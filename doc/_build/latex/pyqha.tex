%% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing }}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{pyqha Documentation}
\date{Oct 23, 2016}
\release{0.1}
\author{Mauro Palumbo}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{introduction:introduction}\label{introduction:welcome-to-pyqha-s-documentation}\label{introduction::doc}\label{introduction:id1}
\sphinxcode{pyqha} is a Python package to perform quasi-harmonic and related calculations from total energies at 0 K, elastic constants at 0 K and phonon densities of states. The package provides Python functions to postprocess the results of your favourite DFT code, such as Quantum Espresso \footnote[1]{\sphinxAtStartFootnote
\url{http://www.quantum-espresso.org/}
} or VASP \footnote[2]{\sphinxAtStartFootnote
\url{https://www.vasp.at/}
}, to obtain quasi-harmonic properties. It is meant to be imported in your own code or used to produce quasi-harmonic results (see the Tutorial part of this documentation). It is also meant for people who want to tinker with the code and adapt it to their own needs. Finally note that you may couple the package with some other available calculation Python tools, such as \href{https://wiki.fysik.dtu.dk/ase/about.html}{ASE} or \href{http://www.aiida.net/}{AiiDA}.
The package is based on numpy, scipy and matplotlib libraries.

A non-exhaustive list of properties which can be obtained using \sphinxcode{pyqha} is:
\begin{itemize}
\item {} 
quasi-harmonic Helmholtz energy for isotropic and anisotropic unit cells

\item {} 
quasi-harmonic thermal expansions for isotropic and anisotropic unit cells

\item {} 
quasi-harmonic bulk modulus for isotropic unit cells

\item {} 
quasi-harmonic heat capacity for isotropic unit cells

\item {} 
quasi-static elastic constants for anisotropic unit cells

\end{itemize}

Current features of the package include:
\begin{itemize}
\item {} 
Fit the total energy \(E_{tot}(V)\) with Murnaghan's equation of state

\item {} 
Fit the total energy \(E_{tot}(a,b,c)\), where \((a,b,c)\) are the lattice parameters of hexagonal, tetragonal, orthorombic cells, using a quadratic or quartic polynomial

\item {} 
Minimize the energy \(E_{tot}(V)+F_{vib}(V,T)\) as a function of temperature with Murnaghan's equation of state

\item {} 
Minimize the energy \(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) as a function of temperature using a quadratic or quartic polynomial

\item {} 
Calculate the quasi-static elastic constant tensor as a function of temperature

\end{itemize}

The equations to obtain these properties are relatively simple, for an introduction on the quasi-harmonic approximation you can see Baroni et al., available online at \url{https://arxiv.org/abs/1112.4977} or \footnote[3]{\sphinxAtStartFootnote
\begin{enumerate}
\setcounter{enumi}{12}
\item {} 
Palumbo, B. Burton, A. Costa e silva, B. Fultz, B. Grabowski, G. Grimvall, B. Hallstedt, O. Hellman, B. Lindahl, A. Schneider, P.E.A. Turchi, and W. Xiong. Physica Status Solidi (B) Basic Research, 251(1):14â€“32, 2014

\end{enumerate}
}. For an introduction on quasi-static elastic constants see \footnote[4]{\sphinxAtStartFootnote
\begin{enumerate}
\setcounter{enumi}{24}
\item {} 
Wang, J. J. Wang, H. Zhang, V. R. Manga, S. L. Shang, L.-Q. Chen, and Z.-K. Liu. Journal of Physics Condensed Matter, 22:225404, 2010.

\end{enumerate}
} Have a look at the very good documentation of the \sphinxstyleemphasis{thermo\_pw} fortran package available at \url{http://qeforge.qe-forge.org/gf/project/thermo\_pw/}.


\section{Installation}
\label{introduction:installation}
You can download all package files from GitHub (\url{https://github.com/mauropalumbo75/pyqha}) and then install it with the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo python setup.py install
\end{sphinxVerbatim}

The most useful functions for the common user are directly accessible from the \sphinxcode{pyqha}. You can import all of them as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

or you can import only the ones you need. The above command also makes available a number of useful constants that you can use for unit conversions.

More functions are available as submodules. See the related documentation for more details. Note, however, that most of these functions are less well documented and are meant for advanced users or if you want to tinker with the code.


\chapter{Tutorial}
\label{tutorial::doc}\label{tutorial:tutorial}\label{tutorial:id1}
This is a simple tutorial demonstrating the main functionalities of \sphinxcode{pyqha}. The examples below show how to use the package to perform the most common tasks. The code examples can be found in the directory \sphinxstyleemphasis{examples} of the package and can be run either as interactive sessions in your Python intepreter or as scripts.
The tutorial is based on the following examples:

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\sphinxstylethead{\relax 
Example n.
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax \\
\hline
1
&
Fit \(E_{tot}(V)\) for a cubic (isotropic) system using Murnaghan EOS
\\
\hline
2
&
Fit \(E_{tot}(a,c)\) for an hexagonal (anisotropic) system  using a polynomial
\\
\hline
3
&
Calculate the harmonic thermodynamic properties (ZPE, vibrational energy, Helmholtz energy, entropy and heat capacity from a phonon DOS
\\
\hline
4
&
Calculate the harmonic thermodynamic properties as in the previous examples from several phonon DOS
\\
\hline
5
&
A quasi-harmonic calculation for a cubic (isotropic) system using Murnaghan EOS
\\
\hline
6
&
A quasi-harmonic calculation for an hexagonal (anisotropic) system  using a quadratic polynomial
\\
\hline
7
&
A quasi-static calculation for the elastic tensor of an hexagonal (anisotropic) system  using a quadratic polynomial
\\
\hline\end{tabulary}


Several simplified plotting functions are available in \sphinxcode{pyqha} and are used in the following tutorial to show what you can plot.
Note however that all plotting functions need the matplotlib library, which must be available on your system and can be used to further taylor your plot.


\section{Fitting the total energy}
\label{tutorial:fitting-the-total-energy}
The simplest task you can do with \sphinxcode{pyqha} is to fit the total energy as a function of volume \(E_{tot}(V)\) (example1) or lattice parameters values \(E_{tot}(a,b,c,\alpha,\beta,\gamma)\) (example2). In the former case, you can use
an equation of state (EOS) such as Murnaghan's or similar. In the latter case, you must use polynomials. Currently the Murnaghan EOS and quadratic and quartic polynomials are implemented in \sphinxcode{pyqha}. Besides, only \(a,b,c\) lattice parameters can be handled. This includes cubic, hexagonal, tetragonal and orthorombic systems.

Let's start with the simpler case where we want to fit \(E_{tot}(V)\). This is the case of isotropic cubic systems (simple cubic, body centered cubic, face centered cubic) or systems which can be approximate as isotropic (for example an hexagonal system with nearly constant \(c/a\) ratio).

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{fitEtotV}\PYG{p}{,} \PYG{n}{plot\PYGZus{}EV}

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./EtotV.dat}\PYG{l+s+s2}{\PYGZdq{}}  		\PYG{c+c1}{\PYGZsh{} file with the total energy data E(V)}
\PYG{n}{V}\PYG{p}{,} \PYG{n}{E}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{chi2} \PYG{o}{=} \PYG{n}{fitEtotV}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{)}    	\PYG{c+c1}{\PYGZsh{} fits the E(V) data, returns the coefficients a and}
                                	\PYG{c+c1}{\PYGZsh{} the chi squared chi2}

\PYG{n}{plot\PYGZus{}EV}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,}\PYG{n}{E}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}                  	\PYG{c+c1}{\PYGZsh{} plot the E(V) data and the fitting line}

\end{sphinxVerbatim}

The \sphinxcode{fitEtotV()} needs in input a file with two columns: the first with the volumes (in \(a.u.^3\)), the second with energies (in \(Ryd/cell\)). It returns the volumes \sphinxstyleemphasis{V} and energies \sphinxstyleemphasis{E} from the input file plus the fitting coefficients \sphinxstyleemphasis{a} and the \(\chi^2\) \sphinxstyleemphasis{chi}. The fitting results are also written in details on the \sphinxstyleemphasis{stdout}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Murnaghan EOS 		 chi squared= 6.3052568895e\PYGZhy{}09}
\PYG{c+c1}{\PYGZsh{} E0= 1.9256061524e+02 Ry	 V0= 1.9256061524e+02 a.u.\PYGZca{}3	 B0= 3.9507615923e+03 kbar	 dB0/dV= 4.7879823925e+00}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{} V *a.u.\PYGZca{}3)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Etot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ (Ry)}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Etotfit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ (Ry)}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Etot\PYGZhy{}Etotfit (Ry)}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{P (kbar)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.7119697047e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668351807e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668351587e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.2057946126e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 6.2382144794e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.7637989181e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668536038e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668536431e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 3.9279193061e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 4.3100002530e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.8166637877e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668660570e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668660710e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 1.4066826679e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 2.6537032641e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.8705745588e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668731355e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668731118e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.3774691499e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 1.2288570223e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.9255414767e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668753764e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668753460e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}3.0400133255e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 1.3270797876e\PYGZhy{}01}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.9815747866e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668732871e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668732783e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}8.8363487976e\PYGZhy{}06}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.0577273936e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.0386847338e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668673220e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668673472e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 2.5137771445e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.9727140701e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.0968815635e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668579007e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668579345e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 3.3763105193e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.7643217490e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.1561755211e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668454001e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668453730e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.7177809670e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}3.4501143525e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Optionally, you can plot the results with the \sphinxcode{plot\_EV()}. The original data are represented as points. If \sphinxstyleemphasis{a!=None}, a line with the fitting EOS will also be plotted. The output plot looks like the following:

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_1}.png}

The second example shows how to fit the total energy of an hexagonal system, i.e. as a function of the lattice parameters \((a,c)\). The input file (\sphinxstyleemphasis{fin}) contains three columns, the first two with the \((a,c)\) (in \(a.u.\)) and the third one with the energies (in \(Ryd/cell\)). Note that if the original data are as \((a,c/a)\), as often reported, you must convert the \(c/a\) values into \(c\) values in the input file.
The \sphinxcode{fitEtot()} reads the input file and perform the fit using either a quadratic or quartic polynomial (as specified by the parameter \sphinxstyleemphasis{fitype}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}  	\PYG{c+c1}{\PYGZsh{} contains the input energies}

\PYG{c+c1}{\PYGZsh{} fits the energies and returns the coeffients a0 and the chi squared chia0}
\PYG{c+c1}{\PYGZsh{} the fit is done with a quartic polynomial}
\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Ex}\PYG{p}{,} \PYG{n}{a0}\PYG{p}{,} \PYG{n}{chia0}\PYG{p}{,} \PYG{n}{mincelldms}\PYG{p}{,} \PYG{n}{fmin} \PYG{o}{=} \PYG{n}{fitEtot}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{guess}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{5.12374914}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{8.19314311}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} 3D plot only with fitted energy}
\PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot fitted energy and points}
\PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy }
\PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{p}{)}

\end{sphinxVerbatim}

The output of the fitting function is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
quartic fit
(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}Etot\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}Etotfit\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}Etot\PYGZhy{}Etotfit\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.8471807981e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668528744e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668528745e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.0725036494e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.9240488978e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668649001e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668649002e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}9.8750206234e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0009169975e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668716783e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668716776e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}7.7131721810e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0777850972e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737355e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737365e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}9.2776986094e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1546531969e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668715550e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668715547e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}3.2629236557e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.9492671099e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668606004e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668606001e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}2.1225582714e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0271352096e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668700587e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668700591e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}3.0630963010e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1050033093e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668744794e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668744800e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}6.7416499405e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1828714090e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743826e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743814e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.2613072613e\PYGZhy{}06\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2607395087e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668702280e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668702285e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}4.9947925618e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0513534218e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668660570e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668660572e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}2.5535950954e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1302215215e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668731355e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668731348e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}7.0765509008e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2090896212e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668753764e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668753765e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}1.0862777344e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2879577209e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668732871e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668732880e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4404246081e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3668258206e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668673220e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668673216e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.0985673877e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1534397336e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668694343e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668694339e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.5153024075e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2333078333e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743061e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743073e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}1.2780792531e\PYGZhy{}06\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3131759330e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668745384e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668745377e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}7.0226747084e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3930440327e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668706178e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668706173e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.6083209782e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4729121324e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668629842e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668629845e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}3.4305685404e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2555260455e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668709188e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668709191e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}3.3864898796e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3363941452e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737584e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737574e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}9.7452812042e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4172622449e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668721346e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668721354e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.8953144111e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4981303446e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668665315e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668665315e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.8681386033e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.5789984443e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668573689e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668573688e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.0538019524e\PYGZhy{}07\PYGZsq{})

Fitted polynomial is: 

p(x1,x2) = \PYGZhy{}1291.10429456 + \PYGZhy{}184.969221276 * x1 + 42.2676103527 * x1\PYGZca{}2 + \PYGZhy{}4.81052197937 * x1\PYGZca{}3 + 0.188178329491 * x1\PYGZca{}4 +
\PYGZhy{}49.1590620388 *x2 + 5.34145510286 *x2\PYGZca{}2 + \PYGZhy{}0.245662970361 *x2\PYGZca{}3 + \PYGZhy{}0.000328650634003 *x2\PYGZca{}4 +
8.48734670683 *x1*x2 + \PYGZhy{}0.67806386411 *x1*x2\PYGZca{}2 + 0.0444127765503 *x1*x2\PYGZca{}3 + \PYGZhy{}0.393401452901 *x1\PYGZca{}2*x2 + \PYGZhy{}0.0458527834065 *x1\PYGZca{}2*x2\PYGZca{}2 +
0.0705006802514 *x1\PYGZca{}3*x2

(\PYGZsq{}Chi squared: \PYGZsq{}, 9.8189738184091843e\PYGZhy{}12, \PYGZsq{}\PYGZbs{}n\PYGZsq{})
(\PYGZsq{}Minimun quartic: \PYGZsq{}, array([ 5.20422739,  0.        ,  8.20917812,  0.        ,  0.        ,  0.        ]), \PYGZsq{}\PYGZbs{}tEnergy at the minimum: \PYGZhy{}1.66687537646403052349e+03\PYGZbs{}n\PYGZsq{})
\end{sphinxVerbatim}

Optionally, you can use the functions \sphinxcode{plot\_Etot()}, \sphinxcode{plot\_Etot\_contour()} to create 3D or contour plots of the fitted energy over the grid \((a,c)\), including or not the original energy points:

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_11}.png}

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_2}.png}

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_3}.png}


\section{Computing thermal properties from phonon DOS}
\label{tutorial:computing-thermal-properties-from-phonon-dos}
\sphinxcode{pyqha} can calculate the vibrational properties of your system from the phonon DOS in the harmonic approximation as shown in \sphinxstyleemphasis{example3}. The DOS file must be a two columns one, the first column being the energy (in \(Ryd/cell\)) and the second column being the density of states (in \((Ryd/cell)^{-1}\)).

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./dos.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{fout} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./thermo}\PYG{l+s+s2}{\PYGZdq{}}  

\PYG{n}{TT} \PYG{o}{=} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} create a numpy array of temperatures from 1 to 1000 step 0.5}

\PYG{n}{E}\PYG{p}{,} \PYG{n}{dos} \PYG{o}{=} \PYG{n}{read\PYGZus{}dos}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} read the dos file. It returns the energies and dos values.}


\PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{ZPE}\PYG{p}{,} \PYG{n}{modes} \PYG{o}{=} \PYG{n}{compute\PYGZus{}thermo}\PYG{p}{(}\PYG{n}{E}\PYG{o}{/}\PYG{n}{RY\PYGZus{}TO\PYGZus{}CMM1}\PYG{p}{,}\PYG{n}{dos}\PYG{o}{*}\PYG{n}{RY\PYGZus{}TO\PYGZus{}CMM1}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{)}
\PYG{n}{write\PYGZus{}thermo}\PYG{p}{(}\PYG{n}{fout}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib}\PYG{p}{,} \PYG{n}{ZPE}\PYG{p}{,} \PYG{n}{modes}\PYG{p}{)}  

\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}
\PYG{c+c1}{\PYGZsh{} plot the original phonon DOS}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,}\PYG{n}{dos}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E (Ryd/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phonon DOS (Ry/cell)\PYGZca{}\PYGZob{}\PYGZhy{}1\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} create several plots for the thermodynamic quantities computed}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Evib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Evib (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Fvib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fvib (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Svib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Svib (Ry/cell/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Cvib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

The output produced by the function \sphinxcode{compute\_thermo()} is stored in the variables \sphinxstyleemphasis{T, Evib, Svib, Cvib, Fvib, ZPE, modes} and can be written in a file using the function \sphinxcode{write\_thermo()}. This output file is as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} total modes from dos = 5.9999726114e+00
\PYGZsh{} ZPE = 5.6214272319e\PYGZhy{}03 Ry/cell
\PYGZsh{} Multiply by 13.6058 to have energies in eV/cell etc..
\PYGZsh{} Multiply by 13.6058 x 23060.35 = 313 754.5 to have energies in cal/(N mol).
\PYGZsh{} Multiply by 13.6058 x 96526.0 = 1 313 313 to have energies in J/(N mol).
\PYGZsh{} N is the number of formula units per cell.
\PYGZsh{}
\PYGZsh{} T (K) 	Evib (Ry/cell)	Fvib (Ry/cell)	Svib (Ry/cell/K)	Cvib (Ry/cell/K)
1.0000000000e+00	5.6214272416e\PYGZhy{}03	5.6214271698e\PYGZhy{}03	7.1803604634e\PYGZhy{}11	2.7457378670e\PYGZhy{}11
1.5000000000e+00	5.6214272660e\PYGZhy{}03	5.6214271296e\PYGZhy{}03	9.0971071082e\PYGZhy{}11	7.6156598111e\PYGZhy{}11
2.0000000000e+00	5.6214273247e\PYGZhy{}03	5.6214270765e\PYGZhy{}03	1.2411743622e\PYGZhy{}10	1.6670823649e\PYGZhy{}10
2.5000000000e+00	5.6214274420e\PYGZhy{}03	5.6214270023e\PYGZhy{}03	1.7586528823e\PYGZhy{}10	3.1294495785e\PYGZhy{}10
3.0000000000e+00	5.6214276492e\PYGZhy{}03	5.6214268967e\PYGZhy{}03	2.5083680991e\PYGZhy{}10	5.2875068522e\PYGZhy{}10
3.5000000000e+00	5.6214279847e\PYGZhy{}03	5.6214267469e\PYGZhy{}03	3.5365843213e\PYGZhy{}10	8.2803005242e\PYGZhy{}10
4.0000000000e+00	5.6214284935e\PYGZhy{}03	5.6214265377e\PYGZhy{}03	4.8896152188e\PYGZhy{}10	1.2247123119e\PYGZhy{}09
4.5000000000e+00	5.6214292279e\PYGZhy{}03	5.6214262517e\PYGZhy{}03	6.6138346588e\PYGZhy{}10	1.7327611278e\PYGZhy{}09
5.0000000000e+00	5.6214302472e\PYGZhy{}03	5.6214258693e\PYGZhy{}03	8.7556952905e\PYGZhy{}10	2.3661903162e\PYGZhy{}09
5.5000000000e+00	5.6214316174e\PYGZhy{}03	5.6214253684e\PYGZhy{}03	1.1361755892e\PYGZhy{}09	3.1390850039e\PYGZhy{}09
6.0000000000e+00	5.6214334118e\PYGZhy{}03	5.6214247246e\PYGZhy{}03	1.4478717445e\PYGZhy{}09	4.0656278651e\PYGZhy{}09
6.5000000000e+00	5.6214357110e\PYGZhy{}03	5.6214239112e\PYGZhy{}03	1.8153467817e\PYGZhy{}09	5.1601305330e\PYGZhy{}09
7.0000000000e+00	5.6214386024e\PYGZhy{}03	5.6214228992e\PYGZhy{}03	2.2433135214e\PYGZhy{}09	6.4370706688e\PYGZhy{}09
7.5000000000e+00	5.6214421809e\PYGZhy{}03	5.6214216571e\PYGZhy{}03	2.7365150966e\PYGZhy{}09	7.9111356177e\PYGZhy{}09
8.0000000000e+00	5.6214465489e\PYGZhy{}03	5.6214201510e\PYGZhy{}03	3.2997322753e\PYGZhy{}09	9.5972742802e\PYGZhy{}09
8.5000000000e+00	5.6214518161e\PYGZhy{}03	5.6214183448e\PYGZhy{}03	3.9377920199e\PYGZhy{}09	1.1510759902e\PYGZhy{}08
9.0000000000e+00	5.6214581001e\PYGZhy{}03	5.6214161999e\PYGZhy{}03	4.6555775947e\PYGZhy{}09	1.3667267917e\PYGZhy{}08
9.5000000000e+00	5.6214655265e\PYGZhy{}03	5.6214136752e\PYGZhy{}03	5.4580406777e\PYGZhy{}09	1.6082974484e\PYGZhy{}08
1.0000000000e+01	5.6214742291e\PYGZhy{}03	5.6214107269e\PYGZhy{}03	6.3502160901e\PYGZhy{}09	1.8774682469e\PYGZhy{}08
1.0500000000e+01	5.6214843502e\PYGZhy{}03	5.6214073091e\PYGZhy{}03	7.3372398855e\PYGZhy{}09	2.1759981704e\PYGZhy{}08
1.1000000000e+01	5.6214960411e\PYGZhy{}03	5.6214033730e\PYGZhy{}03	8.4243715943e\PYGZhy{}09	2.5057449144e\PYGZhy{}08
1.1500000000e+01	5.6215094629e\PYGZhy{}03	5.6213988672e\PYGZhy{}03	9.6170213626e\PYGZhy{}09	2.8686891747e\PYGZhy{}08
1.2000000000e+01	5.6215247869e\PYGZhy{}03	5.6213937375e\PYGZhy{}03	1.0920782549e\PYGZhy{}08	3.2669631041e\PYGZhy{}08
1.2500000000e+01	5.6215421953e\PYGZhy{}03	5.6213879269e\PYGZhy{}03	1.2341470051e\PYGZhy{}08	3.7028823823e\PYGZhy{}08
1.3000000000e+01	5.6215618826e\PYGZhy{}03	5.6213813755e\PYGZhy{}03	1.3885164240e\PYGZhy{}08	4.1789809033e\PYGZhy{}08
1.3500000000e+01	5.6215840567e\PYGZhy{}03	5.6213740202e\PYGZhy{}03	1.5558259988e\PYGZhy{}08	4.6980467173e\PYGZhy{}08
1.4000000000e+01	5.6216089398e\PYGZhy{}03	5.6213657946e\PYGZhy{}03	1.7367519841e\PYGZhy{}08	5.2631576208e\PYGZhy{}08
1.4500000000e+01	5.6216367707e\PYGZhy{}03	5.6213566288e\PYGZhy{}03	1.9320130039e\PYGZhy{}08	5.8777146866e\PYGZhy{}08
1.5000000000e+01	5.6216678056e\PYGZhy{}03	5.6213464493e\PYGZhy{}03	2.1423757831e\PYGZhy{}08	6.5454720686e\PYGZhy{}08
1.5500000000e+01	5.6217023209e\PYGZhy{}03	5.6213351785e\PYGZhy{}03	2.3686608350e\PYGZhy{}08	7.2705615875e\PYGZhy{}08
1.6000000000e+01	5.6217406143e\PYGZhy{}03	5.6213227346e\PYGZhy{}03	2.6117479280e\PYGZhy{}08	8.0575108690e\PYGZhy{}08
1.6500000000e+01	5.6217830073e\PYGZhy{}03	5.6213090314e\PYGZhy{}03	2.8725811574e\PYGZhy{}08	8.9112541358e\PYGZhy{}08
\end{sphinxVerbatim}

The first line is the simple integral of the input dos. It must be approximately equal to \(3N\), where \sphinxstyleemphasis{N} is the number of atoms in the cell. In the present case (hex Os) it is equal to 6. The second line shows the Zero Point Energy (ZPE). After a few comments lines, the vibrational energy (Evib), Helmholtz energy (Fvib), entropy (Svib) and heat capacity (Cvib) are written as a function of temperature. All quantities are calculated in the harmonic approximation, i.e. for fixed volume (and lattice parameters).

The original dos is plotted as:

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_12}.png}

The calculated thermodynaminc functions are plotted as:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_21}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_31}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_4}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_5}.png}

The following code (example4) shows how multiple dos files can be handled, a step which is preliminary to a quasi-harmonic calculation. The dos are for different volumes (for hexagonal Os).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fout} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{9}				

\PYG{n}{gE}\PYG{p}{,} \PYG{n}{gdos} \PYG{o}{=} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{)} 	\PYG{c+c1}{\PYGZsh{} read ngeo=9 dos files}


\PYG{c+c1}{\PYGZsh{} plot the first 5 phonon dos    }
\PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{gE}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{gdos}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E (Ryd/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phonon DOS (cell/Ryd)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{TT} \PYG{o}{=}\PYG{n}{gen\PYGZus{}TT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}

\PYG{c+c1}{\PYGZsh{} compute the thermodynamic properties for all ngeo dos files and write them in fout+\PYGZdq{}i\PYGZdq{} files, where is an int from 1 to ngeo}
\PYG{n}{T}\PYG{p}{,} \PYG{n}{ggEvib}\PYG{p}{,} \PYG{n}{ggFvib}\PYG{p}{,} \PYG{n}{ggSvib}\PYG{p}{,} \PYG{n}{ggCvib}\PYG{p}{,} \PYG{n}{ggZPE}\PYG{p}{,} \PYG{n}{ggmodes} \PYG{o}{=} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{fout}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the vibrational Helmholtz energy for the first 5 phonon dos    }
\PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ggFvib}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the vibrational entropy for the first 5 phonon dos    }
\PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ggSvib}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the vibrational heat capacity for the first 5 phonon dos    }
\PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ggCvib}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

The first 5 phonon dos are plotted as (color order is: black, red, blue, green, cyan for increasing volumes):

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_13}.png}

The corresponding vibrational Helmoltz energies, entropies and heat capacity are plotted as:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_22}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_32}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_41}.png}


\section{Computing quasi-harmonic properties}
\label{tutorial:computing-quasi-harmonic-properties}
Here we show how to do a full quasi-harmonic calculation starting from the \(E_{tot}\) and phonon DOS. First, we show an example using the Murnaghan EOS, having \(E_{tot}(V)\) and the corresponding DOS, then using a quartic polynomial on the full grid \((a,c)\) for an hexagonal cell.

Here is the code in the Murnaghan case:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{RY\PYGZus{}KBAR}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{,} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{fitFvibV}\PYG{p}{,} \PYG{n}{write\PYGZus{}xy}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}

\PYG{c+c1}{\PYGZsh{} this part is for calculating the thermodynamic properties from the dos}
\PYG{n}{fdos}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fthermo} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{9}	\PYG{c+c1}{\PYGZsh{} this is the number of volumes for which a dos has been calculated			}

\PYG{n}{TT} \PYG{o}{=}\PYG{n}{gen\PYGZus{}TT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}
\PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib}\PYG{p}{,} \PYG{n}{ZPE}\PYG{p}{,} \PYG{n}{modes} \PYG{o}{=} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fdos}\PYG{p}{,}\PYG{n}{fthermo}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{)}
\PYG{n}{nT} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Alternatively, read the thermodynamic data from files, if you have already}
\PYG{c+c1}{\PYGZsh{} done the calculations. Uncomment the following 2 lines and delete the previous 3 lines}
\PYG{c+c1}{\PYGZsh{}T1, Evib1, Fvib1, Svib1, Cvib1 = read\PYGZus{}thermo( fthermo, ngeo )}
\PYG{c+c1}{\PYGZsh{}T, T, Evib, Fvib, Svib, Cvib = rearrange\PYGZus{}thermo( T1, Evib1, Fvib1, Svib1, Cvib1, ngeo )    }


\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{thermodata} \PYG{o}{=} \PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} 
\PYG{n}{TT}\PYG{p}{,} \PYG{n}{Fmin}\PYG{p}{,} \PYG{n}{Vmin}\PYG{p}{,} \PYG{n}{B0}\PYG{p}{,} \PYG{n}{betaT}\PYG{p}{,} \PYG{n}{Cv}\PYG{p}{,} \PYG{n}{Cp}\PYG{p}{,} \PYG{n}{aT}\PYG{p}{,} \PYG{n}{chi} \PYG{o}{=} \PYG{n}{fitFvibV}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{)}

\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Fmin}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Vmin}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Vmin (a.u.\PYGZca{}3)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{B0}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B0 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{betaT}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{beta}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Cp}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cp (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} save the results in a file if you want...}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Fmin}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin (Ryd/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Vmin.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Vmin}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Vmin (a.u.\PYGZca{}3)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B0.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{B0}\PYG{o}{*}\PYG{n}{RY\PYGZus{}KBAR}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B0 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{beta.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,} \PYG{n}{betaT}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Beta=1/V dV/dT (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{n}{CvCp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CvCp}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Cv}
\PYG{n}{CvCp}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Cp}
\PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CvCp}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cv/Cp (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{print\PYGZus{}eos\PYGZus{}data}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,}\PYG{n}{E}\PYG{o}{+}\PYG{n}{Fvib}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{a}\PYG{p}{,}\PYG{n}{chi}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} print full detail at each T}

\end{sphinxVerbatim}

Note from the first line that there are some constants you can import from the module and use for unit conversions. See the documentation for more details on which ones are available.
In this example, 9 volumes are used (ngeo=9). First the harmonic thermodynamic properties are computed as in the previous example. You store these quantities in a list called \sphinxstyleemphasis{thermodata}. You also need to read the total energies as in example 1 from the file \sphinxstyleemphasis{Etot.dat}, which is taken care inside the function \sphinxcode{fitEtotV()}. This is the function which is really doing the quasi-harmonic calculations, i.e. it fits a Murnaghan EOS at each T using \(E_{tot}(V)+F_{vib}(V,T)\). It returns \sphinxstyleemphasis{TT, Fmin, Vmin, B0, betaT, Cv, Cp}, which are all numpy 1D arrays containing the temperatures where the calculations were done and the resulting minimun Helmholtz energy (at each T), minimun volume, isobaric bulk modulus, volume thermal expansion, constant volume and constant pressure heat capacities, respectively. These quantities correspond to \(P=0\).

The following lines show how to plot each quantity on a single plot (using the function \sphinxcode{simple\_plot\_xy()}), write the results in files (using the \sphinxcode{write\_xy()}) and plot both \sphinxstyleemphasis{Cv} and \sphinxstyleemphasis{Cp} in a single plot (using the function \sphinxcode{multiple\_plot\_xy()}).

If everything went well, you should get the following plots:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_14}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_23}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_33}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_42}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_51}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_6}.png}

In the following we show the code for a similar example of an hexagonal (anisotropic) system. The code is similar to the previous examples with a few important differences.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{RY\PYGZus{}KBAR}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{,} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{fitFvib}\PYG{p}{,} \PYG{n}{write\PYGZus{}celldmsT}\PYG{p}{,} \PYG{n}{write\PYGZus{}alphaT}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}

\PYG{c+c1}{\PYGZsh{} this part is for calculating the thermodynamic properties from the dos}
\PYG{n}{fdos}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fthermo} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{25}	\PYG{c+c1}{\PYGZsh{} this is the number of volumes for which a dos has been calculated			}

\PYG{n}{TT} \PYG{o}{=}\PYG{n}{gen\PYGZus{}TT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}
\PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib}\PYG{p}{,} \PYG{n}{ZPE}\PYG{p}{,} \PYG{n}{modes} \PYG{o}{=} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fdos}\PYG{p}{,}\PYG{n}{fthermo}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{)}
\PYG{n}{nT} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Alternatively, read the thermodynamic data from files if you have already}
\PYG{c+c1}{\PYGZsh{} done the calculations}
\PYG{c+c1}{\PYGZsh{}T1, Evib1, Fvib1, Svib1, Cvib1 = read\PYGZus{}thermo( fthermo, ngeo )}
\PYG{c+c1}{\PYGZsh{}nT, T, Evib, Fvib, Svib, Cvib = rearrange\PYGZus{}thermo( T1, Evib1, Fvib1, Svib1, Cvib1, ngeo )    }


\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{thermodata} \PYG{o}{=} \PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} 
\PYG{n}{TT}\PYG{p}{,} \PYG{n}{Fmin}\PYG{p}{,} \PYG{n}{celldmsminT}\PYG{p}{,} \PYG{n}{alphaT}\PYG{p}{,} \PYG{n}{a0}\PYG{p}{,} \PYG{n}{chi}\PYG{p}{,} \PYG{n}{aT}\PYG{p}{,} \PYG{n}{chi} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{)}

\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Fmin}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{/}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c/a }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{alphaT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}xx (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{alphaT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}zz (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} write a(T) and c(T) on a file}
\PYG{n}{write\PYGZus{}celldmsT}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{celldmminT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} write alpha\PYGZus{}xx(T) and alpha\PYGZus{}zz(T) on a file}
\PYG{n}{write\PYGZus{}alphaT}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alphaT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{alphaT}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot several quantities at T=998+1 K as an example}
\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Ex} \PYG{o}{=} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} since the fitFvib does not return Etot data, you must read them from the original file}
\PYG{n}{iT}\PYG{o}{=}\PYG{l+m+mi}{998}                  \PYG{c+c1}{\PYGZsh{} this is the index of the temperatures array, not the temperature itself}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T= }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot only with fitted energy (Etot+Fvib)}
\PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{o}{+}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot fitted energy and points}
\PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{+}\PYG{n}{Fvib}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{o}{+}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot with fitted energy Fvib only}
\PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy (Etot+Fvib)}
\PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{o}{+}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy Fvib only}
\PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}   

\end{sphinxVerbatim}

If everything went well,  you should get the following plots:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_15}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_24}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_34}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_43}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_52}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_61}.png}


\section{Computing quasi-static elastic constant}
\label{tutorial:computing-quasi-static-elastic-constant}
The following code example shows how to do a calculation of a quasi-static elastic tensor as a function of temperature for an hexagonal system. This kind of calculation requires that a quasi-harmonic calculation has already be done (as in example 6). Besides, the elastic constants for different \((a,c)\) values must be available. To compute these elastic constants you can use for example the thermo\_pw code \footnote[1]{\sphinxAtStartFootnote
\url{http://qeforge.qe-forge.org/gf/project/thermo\_pw/}
}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{RY\PYGZus{}KBAR}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{,} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{fitFvib}\PYG{p}{,} \PYG{n}{write\PYGZus{}celldmsT}\PYG{p}{,} \PYG{n}{write\PYGZus{}alphaT}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{read\PYGZus{}elastic\PYGZus{}constants\PYGZus{}geo}\PYG{p}{,} \PYG{n}{write\PYGZus{}C\PYGZus{}geo}\PYG{p}{,} \PYG{n}{write\PYGZus{}CT}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}Cx}\PYG{p}{,} \PYG{n}{fitCxx}\PYG{p}{,} \PYG{n}{fitCT}

\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Ex} \PYG{o}{=} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} since the fitFvib does not return Etot data, you must read them from the original file}
    
\PYG{c+c1}{\PYGZsh{} this part is for calculating the thermodynamic properties from the dos}
\PYG{n}{fdos}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fthermo} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{25}	\PYG{c+c1}{\PYGZsh{} this is the number of volumes for which a dos has been calculated  }

\PYG{c+c1}{\PYGZsh{}TT =gen\PYGZus{}TT(1,1000)	\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}
\PYG{c+c1}{\PYGZsh{}T, Evib, Fvib, Svib, Cvib, ZPE, modes = compute\PYGZus{}thermo\PYGZus{}geo(fdos,fthermo,ngeo,TT)}
\PYG{c+c1}{\PYGZsh{}nT = len(T)}

\PYG{c+c1}{\PYGZsh{} Alternatively, read the thermodynamic data from files if you have already}
\PYG{c+c1}{\PYGZsh{} done the calculations}
\PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1} \PYG{o}{=} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{fthermo}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}
\PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} \PYG{o}{=} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}   

\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{thermodata} \PYG{o}{=} \PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} 
\PYG{n}{TT}\PYG{p}{,} \PYG{n}{Fmin}\PYG{p}{,} \PYG{n}{celldmsminT}\PYG{p}{,} \PYG{n}{alphaT}\PYG{p}{,} \PYG{n}{a0}\PYG{p}{,} \PYG{n}{chi}\PYG{p}{,} \PYG{n}{aT}\PYG{p}{,} \PYG{n}{chi} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{typeEtot}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{typeFvib}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{defaultguess}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{5.12374914}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{8.19314311}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Now start the quasi\PYGZhy{}static calculation    }
\PYG{n}{fC} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./elastic\PYGZus{}constants/output\PYGZus{}el\PYGZus{}cons.g}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Read the elastic constants and compliances from files }
\PYG{n}{Cx}\PYG{p}{,} \PYG{n}{Sx} \PYG{o}{=} \PYG{n}{read\PYGZus{}elastic\PYGZus{}constants\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fC}\PYG{p}{,} \PYG{n}{ngeo}\PYG{p}{)}    
\PYG{n}{Cxx} \PYG{o}{=} \PYG{n}{rearrange\PYGZus{}Cx}\PYG{p}{(}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} rearrange them in the proper order for fitting}

\PYG{c+c1}{\PYGZsh{} Optionally save them}
\PYG{n}{write\PYGZus{}C\PYGZus{}geo}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Cxx}\PYG{p}{,} \PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{fCout}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./elastic\PYGZus{}constants/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fit the elastic constants as a function of celldmsx}
\PYG{n}{aC}\PYG{p}{,} \PYG{n}{chiC} \PYG{o}{=} \PYG{n}{fitCxx}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Cxx}\PYG{p}{,} \PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{typeC}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{T}\PYG{p}{,} \PYG{n}{CT} \PYG{o}{=} \PYG{n}{fitCT}\PYG{p}{(}\PYG{n}{aC}\PYG{p}{,} \PYG{n}{chiC}\PYG{p}{,} \PYG{n}{TT}\PYG{p}{,} \PYG{n}{celldmsminT}\PYG{p}{,} \PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{typeC}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
       
\PYG{n}{write\PYGZus{}CT}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{,}\PYG{n}{fCout}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./elastic\PYGZus{}constants/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C11 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C12 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C13 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C33 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot now 4 elastic constants in the same plot}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{n}{pCxx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{Clabels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C11}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C12}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C13}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C33}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{pCxx}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cxx (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{n}{Clabels}\PYG{p}{)}

\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_16}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_25}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_35}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_44}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_53}.png}


\chapter{pyqha package}
\label{pyqha:pyqha-package}\label{pyqha::doc}

\section{Module contents}
\label{pyqha:module-contents}
The following functions are available from \sphinxcode{pyqha} module and are the most common ones for the end user.
\phantomsection\label{pyqha:module-pyqha.fitEtot}\index{pyqha.fitEtot (module)}\index{fitEtot() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitEtot.fitEtot}\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtot}}{\emph{fin}, \emph{out=True}, \emph{ibrav=4}, \emph{fittype='quadratic'}, \emph{guess=None}}{}
This function reads the file \sphinxstyleemphasis{fin} containing the energies as a function
of the lattice parameters \(E(a,b,c)\) and fits them with a quartic (\sphinxstyleemphasis{fittype=''quartic''}) or 
quadratic (\sphinxstyleemphasis{fittype=''quadratic''}) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redericted to \sphinxstyleemphasis{stdout})
if \sphinxstyleemphasis{out=True}.
It returns the lattice parameters and energies as in the input file \sphinxstyleemphasis{fin},
the fitted coefficients of the polynomial, the corresponding \(\chi^2\),
the lattice parameters at the minimum and the minimun energy.

Note: for cubic systems use fitEtotV instead.

\end{fulllineitems}

\index{fitEtotV() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitEtot.fitEtotV}\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtotV}}{\emph{fin}, \emph{fout=None}}{}
This function reads \(E(V)\) data from the input file \sphinxstyleemphasis{fin}, fits them with a Murnaghan EOS,
prints the results on the \sphinxstyleemphasis{stdout} and write them in the file ``fout''.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding \(\chi^2\).

\end{fulllineitems}

\phantomsection\label{pyqha:module-pyqha.thermo}\index{pyqha.thermo (module)}\index{compute\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.compute_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo}}{\emph{E}, \emph{dos}, \emph{TT}}{}
This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays \sphinxstyleemphasis{E} 
and \sphinxstyleemphasis{dos} containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array \sphinxstyleemphasis{TT}.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to \(3*N\), with \sphinxstyleemphasis{N} the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.

\end{fulllineitems}

\index{compute\_thermo\_geo() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.compute_thermo_geo}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo\_geo}}{\emph{fin}, \emph{fout=None}, \emph{ngeo=1}, \emph{TT=array({[}1{]})}}{}
This function reads the input dos file(s) from \sphinxstyleemphasis{fin+i}, with \sphinxstyleemphasis{i} a number from
1 to \sphinxstyleemphasis{ngeo} + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
T
\unskip}\relax &
\(E_{vib}\)
&
\(F_{vib}\)
&
\(S_{vib}\)
&
\(C_{vib}\)
\\
\hline
1
&
...
&
...
&
...
&
...
\\
\hline\end{tabulary}


and are names \sphinxstyleemphasis{fout} +1, \sphinxstyleemphasis{fout} +2,... for each geometry.

Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib{[}T,geo{]} -\textgreater{} Fvib at the temperature ``T'' for the geometry ``geo''

\end{fulllineitems}

\index{dos\_integral() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.dos_integral}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{dos\_integral}}{\emph{E}, \emph{dos}, \emph{m=0}}{}
A function to compute the integral of an input phonon DOS (\sphinxstyleemphasis{dos}) with the 3/8 Simpson method.
\sphinxstyleemphasis{m} is the moment of the integral, if \(m>0\) different moments can be calculated.
For example, with \(m=0\) (default) it returns the number of modes from the dos, 
with \(m=1\) it returns the ZPE. The input energy (\sphinxstyleemphasis{E}) and phonon DOS (\sphinxstyleemphasis{dos}) are expected to be in
\(cm^{-1}\).

\end{fulllineitems}

\index{gen\_TT() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.gen_TT}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{gen\_TT}}{\emph{Tstart=1}, \emph{Tend=1000}, \emph{Tstep=1}}{}
A simple function to generate a numpy array of temperatures, starting from
\sphinxstyleemphasis{Tstart} and ending to \sphinxstyleemphasis{Tend} (or the closest \sphinxstyleemphasis{T\textless{}Tend} accorinding to the \sphinxstyleemphasis{Tstep} )
with step \sphinxstyleemphasis{Tstep} .

\end{fulllineitems}

\index{rearrange\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.rearrange_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{rearrange\_thermo}}{\emph{T}, \emph{Evib}, \emph{Fvib}, \emph{Svib}, \emph{Cvib}, \emph{ngeo=1}}{}
This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices \sphinxstyleemphasis{X} now gives all geometries at a given
\sphinxstyleemphasis{T}, i.e. \sphinxstyleemphasis{X{[}0{]}} is the vector of the property \sphinxstyleemphasis{X} a \sphinxstyleemphasis{T=T{[}0,0{]}} . \sphinxstyleemphasis{X{[}0,0{]}} for the first 
geometry, \sphinxstyleemphasis{X{[}0,1{]}} the second geometry and so on.

\end{fulllineitems}

\phantomsection\label{pyqha:module-pyqha.fitFvib}\index{pyqha.fitFvib (module)}\index{fitFvib() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitFvib.fitFvib}\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvib}}{\emph{fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess={[}0.0, 0.0, 0.0, 0.0, 0.0, 0.0{]}}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(a,b,c)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(a,b,c,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in \sphinxstyleemphasis{fin} file. The 
real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

The function fits \(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) with a quadratic
or quartic polynomial (as defined by \sphinxstyleemphasis{typeEtot} and \sphinxstyleemphasis{typeFvib} ) at each
temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting \(E_{tot}(a,b,c)\)
and \(F_{vib}(a,b,c)\). Then it computes the minimun energy \(E_{tot}+F_{vib}\)
and the corresponding lattice parameters \((a_{min},b_{min},c_{min})\) 
at each temperature by miniimizing the energy.

It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (\sphinxcode{compute\_alpha()}).

It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the \(\chi^2\) for \(E_{tot}(a,b,c)\) 
only (at T=0 K) and the fitted coefficients and the \(\chi^2\) for 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) at each temperature.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example6} and 
the tutorial.
\end{sphinxadmonition}

\end{fulllineitems}

\index{fitFvibV() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitFvib.fitFvibV}\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvibV}}{\emph{fin}, \emph{thermodata}, \emph{verbosity='low'}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(V)+F_{vib}(V,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(V)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(V,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in \sphinxstyleemphasis{fin} file.

The function fits \(E_{tot}(V)+F_{vib}(V,T)\) with a Murnaghan's EOS
at each temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (\sphinxcode{compute\_beta()}), the
constant volume heat capacity at the minimum volume at each T
(\sphinxcode{compute\_Cv()}) and the constant pression heat capacity (\sphinxcode{compute\_Cp()}).

It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the \(\chi^2\) at each T.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example5} and 
the tutorial.
\end{sphinxadmonition}

\end{fulllineitems}

\phantomsection\label{pyqha:module-pyqha.fitC}\index{pyqha.fitC (module)}\index{fitCT() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.fitCT}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCT}}{\emph{aC}, \emph{chiC}, \emph{T}, \emph{minT}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function calculates the elastic constants tensor \sphinxstyleemphasis{CT} as a function of
temperatature in the quasi-static approximation.
It takes in input \sphinxstyleemphasis{aC} and \sphinxstyleemphasis{chiC}, the fitted coefficients of the elastic 
constants as a function of \((a,b,c)\) and the corresponding \(\chi^2\).
It also takes in input an array of temperatures \sphinxstyleemphasis{T} and the corresponding
lattice parameters \sphinxstyleemphasis{minT}, i.e. \((a_{min},b_{min},c_{min})\) from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( \sphinxstyleemphasis{ibrav} ) and the type of polynomial
( \sphinxstyleemphasis{typeC} ) used for fitting the input \sphinxstyleemphasis{aC}.

The function uses the coefficients \sphinxstyleemphasis{aC} to compute the elastic tensor at
each temperature in the array \sphinxstyleemphasis{T} from the corresponding lattice parameters
\((a_{min},b_{min},c_{min})\) in \sphinxstyleemphasis{minT}.

It returns the temperature array and the a matrix \sphinxstyleemphasis{CT} with all the elastic
tensors at each T ( \sphinxstyleemphasis{CT{[}i{]}} is the elastic constants matrix for the 
temperature \sphinxstyleemphasis{T{[}i{]}})

\begin{sphinxadmonition}{warning}{Warning:}
The coefficients \sphinxstyleemphasis{aC} must be the result of fitting the elastic constants
over the same \((a,b,c)\) grid used in the quasi-harmonic calculations
corresponding to \sphinxstyleemphasis{minT} values! (See example7)
\end{sphinxadmonition}

\end{fulllineitems}

\index{fitCxx() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.fitCxx}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCxx}}{\emph{celldmsx}, \emph{Cxx}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function fits the elastic constant elements of \sphinxstyleemphasis{Cxx} as a function of the
grid of lattice parameters \((a,b,c)\). 
The real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

It returns a 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the corresponding
\(\chi^2\). If the chi squared is zero, the fitting procedure was NOT succesful

\end{fulllineitems}

\index{rearrange\_Cx() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.rearrange_Cx}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{rearrange\_Cx}}{\emph{Cx}, \emph{ngeo}}{}
This function rearrange the input numpy matrix \sphinxstyleemphasis{Cx} into an equivalent matrix \sphinxstyleemphasis{Cxx}
for fitting it.
\sphinxstyleemphasis{Cx} is a \(ngeo*6*6\) matrix, each \sphinxstyleemphasis{Cx{[}i{]}} is the 6*6 \sphinxstyleemphasis{C} matrix for a given geometry ( \sphinxstyleemphasis{i} )
\sphinxstyleemphasis{Cxx} is a Lmath:\sphinxtitleref{6*6*ngeo} matrix, each \sphinxstyleemphasis{Cxx{[}i{]}{[}j{]}} is a vector with all values for different
geometries of the \sphinxstyleemphasis{Cij} elastic constant matrix element. For example, \sphinxstyleemphasis{Cxx{[}0,0{]}}
is the vector with ngeo values of the \sphinxstyleemphasis{C11} elastic constant and so on.

\end{fulllineitems}



\section{Submodules}
\label{pyqha:submodules}
Additional functions are available as submodules. Please note the documentation of these functions is still ongoing and can be incomplete or wrong.


\section{pyqha.constants module}
\label{pyqha:pyqha-constants-module}\label{pyqha:module-pyqha.constants}\index{pyqha.constants (module)}
Some useful standard constants for conversions and calculations.


\section{pyqha.eos module}
\label{pyqha:pyqha-eos-module}\label{pyqha:module-pyqha.eos}\index{pyqha.eos (module)}\index{E\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.E_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{E\_Murn}}{\emph{V}, \emph{a}}{}
As {\hyperref[pyqha:pyqha.eos.E_MurnV]{\sphinxcrossref{\sphinxcode{E\_MurnV()}}}} but input parameters are given as a single list 
\sphinxstyleemphasis{a={[}a0,a1,a2,a3{]}}.

\end{fulllineitems}

\index{E\_MurnV() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.E_MurnV}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{E\_MurnV}}{\emph{V}, \emph{a0}, \emph{a1}, \emph{a2}, \emph{a3}}{}
This function implements the Murnaghan EOS (in a form which is best for fitting).
Returns the energy at the volume \sphinxstyleemphasis{V} using the coefficients \sphinxstyleemphasis{a0,a1,a2,a3} 
from the equation:
\begin{equation*}
\begin{split}a_0 - (a_2*a_1)/(a_3-1.0) V a_2/a_3 ( a_1/V^{a_3})/(a_3-1.0) +1.0 )\end{split}
\end{equation*}
\end{fulllineitems}

\index{H\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.H_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{H\_Murn}}{\emph{V}, \emph{a}}{}
This function return

As {\hyperref[pyqha:pyqha.eos.E_MurnV]{\sphinxcrossref{\sphinxcode{E\_MurnV()}}}} but input parameters are given as a single list 
\sphinxstyleemphasis{a={[}a0,a1,a2,a3{]}} and it returns the pressure not the energy from the EOS.

\end{fulllineitems}

\index{P\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.P_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{P\_Murn}}{\emph{V}, \emph{a}}{}
As {\hyperref[pyqha:pyqha.eos.E_MurnV]{\sphinxcrossref{\sphinxcode{E\_MurnV()}}}} but input parameters are given as a single list 
\sphinxstyleemphasis{a={[}a0,a1,a2,a3{]}} and it returns the pressure not the energy from the EOS.

\end{fulllineitems}

\index{calculate\_fitted\_points() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.calculate_fitted_points}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{calculate\_fitted\_points}}{\emph{V}, \emph{a}}{}
Calculates a denser mesh of E(V) points for plotting...

\end{fulllineitems}

\index{compute\_Cp() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.compute_Cp}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{compute\_Cp}}{\emph{T}, \emph{Cv}, \emph{V}, \emph{B0}, \emph{beta}}{}
This function computes the isobaric heat capacity from the eq. Cp-Cv=...
Not implemented yet.

\end{fulllineitems}

\index{compute\_Cv() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.compute_Cv}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{compute\_Cv}}{\emph{T}, \emph{Vmin}, \emph{V}, \emph{Cvib}}{}
This function computes the isocoric heat capacity as a function of temperature.
From \sphinxstyleemphasis{Cvib}, which is a matrix with \sphinxstyleemphasis{Cvib(T,V)} as from the harmonic calculations
determines the \sphinxstyleemphasis{Cv} at each temperature by linear interpolation between the values
at the two volumes closest to Vmin(T). Vmin(T) is from the minimization of F(V,T)
and \sphinxstyleemphasis{V} is the array of volumes used for it.
Returns \sphinxstyleemphasis{Cv(T)}.

Not implemented yet.

\end{fulllineitems}

\index{compute\_beta() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.compute_beta}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{compute\_beta}}{\emph{minT}}{}
This function computes the volumetric thermal expansion as a numerical
derivative of the volume as a function of temperature V(T). This is obtained
from the free energy minimization which should be done before.

\end{fulllineitems}

\index{fit\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.fit_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{fit\_Murn}}{\emph{V}, \emph{E}}{}
This is the function for fitting with the Murnaghan EOS as a function of volume only.

The input variable V is an 1D array of volumes, E are the corresponding 
energies (or other analogous quantity to be fitted with the Murnaghan EOS.

\end{fulllineitems}

\index{print\_eos\_data() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.print_eos_data}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{print\_eos\_data}}{\emph{x}, \emph{y}, \emph{a}, \emph{chi}, \emph{ylabel='Etot'}}{}
Print the data and the fitted results using the EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be ``Etot'', 
``Fvib'', etc.

\end{fulllineitems}

\index{write\_Etotfitted() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.write_Etotfitted}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{write\_Etotfitted}}{\emph{filename}, \emph{x}, \emph{y}, \emph{a}, \emph{chi}, \emph{ylabel='E'}}{}
Write in filename the data and the fitted results using the EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be ``Etot'', 
``Fvib'', etc.

\end{fulllineitems}



\section{pyqha.fitC module}
\label{pyqha:pyqha-fitc-module}\label{pyqha:module-pyqha.fitC}\index{pyqha.fitC (module)}\index{fitCT() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCT}}{\emph{aC}, \emph{chiC}, \emph{T}, \emph{minT}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function calculates the elastic constants tensor \sphinxstyleemphasis{CT} as a function of
temperatature in the quasi-static approximation.
It takes in input \sphinxstyleemphasis{aC} and \sphinxstyleemphasis{chiC}, the fitted coefficients of the elastic 
constants as a function of \((a,b,c)\) and the corresponding \(\chi^2\).
It also takes in input an array of temperatures \sphinxstyleemphasis{T} and the corresponding
lattice parameters \sphinxstyleemphasis{minT}, i.e. \((a_{min},b_{min},c_{min})\) from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( \sphinxstyleemphasis{ibrav} ) and the type of polynomial
( \sphinxstyleemphasis{typeC} ) used for fitting the input \sphinxstyleemphasis{aC}.

The function uses the coefficients \sphinxstyleemphasis{aC} to compute the elastic tensor at
each temperature in the array \sphinxstyleemphasis{T} from the corresponding lattice parameters
\((a_{min},b_{min},c_{min})\) in \sphinxstyleemphasis{minT}.

It returns the temperature array and the a matrix \sphinxstyleemphasis{CT} with all the elastic
tensors at each T ( \sphinxstyleemphasis{CT{[}i{]}} is the elastic constants matrix for the 
temperature \sphinxstyleemphasis{T{[}i{]}})

\begin{sphinxadmonition}{warning}{Warning:}
The coefficients \sphinxstyleemphasis{aC} must be the result of fitting the elastic constants
over the same \((a,b,c)\) grid used in the quasi-harmonic calculations
corresponding to \sphinxstyleemphasis{minT} values! (See example7)
\end{sphinxadmonition}

\end{fulllineitems}

\index{fitCxx() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCxx}}{\emph{celldmsx}, \emph{Cxx}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function fits the elastic constant elements of \sphinxstyleemphasis{Cxx} as a function of the
grid of lattice parameters \((a,b,c)\). 
The real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

It returns a 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the corresponding
\(\chi^2\). If the chi squared is zero, the fitting procedure was NOT succesful

\end{fulllineitems}

\index{rearrange\_Cx() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{rearrange\_Cx}}{\emph{Cx}, \emph{ngeo}}{}
This function rearrange the input numpy matrix \sphinxstyleemphasis{Cx} into an equivalent matrix \sphinxstyleemphasis{Cxx}
for fitting it.
\sphinxstyleemphasis{Cx} is a \(ngeo*6*6\) matrix, each \sphinxstyleemphasis{Cx{[}i{]}} is the 6*6 \sphinxstyleemphasis{C} matrix for a given geometry ( \sphinxstyleemphasis{i} )
\sphinxstyleemphasis{Cxx} is a Lmath:\sphinxtitleref{6*6*ngeo} matrix, each \sphinxstyleemphasis{Cxx{[}i{]}{[}j{]}} is a vector with all values for different
geometries of the \sphinxstyleemphasis{Cij} elastic constant matrix element. For example, \sphinxstyleemphasis{Cxx{[}0,0{]}}
is the vector with ngeo values of the \sphinxstyleemphasis{C11} elastic constant and so on.

\end{fulllineitems}



\section{pyqha.fitEtot module}
\label{pyqha:pyqha-fitetot-module}\label{pyqha:module-pyqha.fitEtot}\index{pyqha.fitEtot (module)}\index{fitEtot() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtot}}{\emph{fin}, \emph{out=True}, \emph{ibrav=4}, \emph{fittype='quadratic'}, \emph{guess=None}}{}
This function reads the file \sphinxstyleemphasis{fin} containing the energies as a function
of the lattice parameters \(E(a,b,c)\) and fits them with a quartic (\sphinxstyleemphasis{fittype=''quartic''}) or 
quadratic (\sphinxstyleemphasis{fittype=''quadratic''}) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redericted to \sphinxstyleemphasis{stdout})
if \sphinxstyleemphasis{out=True}.
It returns the lattice parameters and energies as in the input file \sphinxstyleemphasis{fin},
the fitted coefficients of the polynomial, the corresponding \(\chi^2\),
the lattice parameters at the minimum and the minimun energy.

Note: for cubic systems use fitEtotV instead.

\end{fulllineitems}

\index{fitEtotV() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtotV}}{\emph{fin}, \emph{fout=None}}{}
This function reads \(E(V)\) data from the input file \sphinxstyleemphasis{fin}, fits them with a Murnaghan EOS,
prints the results on the \sphinxstyleemphasis{stdout} and write them in the file ``fout''.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding \(\chi^2\).

\end{fulllineitems}



\section{pyqha.fitFvib module}
\label{pyqha:pyqha-fitfvib-module}\label{pyqha:module-pyqha.fitFvib}\index{pyqha.fitFvib (module)}\index{fitFvib() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvib}}{\emph{fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess={[}0.0, 0.0, 0.0, 0.0, 0.0, 0.0{]}}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(a,b,c)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(a,b,c,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in \sphinxstyleemphasis{fin} file. The 
real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

The function fits \(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) with a quadratic
or quartic polynomial (as defined by \sphinxstyleemphasis{typeEtot} and \sphinxstyleemphasis{typeFvib} ) at each
temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting \(E_{tot}(a,b,c)\)
and \(F_{vib}(a,b,c)\). Then it computes the minimun energy \(E_{tot}+F_{vib}\)
and the corresponding lattice parameters \((a_{min},b_{min},c_{min})\) 
at each temperature by miniimizing the energy.

It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (\sphinxcode{compute\_alpha()}).

It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the \(\chi^2\) for \(E_{tot}(a,b,c)\) 
only (at T=0 K) and the fitted coefficients and the \(\chi^2\) for 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) at each temperature.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example6} and 
the tutorial.
\end{sphinxadmonition}

\end{fulllineitems}

\index{fitFvibV() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvibV}}{\emph{fin}, \emph{thermodata}, \emph{verbosity='low'}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(V)+F_{vib}(V,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(V)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(V,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in \sphinxstyleemphasis{fin} file.

The function fits \(E_{tot}(V)+F_{vib}(V,T)\) with a Murnaghan's EOS
at each temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (\sphinxcode{compute\_beta()}), the
constant volume heat capacity at the minimum volume at each T
(\sphinxcode{compute\_Cv()}) and the constant pression heat capacity (\sphinxcode{compute\_Cp()}).

It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the \(\chi^2\) at each T.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example5} and 
the tutorial.
\end{sphinxadmonition}

\end{fulllineitems}



\section{pyqha.fitfreqgrun module}
\label{pyqha:pyqha-fitfreqgrun-module}\label{pyqha:module-pyqha.fitfreqgrun}\index{pyqha.fitfreqgrun (module)}\index{fitfreq() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.fitfreq}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{fitfreq}}{\emph{celldmsx}, \emph{min0}, \emph{inputfilefreq}, \emph{ibrav=4}, \emph{typefreq='quadratic'}, \emph{compute\_grun=False}}{}
An auxiliary function for fitting the frequencies. It returns a matrix of nq*modes
frequencies obtained for the fitted polynomial (quadratic or quartic) at the 
minimun point min0. It also returns the weigths of each q point where the 
frequencies are available.

\end{fulllineitems}

\index{fitfreqxx() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.fitfreqxx}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{fitfreqxx}}{\emph{celldmsx}, \emph{freqxx}, \emph{ibrav}, \emph{out}, \emph{typefreq}}{}
This function fits the frequencies in freqxx as a function of the
grid of lattice parameters.

It returns a nq*modes matrix, whose element {[}i,j{]} is the set of coefficients of the 
polynomial fit and another nq*modes matrix, whose element {[}i,j{]} is the corresponding
chi squared. If the chi squared is zero, the fitting procedure was NOT succesful

\end{fulllineitems}

\index{freqmin() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.freqmin}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{freqmin}}{\emph{afreq}, \emph{min0}, \emph{nq}, \emph{modes}, \emph{ibrav}, \emph{typefreq}}{}
This function calculate the frequencies from the fitted polynomials at the 
minimun point min0. afreq contains the fitted polynomial coefficients.

It returns a nq*modes matrix, whose element {[}i,j{]} is the fitted frequency

\end{fulllineitems}

\index{freqmingrun() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.freqmingrun}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{freqmingrun}}{\emph{afreq}, \emph{min0}, \emph{nq}, \emph{modes}, \emph{ibrav}, \emph{typefreq}}{}
This function calculate the frequencies and the gruneisen parameters 
from the fitted polynomials at the minimun point min0. afreq contains the 
fitted polynomial coefficients.

It returns a nq*modes matrix, whose element {[}i,j{]} is the fitted frequency 
In addition, it returns a nq*modes*6 with the Gruneisein parameters.
Each element {[}i,j,k{]} is the the Gruneisein parameter at nq=i, mode=j and direction
k (for example, in hex systems k=0 is a direction, k=2 is c direction, other are zero)

Note that the Gruneisein parameters are not multiplied for the lattice parameters

\end{fulllineitems}

\index{rearrange\_freqx() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.rearrange_freqx}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{rearrange\_freqx}}{\emph{freqx}}{}
This function rearrange the input numpy matrix freqx into an equivalent matrix freqxx
for the subsequent fitting.
freqx is a ngeo*nq*modes matrix, each freqx{[}i{]} is the nq*modes freq matrix for a given geometry (i)
freqxx is a nq*modes*ngeo matrix, each freqxx{[}i{]}{[}j{]} is a vector with all values for different
geometries of the frequencies at point q=i and mode=j. For example, freqxx{[}0{]}{[}0{]}
is the vector with ngeo values of the frequencies at the first q-point and first mode so on.

\end{fulllineitems}



\section{pyqha.fitutils module}
\label{pyqha:pyqha-fitutils-module}\label{pyqha:module-pyqha.fitutils}\index{pyqha.fitutils (module)}\index{expand\_quadratic\_to\_quartic() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.expand_quadratic_to_quartic}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{expand\_quadratic\_to\_quartic}}{\emph{a}}{}
This function gets a vector of coefficients from a quadratic fit and turns it
into a vector of coeffients as from a quartic fit (extra coeffients are set to zero)

\end{fulllineitems}

\index{fit\_anis() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.fit_anis}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{fit\_anis}}{\emph{celldmsx}, \emph{Ex}, \emph{ibrav=1}, \emph{out=False}, \emph{type='quadratic'}, \emph{ylabel='Etot'}}{}
An auxiliary function for handling fitting in the anisotropic case

\end{fulllineitems}

\index{fit\_quadratic() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.fit_quadratic}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{fit\_quadratic}}{\emph{x}, \emph{y}, \emph{ibrav=4}, \emph{out=False}, \emph{ylabel='E'}}{}
This is the function for fitting with a quadratic polynomial

The most general fitting multidimensional quadratic polynomial for a triclinic
system is:
a1 + a2 x1 + a3 x1\textasciicircum{}2 + a4  x2 + a5  x2\textasciicircum{}2 + a6 x1*x2 +    
+ a7  x3 + a8  x3\textasciicircum{}2 + a9  x1*x3 + a10 x2*x3 +         
+ a11 x4 + a12 x4\textasciicircum{}2 + a13 x1*x4 + a14 x2*x4 + a15 x3*x4 +        
+ a16 x5 + a17 x5\textasciicircum{}2 + a18 x1*x5 + a19 x2*x5 + a20 x3*x5 + a21 x4*x5 
+ a22 x6 + a23 x6\textasciicircum{}2 + a24 x1*x6 + a25 x2*x6 + a26 x3*x6 + a27 x4*x6 + a28 x5*x6

ONLY THE HEXAGONAL AND GENERAL CASE ARE IMPLEMENTED, more to be done

The input variable x is a matrix ngeo*6, where
x{[}:,0{]} is the set of a values  
x{[}:,1{]} is the set of b values  
x{[}:,2{]} is the set of c values  
x{[}:,3{]} is the set of alpha values  
x{[}:,4{]} is the set of beta values   
x{[}:,5{]} is the set of gamma values

\end{fulllineitems}

\index{fit\_quartic() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.fit_quartic}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{fit\_quartic}}{\emph{x}, \emph{y}, \emph{ibrav=4}, \emph{out=False}, \emph{ylabel='E'}}{}
This is the function for fitting with a quartic polynomial

The most general fitting multidimensional quadratic polynomial for a triclinic
system is:
\begin{description}
\item[{a1 + a2  x1 + a3  x1\textasciicircum{}2 + a4  x1\textasciicircum{}3 + a5 x1\textasciicircum{}4        }] \leavevmode\begin{itemize}
\item {} 
a6  x2 + a7  x2\textasciicircum{}2 + a8  x2\textasciicircum{}3 + a9 x2\textasciicircum{}4

\item {} \begin{description}
\item[{a10 x1*x2 + a11 x1*x2\textasciicircum{}2 + a12  x1*x2\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a13 x1\textasciicircum{}2*x2 + a14  x1\textasciicircum{}2*x2\textasciicircum{}2

\item {} 
a15 x1\textasciicircum{}3*x2

\end{itemize}

\end{description}

\item {} 
a16 x3 + a17 x3\textasciicircum{}2 + a18 x3\textasciicircum{}3 + a19 x3\textasciicircum{}4

\item {} \begin{description}
\item[{a20 x1*x3 + a21 x1*x3\textasciicircum{}2 + a22  x1*x3\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a23 x1\textasciicircum{}2*x3 + a24  x1\textasciicircum{}2*x3\textasciicircum{}2

\item {} 
a25 x1\textasciicircum{}3*x3

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a26 x2*x3 + a27 x2*x3\textasciicircum{}2 + a28  x2*x3\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a29 x2\textasciicircum{}2*x3 + a30  x2\textasciicircum{}2*x3\textasciicircum{}2

\item {} 
a31 x2\textasciicircum{}3*x3

\end{itemize}

\end{description}

\item {} 
a32 x1 * x2 * x3 + a33 x1 * x2\textasciicircum{}2 * x3

\item {} 
a34 x1 * x2 * x3\textasciicircum{}2 + a35 x1\textasciicircum{}2 * x2 * x3

\item {} 
a36 x4 + a37 x4\textasciicircum{}2 + a38 x4\textasciicircum{}3 + a39 x4\textasciicircum{}4

\item {} \begin{description}
\item[{a40 x1*x4 + a41 x1*x4\textasciicircum{}2 + a42  x1*x4\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a43 x1\textasciicircum{}2*x4 + a44  x1\textasciicircum{}2*x4\textasciicircum{}2

\item {} 
a45 x1\textasciicircum{}3*x4

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a46 x2*x4 + a47 x2*x4\textasciicircum{}2 + a48  x2*x4\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a49 x2\textasciicircum{}2*x4 + a50  x2\textasciicircum{}2*x4\textasciicircum{}2

\item {} 
a51 x2\textasciicircum{}3*x4

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a52 x3*x4 + a53 x3*x4\textasciicircum{}2 + a54  x3*x4\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a55 x3\textasciicircum{}2*x4 + a56  x3\textasciicircum{}2*x4\textasciicircum{}2

\item {} 
a57 x3\textasciicircum{}3*x4

\end{itemize}

\end{description}

\item {} 
a58 x1 * x2 * x4 + a59 x1 * x2\textasciicircum{}2 * x4

\item {} 
a60 x1 * x2 * x4\textasciicircum{}2 + a61 x1\textasciicircum{}2 * x2 * x4

\item {} 
a62 x1 * x3 * x4 + a63 x1 * x3\textasciicircum{}2 * x4

\item {} 
a64 x1 * x3 * x4\textasciicircum{}2 + a65 x1\textasciicircum{}2 * x3 * x4

\item {} 
a66 x2 * x3 * x4 + a67 x2 * x3\textasciicircum{}2 * x4

\item {} 
a68 x2 * x3 * x4\textasciicircum{}2 + a69 x2\textasciicircum{}2 * x3 * x4

\item {} 
a70 x1 * x2 * x3 * x4

\item {} 
a71 x5 + a72 x5\textasciicircum{}2 + a73 x5\textasciicircum{}3 + a74 x5\textasciicircum{}4

\item {} \begin{description}
\item[{a75 x1*x5 + a76 x1*x5\textasciicircum{}2 + a77 x1*x5\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a78 x1\textasciicircum{}2*x5 + a79 x1\textasciicircum{}2*x5\textasciicircum{}2

\item {} 
a80 x1\textasciicircum{}3*x5

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a81 x2*x5 + a82 x2*x5\textasciicircum{}2 + a83 x2*x5\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a84 x2\textasciicircum{}2*x5 + a85 x2\textasciicircum{}2*x5\textasciicircum{}2

\item {} 
a86 x2\textasciicircum{}3*x5

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a87 x3*x5 + a88 x3*x5\textasciicircum{}2 + a89 x3*x5\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a90 x3\textasciicircum{}2*x5 + a91 x3\textasciicircum{}2*x5\textasciicircum{}2

\item {} 
a92 x3\textasciicircum{}3*x5

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a93 x4*x5 + a94 x4*x5\textasciicircum{}2 + a95 x4*x5\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a96 x4\textasciicircum{}2*x5 + a97 x4\textasciicircum{}2*x5\textasciicircum{}2

\item {} 
a98 x4\textasciicircum{}3*x5

\end{itemize}

\end{description}

\item {} 
a99  x1 * x2 * x5 + a100 x1 * x2\textasciicircum{}2 * x5

\item {} 
a101 x1 * x2 * x5\textasciicircum{}2 + a102 x1\textasciicircum{}2 * x2 * x5

\item {} 
a103 x1 * x3 * x5 + a104 x1 * x3\textasciicircum{}2 * x5

\item {} 
a105 x1 * x3 * x5\textasciicircum{}2 + a106 x1\textasciicircum{}2 * x3 * x5

\item {} 
a107 x1 * x4 * x5 + a108 x1 * x4\textasciicircum{}2 * x5

\item {} 
a109 x1 * x4 * x5\textasciicircum{}2 + a110 x1\textasciicircum{}2 * x4 * x5

\item {} 
a111 x2 * x3 * x5 + a112 x2 * x3\textasciicircum{}2 * x5

\item {} 
a113 x2 * x3 * x5\textasciicircum{}2 + a114 x2\textasciicircum{}2 * x3 * x5

\item {} 
a115 x2 * x4 * x5 + a116 x2 * x4\textasciicircum{}2 * x5

\item {} 
a117 x2 * x4 * x5\textasciicircum{}2 + a118 x2\textasciicircum{}2 * x4 * x5

\item {} 
a119 x3 * x4 * x5 + a120 x3 * x4\textasciicircum{}2 * x5

\item {} 
a121 x3 * x4 * x5\textasciicircum{}2 + a122 x3\textasciicircum{}2 * x4 * x5

\item {} 
a123 x1 * x2 * x3 * x5

\item {} 
a124 x1 * x2 * x4 * x5

\item {} 
a125 x1 * x3 * x4 * x5

\item {} 
a126 x2 * x3 * x4 * x5

\item {} 
a127 x6 + a128 x6\textasciicircum{}2 + a129 x6\textasciicircum{}3 + a130 x6\textasciicircum{}4

\item {} \begin{description}
\item[{a131 x1*x6 + a132 x1*x6\textasciicircum{}2 + a133 x1*x6\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a134 x1\textasciicircum{}2*x6 + a135 x1\textasciicircum{}2*x6\textasciicircum{}2

\item {} 
a136 x1\textasciicircum{}3*x6

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a137 x2*x6 + a138 x2*x6\textasciicircum{}2 + a139 x2*x6\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a140 x2\textasciicircum{}2*x6 + a141 x2\textasciicircum{}2*x6\textasciicircum{}2

\item {} 
a142 x2\textasciicircum{}3*x6

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a143 x3*x6 + a144 x3*x6\textasciicircum{}2 + a145 x3*x6\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a146 x3\textasciicircum{}2*x6 + a147 x3\textasciicircum{}2*x6\textasciicircum{}2

\item {} 
a148 x3\textasciicircum{}3*x6

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a149 x4*x6 + a150 x4*x6\textasciicircum{}2 + a151 x4*x6\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a152 x4\textasciicircum{}2*x6 + a153 x4\textasciicircum{}2*x6\textasciicircum{}2

\item {} 
a154 x4\textasciicircum{}3*x6

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{a155 x5*x6 + a156 x5*x6\textasciicircum{}2 + a157 x5*x6\textasciicircum{}3}] \leavevmode\begin{itemize}
\item {} 
a158 x5\textasciicircum{}2*x6 + a159 x5\textasciicircum{}2*x6\textasciicircum{}2

\item {} 
a160 x5\textasciicircum{}3*x6

\end{itemize}

\end{description}

\item {} 
a161 x1 * x2 * x6 + a162 x1 * x2\textasciicircum{}2 * x6

\item {} 
a163 x1 * x2 * x6\textasciicircum{}2 + a164 x1\textasciicircum{}2 * x2 * x6

\item {} 
a165 x1 * x3 * x6 + a166 x1 * x3\textasciicircum{}2 * x6

\item {} 
a167 x1 * x3 * x6\textasciicircum{}2 + a168 x1\textasciicircum{}2 * x3 * x6

\item {} 
a169 x1 * x4 * x6 + a170 x1 * x4\textasciicircum{}2 * x6

\item {} 
a171 x1 * x4 * x6\textasciicircum{}2 + a172 x1\textasciicircum{}2 * x4 * x6

\item {} 
a173 x1 * x5 * x6 + a174 x1 * x5\textasciicircum{}2 * x6

\item {} 
a175 x1 * x5 * x6\textasciicircum{}2 + a176 x1\textasciicircum{}2 * x5 * x6

\item {} 
a177 x2 * x3 * x6 + a178 x2 * x3\textasciicircum{}2 * x6

\item {} 
a179 x2 * x3 * x6\textasciicircum{}2 + a180 x2\textasciicircum{}2 * x3 * x6

\item {} 
a181 x2 * x4 * x6 + a182 x2 * x4\textasciicircum{}2 * x6

\item {} 
a183 x2 * x4 * x6\textasciicircum{}2 + a184 x2\textasciicircum{}2 * x4 * x6

\item {} 
a185 x2 * x5 * x6 + a186 x2 * x5\textasciicircum{}2 * x6

\item {} 
a187 x2 * x5 * x6\textasciicircum{}2 + a188 x2\textasciicircum{}2 * x5 * x6

\item {} 
a189 x3 * x4 * x6 + a190 x3 * x4\textasciicircum{}2 * x6

\item {} 
a191 x3 * x4 * x6\textasciicircum{}2 + a192 x3\textasciicircum{}2 * x4 * x6

\item {} 
a193 x3 * x5 * x6 + a194 x3 * x5\textasciicircum{}2 * x6

\item {} 
a195 x3 * x5 * x6\textasciicircum{}2 + a196 x3\textasciicircum{}2 * x5 * x6

\item {} 
a197 x4 * x5 * x6 + a198 x4 * x5\textasciicircum{}2 * x6

\item {} 
a199 x4 * x5 * x6\textasciicircum{}2 + a200 x4\textasciicircum{}2 * x5 * x6

\item {} 
a201 x1 * x2 * x3 * x6

\item {} 
a202 x1 * x2 * x4 * x6

\item {} 
a203 x1 * x2 * x5 * x6

\item {} 
a204 x1 * x3 * x4 * x6

\item {} 
a205 x1 * x3 * x5 * x6

\item {} 
a206 x1 * x4 * x5 * x6

\item {} 
a207 x2 * x3 * x4 * x6

\item {} 
a208 x2 * x3 * x5 * x6

\item {} 
a209 x2 * x4 * x5 * x6

\item {} 
a210 x3 * x4 * x5 * x6

\end{itemize}

\end{description}

ONLY THE HEXAGONAL CASE IS IMPLEMENTED, more to be done

The input variable x is a matrix ngeo*6, where
x{[}:,0{]} is the set of a values  
x{[}:,1{]} is the set of b values  
x{[}:,2{]} is the set of c or c/a values  
x{[}:,3{]} is the set of alpha values  
x{[}:,4{]} is the set of beta values   
x{[}:,5{]} is the set of gamma values

\end{fulllineitems}

\index{print\_data() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.print_data}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{print\_data}}{\emph{x}, \emph{y}, \emph{results}, \emph{A}, \emph{ibrav}, \emph{ylabel='E'}}{}
This function prints the data and the fitted results 
ylabel can be ``E'', ``Fvib'', ``Cxx'', etc. so that can be used for different
fitted quantities

\end{fulllineitems}

\index{print\_polynomial() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.print_polynomial}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{print\_polynomial}}{\emph{a}, \emph{ibrav=4}}{}
This function prints the fitted polynomial, either quartic or quadratic

\end{fulllineitems}



\section{pyqha.gruneisen1D module}
\label{pyqha:pyqha-gruneisen1d-module}\label{pyqha:module-pyqha.gruneisen1D}\index{pyqha.gruneisen1D (module)}\index{compute\_grun() (in module pyqha.gruneisen1D)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.gruneisen1D.compute_grun}\pysiglinewithargsret{\sphinxcode{pyqha.gruneisen1D.}\sphinxbfcode{compute\_grun}}{\emph{ngeo}, \emph{celldmsx}, \emph{inputfilefreq}, \emph{ibrav=4}, \emph{ext=False}}{}
Read the frequencies for all geometries where the gruneisen parameters must be
calculated. This depends on the direction (along a, along c, etc.)
According to the direction chosen, start,stop,step must be given to loop over 
all geometries as listed in the file containing the energies

More work to do: entend to other ibrav types, etc.

\end{fulllineitems}

\index{compute\_grun\_along\_one\_direction() (in module pyqha.gruneisen1D)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.gruneisen1D.compute_grun_along_one_direction}\pysiglinewithargsret{\sphinxcode{pyqha.gruneisen1D.}\sphinxbfcode{compute\_grun\_along\_one\_direction}}{\emph{nq}, \emph{modes}, \emph{ngeo}, \emph{cgeo}, \emph{celldmsx}, \emph{freqgeo}, \emph{rangegeo}, \emph{xindex=0}}{}
Compute the Gruneisen parameters along one direction.
This function uses a 1-dimensional polynomial of fourth degree to fit the 
frequencies along a certain direction (along a and c axis in hexagonal systems
for example).

\end{fulllineitems}

\index{find\_geocenters() (in module pyqha.gruneisen1D)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.gruneisen1D.find_geocenters}\pysiglinewithargsret{\sphinxcode{pyqha.gruneisen1D.}\sphinxbfcode{find\_geocenters}}{\emph{ngeo}}{}
Find the center geometries. Remember indexex in lists starts from 0...

\end{fulllineitems}



\section{pyqha.minutils module}
\label{pyqha:module-pyqha.minutils}\label{pyqha:pyqha-minutils-module}\index{pyqha.minutils (module)}\index{calculate\_fitted\_points\_anis() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.calculate_fitted_points_anis}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{calculate\_fitted\_points\_anis}}{\emph{celldmsx}, \emph{nmesh}, \emph{fittype='quadratic'}, \emph{ibrav=4}, \emph{a=None}}{}
Calculates a denser mesh of Efitted(celldmsx) points for plotting. nmesh = (nx,ny,nz)
gives the dimensions of the mesh.

\end{fulllineitems}

\index{contract\_vector() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.contract_vector}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{contract\_vector}}{\emph{x}, \emph{ibrav=4}}{}
Utility function: contract a vector x, len(x)=6, into a x-dim vector (x\textless{}6) 
according to ibrav
Note: not all ibrav are implemented yet

\end{fulllineitems}

\index{expand\_vector() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.expand_vector}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{expand\_vector}}{\emph{x}, \emph{ibrav=4}}{}
Utility function: expands a vector x, len(x)\textless{}6, into a 6-dim vector according
to ibrav
Note: not all ibrav are implemented yet

\end{fulllineitems}

\index{find\_min() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.find_min}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{find\_min}}{\emph{a}, \emph{ibrav}, \emph{type}, \emph{guess=None}}{}
An auxiliary function for handling the minimum search

\end{fulllineitems}

\index{find\_min\_quadratic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.find_min_quadratic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{find\_min\_quadratic}}{\emph{a}, \emph{ibrav=4}, \emph{guess=None}}{}
This is the function for finding the minimum of the quadratic polynomial

\end{fulllineitems}

\index{find\_min\_quartic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.find_min_quartic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{find\_min\_quartic}}{\emph{a}, \emph{ibrav=4}, \emph{guess=None}}{}
This is the function for finding the minimum of the quartic polynomial

\end{fulllineitems}

\index{fquadratic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquadratic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquadratic}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
Implemented polynomials for fitting and miminizing

only ibrav=4 and the most general case are implemented for now

\end{fulllineitems}

\index{fquadratic\_der() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquadratic_der}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquadratic\_der}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
\end{fulllineitems}

\index{fquartic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquartic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquartic}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
\end{fulllineitems}

\index{fquartic\_der() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquartic_der}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquartic\_der}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
\end{fulllineitems}



\section{pyqha.plotutils module}
\label{pyqha:module-pyqha.plotutils}\label{pyqha:pyqha-plotutils-module}\index{pyqha.plotutils (module)}\index{multiple\_plot\_xy() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.multiple_plot_xy}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{multiple\_plot\_xy}}{\emph{x}, \emph{y}, \emph{xlabel='`}, \emph{ylabel='`}, \emph{labels='`}}{}
This function generates a simple xy plot with matplotlib overlapping several
lines as in the matrix y. y second index refers to a line in the plot, the first 
index is for the array to be plotted.

\end{fulllineitems}

\index{plot\_EV() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.plot_EV}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{plot\_EV}}{\emph{V}, \emph{E}, \emph{a=None}, \emph{labely='Etot'}}{}
This function plots with matplotlib E(V) data and if a is given it also plot
the fitted results

\end{fulllineitems}

\index{plot\_Etot() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.plot_Etot}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{plot\_Etot}}{\emph{celldmsx}, \emph{Ex}, \emph{n}, \emph{nmesh=(50}, \emph{50}, \emph{50)}, \emph{fittype='quadratic'}, \emph{ibrav=4}, \emph{a=None}}{}
This function makes a 3D plot with matplotlib Ex(celldmsx) data and if a is given it also plot
the fitted results. The plot type depends on ibrav.

\end{fulllineitems}

\index{plot\_Etot\_contour() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.plot_Etot_contour}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{plot\_Etot\_contour}}{\emph{celldmsx}, \emph{nmesh=(50}, \emph{50}, \emph{50)}, \emph{fittype='quadratic'}, \emph{ibrav=4}, \emph{a=None}}{}
This function makes a countour plot with matplotlib of Ex(celldmsx) fitted results. 
The plot type depends on ibrav.

\end{fulllineitems}

\index{simple\_plot\_xy() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.simple_plot_xy}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{simple\_plot\_xy}}{\emph{x}, \emph{y}, \emph{xlabel='`}, \emph{ylabel='`}}{}
This function generates a simple xy plot with matplotlib.

\end{fulllineitems}



\section{pyqha.properties\_anis module}
\label{pyqha:module-pyqha.properties_anis}\label{pyqha:pyqha-properties-anis-module}\index{pyqha.properties\_anis (module)}\index{compute\_alpha() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_alpha}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_alpha}}{\emph{minT}, \emph{ibrav}}{}
This function calculate the thermal expansion alphaT at different temperatures
from the input minT matrix by computing the numerical derivatives with numpy.
The input matrix minT has shape nT*6, where the first index is the temperature 
and the second the lattice parameter. For example, minT{[}i,0{]} and minT{[}i,2{]} are
the lattice parameters a and c at the temperature i.

More ibrav types must be implemented

\end{fulllineitems}

\index{compute\_alpha\_splines() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_alpha_splines}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_alpha\_splines}}{\emph{TT}, \emph{minT}, \emph{ibrav}}{}
This function calculate the thermal expansion alphaT at different temperatures
as the previous function but with splines

\end{fulllineitems}

\index{compute\_heat\_capacity() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_heat_capacity}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_heat\_capacity}}{\emph{TT}, \emph{minT}, \emph{alphaT}, \emph{C}, \emph{ibrav=4}}{}
This function calculate the difference between the constant stress heat capacity
C\_sigma and the constant strain heat capacity C\_epsilon from the V, the thermal
expansions and the elastic constant tensor C

\end{fulllineitems}

\index{compute\_volume() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_volume}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_volume}}{\emph{celldms}, \emph{ibrav=4}}{}
Compute the volume given the celldms, only for ibrav=4 for now

\end{fulllineitems}



\section{pyqha.read module}
\label{pyqha:pyqha-read-module}\label{pyqha:module-pyqha.read}\index{pyqha.read (module)}\index{read\_Etot() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_Etot}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_Etot}}{\emph{fname}, \emph{ibrav=4}, \emph{bc\_as\_a\_ratio=True}}{}
Read cell parameters \sphinxstyleemphasis{(a,b,c)} and the corresponding energies from input file \sphinxstyleemphasis{fname}. 
Each set of cell parameters is stored in a numpy array of lenght 6 
for \sphinxstyleemphasis{(a,b,c,alpha,beta,gamma)} respectively. This is done for a future possible 
extension but for now only the first 3 elements are used (the others are always 0).
All sets are stored in \sphinxstyleemphasis{celldmsx} and \sphinxstyleemphasis{Ex}, the former is a nE*6 matrix, 
the latter is a nE array.

\sphinxstyleemphasis{ibrav} identifies the Bravais lattice as in Quantum Espresso and is needed 
in input (default is 4, i.e. hexagonal cell). The input file format depends
on \sphinxstyleemphasis{ibrav}, for example in the hex case, the first two columns are for \sphinxstyleemphasis{a} and
\sphinxstyleemphasis{c} and the third is for the energies.

If \sphinxstyleemphasis{bc\_as\_a\_ratio=True}, the input data are assumed to be given as 
\((a,b/a,c/a)\) in the input file and hence converted into \((a,b,c)\)
which is how they are always stored internally in \sphinxcode{pyqha}.

Units must be \(a.u.\) and \(Ryd/cell\)

\end{fulllineitems}

\index{read\_EtotV() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_EtotV}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_EtotV}}{\emph{fname}}{}
Read cell volumes and the corresponding energies from input file \sphinxstyleemphasis{fname}
(1st col, volumes, 2nd col energies). Units must be \(a.u.^3\) and 
\(Ryd/cell\)

\end{fulllineitems}

\index{read\_alpha() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_alpha}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_alpha}}{\emph{fname}}{}
\end{fulllineitems}

\index{read\_celldmt\_hex() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_celldmt_hex}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_celldmt\_hex}}{\emph{filename}}{}
\end{fulllineitems}

\index{read\_dos() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_dos}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_dos}}{\emph{filename}}{}
Read the phonon density of states (y axis) and the corresponding energies (x axis)
from the input file \sphinxstyleemphasis{filename} (1st col energies, 2nd col DOS) and store it
in two numpy arrays which are returned.

\end{fulllineitems}

\index{read\_dos\_geo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_dos_geo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_dos\_geo}}{\emph{fin}, \emph{ngeo}}{}
Read the phonon density of states and energies as in {\hyperref[pyqha:pyqha.read.read_dos]{\sphinxcrossref{\sphinxcode{read\_dos()}}}} from \sphinxstyleemphasis{ngeo} input files
\sphinxstyleemphasis{fin1}, \sphinxstyleemphasis{fin2}, etc. and store it in two numpy matrices which are returned.

\end{fulllineitems}

\index{read\_elastic\_constants() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_elastic_constants}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_elastic\_constants}}{\emph{fname}}{}
This function reads and returns the elastic constants and compliances from
the file \sphinxstyleemphasis{fname} .
Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape {[}6,6{]}
So, the elastic constant C11 is in C{[}0,0{]}, C12 in C{[}0,1{]} and so on.
Same for the elastic compliances.

\end{fulllineitems}

\index{read\_elastic\_constants\_geo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_elastic_constants_geo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_elastic\_constants\_geo}}{\emph{fC}, \emph{ngeo}}{}
Read elastic constants calculated on a multidimensional grid of lattice parameters
\sphinxstyleemphasis{ngeo} defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!

\end{fulllineitems}

\index{read\_freq() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq}}{\emph{filename}}{}
This funcstion reads the phonon frequencies at each \sphinxstyleemphasis{q} point from a frequency file.  
Input file has the following format (to be done).

Returning values are a nq*3 matrix q, each q{[}i{]} being a q point (vector of 3 elements)
and a nq*modes matrix freq, each element freq{[}i{]} being the phonon frequencies
(vector of modes elements)

\end{fulllineitems}

\index{read\_freq\_ext() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq_ext}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq\_ext}}{\emph{filename}}{}
Read the phonon frequencies at each q point from a frequency file. The format 
of this file is different from the one read by the function read\_freq and
contains usually more frequencies, each with a weight, but no qpoint coordinates.
Input file has the following format:

First line contains n. atoms, nqx, nqy, nqz, nq total.
Second line not read.
Third line: weight of the first qpoint
Following lines: phonon frequencies (their number is modes=3*n. atoms), one per line
then again: weight of the next qpoint, phonon frequencies (3*modes), one per line, etc.

Weights are diffent because of simmetry

Returning values are a nq vector weights, each weights{[}i{]} being the weight of a q point 
and a nq*modes matrix freq, each element freq{[}i{]} being the phonon frequencies
(vector of modes elements) at the qpoint i

\end{fulllineitems}

\index{read\_freq\_ext\_geo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq_ext_geo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq\_ext\_geo}}{\emph{inputfilefreq}, \emph{rangegeo}}{}
Read the frequencies for all geometries where the gruneisen parameters must be
calculated.

Notes:
nq = qgeo.shape{[}1{]} -\textgreater{} total number of q points read
modes = freqgeo.shape{[}2{]} -\textgreater{} number of frequency modes

\end{fulllineitems}

\index{read\_freq\_geo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq_geo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq\_geo}}{\emph{inputfilefreq}, \emph{rangegeo}}{}
Read the frequencies for all geometries where the gruneisen parameters must be
calculated. Start, stop, step must be given accordingly. It can be used to read
the frequencies only at some geometries from a larger set, if necessary, 
providing the proper start, stop and step values.

Notes:
nq = qgeo.shape{[}1{]} -\textgreater{} total number of q points read
modes = freqgeo.shape{[}2{]} -\textgreater{} number of frequency modes

\end{fulllineitems}

\index{read\_thermo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_thermo}}{\emph{fname}, \emph{ngeo=1}}{}
Read vibrational thermodynamic functions (Evib, Fvib, Svib, Cvib) as a 
function of temperature from the input file \sphinxstyleemphasis{fname}. \sphinxstyleemphasis{ngeo} is the number
of input files to read, corresponding for example to different geometries
in a quasi-harmonic calculation.
If \sphinxstyleemphasis{ngeo\textgreater{}1} reads from the files \sphinxstyleemphasis{fname1}, \sphinxstyleemphasis{fname2}, etc. up to \sphinxstyleemphasis{ngeo}  
Input file(s) have the following format:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
T
\unskip}\relax &
\(E_{vib}\)
&
\(F_{vib}\)
&
\(S_{vib}\)
&
\(C_{vib}\)
\\
\hline
1
&
...
&
...
&
...
&
...
\\
\hline\end{tabulary}


Lines starting with ``\#'' are not read (comments).

Returning values are \(nT*ngeo\) numpy matrices (T,Evib,Fvib,Svib,Cvib) containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib{[}T,geo{]} -\textgreater{} Fvib at the temperature \sphinxstyleemphasis{T} for the geometry \sphinxstyleemphasis{geo}

Units must be \sphinxstyleemphasis{K} for temperature, \sphinxstyleemphasis{Ryd/cell} for energies, \sphinxstyleemphasis{Ryd/cell/K} for
entropy and heat capacity.

\end{fulllineitems}



\section{pyqha.thermo module}
\label{pyqha:pyqha-thermo-module}\label{pyqha:module-pyqha.thermo}\index{pyqha.thermo (module)}\index{compute\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo}}{\emph{E}, \emph{dos}, \emph{TT}}{}
This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays \sphinxstyleemphasis{E} 
and \sphinxstyleemphasis{dos} containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array \sphinxstyleemphasis{TT}.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to \(3*N\), with \sphinxstyleemphasis{N} the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.

\end{fulllineitems}

\index{compute\_thermo\_geo() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo\_geo}}{\emph{fin}, \emph{fout=None}, \emph{ngeo=1}, \emph{TT=array({[}1{]})}}{}
This function reads the input dos file(s) from \sphinxstyleemphasis{fin+i}, with \sphinxstyleemphasis{i} a number from
1 to \sphinxstyleemphasis{ngeo} + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
T
\unskip}\relax &
\(E_{vib}\)
&
\(F_{vib}\)
&
\(S_{vib}\)
&
\(C_{vib}\)
\\
\hline
1
&
...
&
...
&
...
&
...
\\
\hline\end{tabulary}


and are names \sphinxstyleemphasis{fout} +1, \sphinxstyleemphasis{fout} +2,... for each geometry.

Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib{[}T,geo{]} -\textgreater{} Fvib at the temperature ``T'' for the geometry ``geo''

\end{fulllineitems}

\index{dos\_integral() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{dos\_integral}}{\emph{E}, \emph{dos}, \emph{m=0}}{}
A function to compute the integral of an input phonon DOS (\sphinxstyleemphasis{dos}) with the 3/8 Simpson method.
\sphinxstyleemphasis{m} is the moment of the integral, if \(m>0\) different moments can be calculated.
For example, with \(m=0\) (default) it returns the number of modes from the dos, 
with \(m=1\) it returns the ZPE. The input energy (\sphinxstyleemphasis{E}) and phonon DOS (\sphinxstyleemphasis{dos}) are expected to be in
\(cm^{-1}\).

\end{fulllineitems}

\index{gen\_TT() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{gen\_TT}}{\emph{Tstart=1}, \emph{Tend=1000}, \emph{Tstep=1}}{}
A simple function to generate a numpy array of temperatures, starting from
\sphinxstyleemphasis{Tstart} and ending to \sphinxstyleemphasis{Tend} (or the closest \sphinxstyleemphasis{T\textless{}Tend} accorinding to the \sphinxstyleemphasis{Tstep} )
with step \sphinxstyleemphasis{Tstep} .

\end{fulllineitems}

\index{rearrange\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{rearrange\_thermo}}{\emph{T}, \emph{Evib}, \emph{Fvib}, \emph{Svib}, \emph{Cvib}, \emph{ngeo=1}}{}
This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices \sphinxstyleemphasis{X} now gives all geometries at a given
\sphinxstyleemphasis{T}, i.e. \sphinxstyleemphasis{X{[}0{]}} is the vector of the property \sphinxstyleemphasis{X} a \sphinxstyleemphasis{T=T{[}0,0{]}} . \sphinxstyleemphasis{X{[}0,0{]}} for the first 
geometry, \sphinxstyleemphasis{X{[}0,1{]}} the second geometry and so on.

\end{fulllineitems}



\section{pyqha.write module}
\label{pyqha:pyqha-write-module}\label{pyqha:module-pyqha.write}\index{pyqha.write (module)}\index{write\_CT() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_CT}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_CT}}{\emph{Ts}, \emph{CT}, \emph{fCout='`}}{}
Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!

\end{fulllineitems}

\index{write\_C\_geo() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_C_geo}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_C\_geo}}{\emph{celldmsx}, \emph{C}, \emph{ibrav=4}, \emph{fCout='`}}{}
Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies in the quasi-harmonic calculations!

\end{fulllineitems}

\index{write\_Etot() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_Etot}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_Etot}}{\emph{celldmsx}, \emph{Ex}, \emph{fname}, \emph{ibrav=4}}{}
Read cell parameters (a,b,c,alpha,beta,gamma) and energies for a grid of cell
parameters values from file output\_energy1. 
Each celldms is a vector of lenght 6 containing a,b,c,alpha,beta,gamma respectively
celldmsx and Ex contains the grid of values of celldms and E so that:
celldmsx{[}0{]} = celldms0      Ex{[}0{]} = E0
celldmsx{[}1{]} = celldms1      Ex{[}1{]} = E1
celldmsx{[}2{]} = celldms2      Ex{[}2{]} = E2
........
values are taken from the file ``fname''
ibrav is the Bravais lattice as in Quantum Espresso and is needed in input (default is cubic)

\end{fulllineitems}

\index{write\_alphaT() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_alphaT}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_alphaT}}{\emph{fname}, \emph{T}, \emph{alphaT}, \emph{ibrav=4}}{}
\end{fulllineitems}

\index{write\_celldmsT() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_celldmsT}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_celldmsT}}{\emph{fname}, \emph{T}, \emph{x}, \emph{ibrav=4}}{}
\end{fulllineitems}

\index{write\_elastic\_constants() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_elastic_constants}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_elastic\_constants}}{\emph{C}, \emph{S}, \emph{fname}}{}
Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape {[}6,6{]}
So, the elastic constant C11 is in C{[}0{]}{[}0{]}, C12 in C{[}0{]}{[}1{]} and so on.
Same for the elastic compliances

\end{fulllineitems}

\index{write\_freq() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_freq}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_freq}}{\emph{qgeo}, \emph{freq}, \emph{filename}}{}
Write frequencies (or Gruneisen parameters) in a file. In this format also q points
coordinates are written but not the weight of each point.
It can be used to write the Gruneisen mode parameters, giving them in input as freq

\end{fulllineitems}

\index{write\_freq\_ext() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_freq_ext}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_freq\_ext}}{\emph{weights}, \emph{freq}, \emph{filename}}{}
Write frequencies (or Gruneisen parameters) on an extended mesh in a file.
In this format, q points coordinates are NOT written but the weight of each point yes.
It can be used to write the Gruneisen mode parameters, giving them in input as freq
Write the gruneisen parameters

\end{fulllineitems}

\index{write\_thermo() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_thermo}}{\emph{fname}, \emph{T}, \emph{Evib}, \emph{Fvib}, \emph{Svib}, \emph{Cvib}, \emph{ZPE}, \emph{modes}}{}
\end{fulllineitems}

\index{write\_xy() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_xy}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_xy}}{\emph{fname}, \emph{x}, \emph{y}, \emph{labelx}, \emph{labely}}{}
This function writes a quantity y versus quantity x into the file fname.
y and x are arrays and should have the same lenght. labelx and labely
are the axis labels (possibly with units), written in the header of the file
(first line).

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\sphinxstyleindexentry{pyqha.constants}}\sphinxstyleindexpageref{pyqha:module-pyqha.constants}
\item {\sphinxstyleindexentry{pyqha.eos}}\sphinxstyleindexpageref{pyqha:module-pyqha.eos}
\item {\sphinxstyleindexentry{pyqha.fitC}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitC}
\item {\sphinxstyleindexentry{pyqha.fitEtot}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitEtot}
\item {\sphinxstyleindexentry{pyqha.fitfreqgrun}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitfreqgrun}
\item {\sphinxstyleindexentry{pyqha.fitFvib}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitFvib}
\item {\sphinxstyleindexentry{pyqha.fitutils}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitutils}
\item {\sphinxstyleindexentry{pyqha.gruneisen1D}}\sphinxstyleindexpageref{pyqha:module-pyqha.gruneisen1D}
\item {\sphinxstyleindexentry{pyqha.minutils}}\sphinxstyleindexpageref{pyqha:module-pyqha.minutils}
\item {\sphinxstyleindexentry{pyqha.plotutils}}\sphinxstyleindexpageref{pyqha:module-pyqha.plotutils}
\item {\sphinxstyleindexentry{pyqha.properties\_anis}}\sphinxstyleindexpageref{pyqha:module-pyqha.properties_anis}
\item {\sphinxstyleindexentry{pyqha.read}}\sphinxstyleindexpageref{pyqha:module-pyqha.read}
\item {\sphinxstyleindexentry{pyqha.thermo}}\sphinxstyleindexpageref{pyqha:module-pyqha.thermo}
\item {\sphinxstyleindexentry{pyqha.write}}\sphinxstyleindexpageref{pyqha:module-pyqha.write}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}