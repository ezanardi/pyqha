%% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing }}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{pyqha Documentation}
\date{Nov 11, 2016}
\release{0.1}
\author{Mauro Palumbo}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{introduction:introduction}\label{introduction:welcome-to-pyqha-s-documentation}\label{introduction::doc}\label{introduction:id1}
\sphinxcode{pyqha} is a Python package to perform quasi-harmonic and related calculations from total energies at 0 K, elastic constants at 0 K and phonon densities of states. The package provides Python functions to postprocess the results of your favourite DFT code, such as Quantum Espresso \footnote[1]{\sphinxAtStartFootnote
\url{http://www.quantum-espresso.org/}
} or VASP \footnote[2]{\sphinxAtStartFootnote
\url{https://www.vasp.at/}
}, to obtain quasi-harmonic properties. It is meant to be imported in your own code or used to produce quasi-harmonic results (see the Tutorial part of this documentation). It is also meant for people who want to tinker with the code and adapt it to their own needs. Finally note that you may couple the package with some other available calculation Python tools, such as \href{https://wiki.fysik.dtu.dk/ase/about.html}{ASE} or \href{http://www.aiida.net/}{AiiDA}.
The package is based on numpy, scipy and matplotlib libraries.

A non-exhaustive list of properties which can be obtained using \sphinxcode{pyqha} is:
\begin{itemize}
\item {} 
quasi-harmonic Helmholtz energy for isotropic and anisotropic unit cells

\item {} 
quasi-harmonic thermal expansions for isotropic and anisotropic unit cells

\item {} 
quasi-harmonic bulk modulus for isotropic unit cells

\item {} 
quasi-harmonic heat capacity for isotropic unit cells

\item {} 
quasi-static elastic constants for anisotropic unit cells

\end{itemize}

Current features of the package include:
\begin{itemize}
\item {} 
Fit the total energy \(E_{tot}(V)\) with Murnaghan's equation of state

\item {} 
Fit the total energy \(E_{tot}(a,b,c)\), where \((a,b,c)\) are the lattice parameters of hexagonal, tetragonal, orthorombic cells, using a quadratic or quartic polynomial

\item {} 
Minimize the energy \(E_{tot}(V)+F_{vib}(V,T)\) as a function of temperature with Murnaghan's equation of state

\item {} 
Minimize the energy \(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) as a function of temperature using a quadratic or quartic polynomial

\item {} 
Calculate the quasi-static elastic constant tensor as a function of temperature

\end{itemize}

The equations to obtain these properties are relatively simple, for an introduction on the quasi-harmonic approximation you can see Baroni et al., available online at \url{https://arxiv.org/abs/1112.4977} or \footnote[3]{\sphinxAtStartFootnote
\begin{enumerate}
\setcounter{enumi}{12}
\item {} 
Palumbo, B. Burton, A. Costa e silva, B. Fultz, B. Grabowski, G. Grimvall, B. Hallstedt, O. Hellman, B. Lindahl, A. Schneider, P.E.A. Turchi, and W. Xiong. Physica Status Solidi (B) Basic Research, 251(1):14â€“32, 2014

\end{enumerate}
}. For an introduction on quasi-static elastic constants see \footnote[4]{\sphinxAtStartFootnote
\begin{enumerate}
\setcounter{enumi}{24}
\item {} 
Wang, J. J. Wang, H. Zhang, V. R. Manga, S. L. Shang, L.-Q. Chen, and Z.-K. Liu. Journal of Physics Condensed Matter, 22:225404, 2010.

\end{enumerate}
} Have a look at the very good documentation of the \sphinxstyleemphasis{thermo\_pw} fortran package available at \url{http://qeforge.qe-forge.org/gf/project/thermo\_pw/}.


\section{Installation}
\label{introduction:installation}
You can download all package files from GitHub (\url{https://github.com/mauropalumbo75/pyqha}) and then install it with the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo python setup.py install
\end{sphinxVerbatim}

The most useful functions for the common user are directly accessible from the \sphinxcode{pyqha}. You can import all of them as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

or you can import only the ones you need. The above command also makes available a number of useful constants that you can use for unit conversions.

More functions are available as submodules. See the related documentation for more details. Note, however, that most of these functions are less well documented and are meant for advanced users or if you want to tinker with the code.


\section{General notes}
\label{introduction:general-notes}
The parameter \sphinxstyleemphasis{ibrav}, which occurs in many functions of this package, identifies the Bravais lattice of the system as in Quantum Espresso. Currently, only cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11}) lattices are implemented. Note that only the variation of phonon frequencies over a grid \((a,b,c)\) of lattice parameters can be carried out for now. Angles and internal degrees of freedom (atomic positions) cannot be considered. Thus, different \sphinxstyleemphasis{ibrav} can give the same grid:
\begin{quote}

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline

\sphinxstyleemphasis{ibrav}
&
Grid
&
Fitting polynomial
\\
\hline
1,2,3
&
\((a,a,a)\)
&
1 variable, 2nd or 4th degree
\\
\hline
4,6,7
&
\((a,a,c)\)
&
2 variables, 2nd or 4th degree
\\
\hline
8,9,10,11
&
\((a,b,c)\)
&
3 variables, 2nd or 4th degree
\\
\hline\end{tabulary}

\end{quote}


\chapter{Tutorial}
\label{tutorial::doc}\label{tutorial:tutorial}\label{tutorial:id1}
This is a simple tutorial demonstrating the main functionalities of \sphinxcode{pyqha}. The examples below show how to use the package to perform the most common tasks. The code examples can be found in the directory \sphinxstyleemphasis{examples} of the package and can be run either as interactive sessions in your Python intepreter or as scripts.
The tutorial is based on the following examples:

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\sphinxstylethead{\relax 
Example n.
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax \\
\hline
1
&
Fit \(E_{tot}(V)\) for a cubic (isotropic) system using Murnaghan EOS
\\
\hline
2
&
Fit \(E_{tot}(a,c)\) for an hexagonal (anisotropic) system  using a polynomial
\\
\hline
3
&
Calculate the harmonic thermodynamic properties (ZPE, vibrational energy, Helmholtz energy, entropy and heat capacity from a phonon DOS
\\
\hline
4
&
Calculate the harmonic thermodynamic properties as in the previous examples from several phonon DOS
\\
\hline
5
&
A quasi-harmonic calculation for a cubic (isotropic) system using Murnaghan EOS
\\
\hline
6
&
A quasi-harmonic calculation for an hexagonal (anisotropic) system  using a quadratic polynomial
\\
\hline
7
&
A quasi-static calculation for the elastic tensor of an hexagonal (anisotropic) system  using a quadratic polynomial
\\
\hline
8
&
Numerical issues in quasi-harmonic calculations
\\
\hline\end{tabulary}


Several simplified plotting functions are available in \sphinxcode{pyqha} and are used in the following tutorial to show what you can plot.
Note however that all plotting functions need the matplotlib library, which must be available on your system and can be used to further taylor your plot.


\section{Fitting the total energy (examples 1 and 2)}
\label{tutorial:fitting-the-total-energy-examples-1-and-2}
The simplest task you can do with \sphinxcode{pyqha} is to fit the total energy as a function of volume \(E_{tot}(V)\) (example1) or lattice parameters values \(E_{tot}(a,b,c,\alpha,\beta,\gamma)\) (example2). In the former case, you can use
an equation of state (EOS) such as Murnaghan's or similar. In the latter case, you must use polynomials. Currently the Murnaghan EOS and quadratic and quartic polynomials are implemented in \sphinxcode{pyqha}. Besides, only \(a,b,c\) lattice parameters can be handled. This includes cubic, hexagonal, tetragonal and orthorombic systems.

Let's start with the simpler case where we want to fit \(E_{tot}(V)\). This is the case of isotropic cubic systems (simple cubic, body centered cubic, face centered cubic) or systems which can be approximated as isotropic (for example an hexagonal system with nearly constant \(c/a\) ratio).

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{fitEtotV}\PYG{p}{,} \PYG{n}{plot\PYGZus{}EV}

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./EtotV.dat}\PYG{l+s+s2}{\PYGZdq{}}  		\PYG{c+c1}{\PYGZsh{} file with the total energy data E(V)}
\PYG{n}{V}\PYG{p}{,} \PYG{n}{E}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{chi2} \PYG{o}{=} \PYG{n}{fitEtotV}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{)}    	\PYG{c+c1}{\PYGZsh{} fits the E(V) data, returns the coefficients a and}
                                	\PYG{c+c1}{\PYGZsh{} the chi squared chi2}

\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{plot\PYGZus{}EV}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,}\PYG{n}{E}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}                  	\PYG{c+c1}{\PYGZsh{} plot the E(V) data and the fitting line}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

The \sphinxcode{fitEtotV()} needs in input a file with two columns: the first with the volumes (in \(a.u.^3\)), the second with energies (in \(Ryd/cell\)). It returns the volumes \sphinxstyleemphasis{V} and energies \sphinxstyleemphasis{E} from the input file plus the fitting coefficients \sphinxstyleemphasis{a} and the \(\chi^2\) \sphinxstyleemphasis{chi}. The fitting results are also written in details on the \sphinxstyleemphasis{stdout}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Murnaghan EOS 		 chi squared= 6.3052568895e\PYGZhy{}09}
\PYG{c+c1}{\PYGZsh{} Etotmin= \PYGZhy{}1.6668753460e+03 Ry	 Vmin= 1.9256061524e+02 a.u.\PYGZca{}3	 B0= 3.9507615923e+03 kbar	 dB0/dV= 4.7879823925e+00}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{} V *a.u.\PYGZca{}3)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Etot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ (Ry)}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Etotfit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ (Ry)}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Etot\PYGZhy{}Etotfit (Ry)}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{P (kbar)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.7119697047e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668351807e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668351587e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.2057946126e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 6.2382144794e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.7637989181e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668536038e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668536431e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 3.9279193061e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 4.3100002530e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.8166637877e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668660570e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668660710e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 1.4066826679e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 2.6537032641e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.8705745588e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668731355e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668731118e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.3774691499e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 1.2288570223e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.9255414767e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668753764e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668753460e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}3.0400133255e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 1.3270797876e\PYGZhy{}01}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.9815747866e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668732871e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668732783e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}8.8363487976e\PYGZhy{}06}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.0577273936e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.0386847338e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668673220e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668673472e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 2.5137771445e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.9727140701e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.0968815635e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668579007e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668579345e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ 3.3763105193e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.7643217490e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.1561755211e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}1.6668454001e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}1.6668453730e+03}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}2.7177809670e\PYGZhy{}05}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{ \PYGZhy{}3.4501143525e+02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Optionally, you can plot the results with the \sphinxcode{plot\_EV()}. The original data are represented as points. If \sphinxstyleemphasis{a!=None}, a line with the fitting EOS will also be plotted. The output plot looks like the following:

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_1}.png}

The second example shows how to fit the total energy of an hexagonal system, i.e. as a function of the lattice parameters \((a,c)\). The input file (\sphinxstyleemphasis{fin}) contains three columns, the first two with the \((a,c)\) (in \(a.u.\)) and the third one with the energies (in \(Ryd/cell\)). Note that if the original data are as \((a,c/a)\), as often reported, you must convert the \(c/a\) values into \(c\) values in the input file.
The \sphinxcode{fitEtot()} reads the input file and performs the fit using either a quadratic or quartic polynomial (as specified by the parameter \sphinxstyleemphasis{fitype}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}  	\PYG{c+c1}{\PYGZsh{} contains the input energies}

\PYG{c+c1}{\PYGZsh{} fits the energies and returns the coeffients a0 and the chi squared chia0}
\PYG{c+c1}{\PYGZsh{} the fit is done with a quartic polynomial}
\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Ex}\PYG{p}{,} \PYG{n}{a0}\PYG{p}{,} \PYG{n}{chia0}\PYG{p}{,} \PYG{n}{mincelldms}\PYG{p}{,} \PYG{n}{fmin} \PYG{o}{=} \PYG{n}{fitEtot}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{guess}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{5.12374914}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{8.19314311}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} 3D plot only with fitted energy}
\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{p}{)}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot fitted energy and points}
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}2.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy }
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{p}{)}
\PYG{n}{fig3}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}3.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

The output of the fitting function is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
quartic fit
(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}Etot\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}Etotfit\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZbs{}t\PYGZbs{}t\PYGZsq{}, \PYGZsq{}Etot\PYGZhy{}Etotfit\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.8471807981e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668528744e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668528745e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.0725036494e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.9240488978e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668649001e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668649002e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}9.8750206234e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0009169975e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668716783e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668716776e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}7.7131721810e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0777850972e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737355e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737365e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}9.2776986094e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1546531969e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668715550e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668715547e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}3.2629236557e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.9492671099e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668606004e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668606001e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}2.1225582714e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0271352096e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668700587e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668700591e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}3.0630963010e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1050033093e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668744794e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668744800e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}6.7416499405e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1828714090e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743826e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743814e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.2613072613e\PYGZhy{}06\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2607395087e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668702280e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668702285e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}4.9947925618e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.0513534218e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668660570e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668660572e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}2.5535950954e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1302215215e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668731355e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668731348e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}7.0765509008e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2090896212e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668753764e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668753765e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}1.0862777344e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2879577209e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668732871e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668732880e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4404246081e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3668258206e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668673220e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668673216e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.0985673877e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.1534397336e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668694343e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668694339e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.5153024075e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2333078333e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743061e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668743073e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}1.2780792531e\PYGZhy{}06\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3131759330e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668745384e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668745377e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}7.0226747084e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3930440327e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668706178e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668706173e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.6083209782e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4729121324e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668629842e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668629845e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}3.4305685404e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.2555260455e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668709188e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668709191e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}3.3864898796e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.1543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.3363941452e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737584e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668737574e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}9.7452812042e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4172622449e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668721346e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668721354e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}7.8953144111e\PYGZhy{}07\PYGZsq{})
(\PYGZsq{}5.2543155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.4981303446e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668665315e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668665315e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}4.8681386033e\PYGZhy{}08\PYGZsq{})
(\PYGZsq{}5.3043155930e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}8.5789984443e+00\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668573689e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.6668573688e+03\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}\PYGZhy{}1.0538019524e\PYGZhy{}07\PYGZsq{})

Fitted polynomial is: 

p(x1,x2) = \PYGZhy{}1291.10429456 + \PYGZhy{}184.969221276 * x1 + 42.2676103527 * x1\PYGZca{}2 + \PYGZhy{}4.81052197937 * x1\PYGZca{}3 + 0.188178329491 * x1\PYGZca{}4 +
\PYGZhy{}49.1590620388 *x2 + 5.34145510286 *x2\PYGZca{}2 + \PYGZhy{}0.245662970361 *x2\PYGZca{}3 + \PYGZhy{}0.000328650634003 *x2\PYGZca{}4 +
8.48734670683 *x1*x2 + \PYGZhy{}0.67806386411 *x1*x2\PYGZca{}2 + 0.0444127765503 *x1*x2\PYGZca{}3 + \PYGZhy{}0.393401452901 *x1\PYGZca{}2*x2 + \PYGZhy{}0.0458527834065 *x1\PYGZca{}2*x2\PYGZca{}2 +
0.0705006802514 *x1\PYGZca{}3*x2

(\PYGZsq{}Chi squared: \PYGZsq{}, 9.8189738184091843e\PYGZhy{}12, \PYGZsq{}\PYGZbs{}n\PYGZsq{})
(\PYGZsq{}Minimun quartic: \PYGZsq{}, array([ 5.20422334,  0.        ,  8.20918742,  0.        ,  0.        ,  0.        ]), \PYGZsq{}\PYGZbs{}tEnergy at the minimum: \PYGZhy{}1.66687537646402097380e+03\PYGZbs{}n\PYGZsq{})
\end{sphinxVerbatim}

Optionally, you can use the functions \sphinxcode{plot\_Etot()}, \sphinxcode{plot\_Etot\_contour()} to create 3D or contour plots of the fitted energy over the grid \((a,c)\), including or not the original energy points:

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_11}.png}

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_2}.png}

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_3}.png}


\section{Computing thermal properties from phonon DOS (examples 3 and 4)}
\label{tutorial:computing-thermal-properties-from-phonon-dos-examples-3-and-4}
\sphinxcode{pyqha} can calculate the vibrational properties of your system from the phonon DOS in the harmonic approximation as shown in \sphinxstyleemphasis{example3}. The DOS file must be a two columns one, the first column being the energy (in \(Ryd/cell\)) and the second column being the density of states (in \((Ryd/cell)^{-1}\)).

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./dos.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{fout} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./thermo}\PYG{l+s+s2}{\PYGZdq{}}  

\PYG{n}{TT} \PYG{o}{=} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} create a numpy array of temperatures from 1 to 1000 step 0.5}

\PYG{n}{E}\PYG{p}{,} \PYG{n}{dos} \PYG{o}{=} \PYG{n}{read\PYGZus{}dos}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} read the dos file. It returns the energies and dos values.}


\PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{ZPE}\PYG{p}{,} \PYG{n}{modes} \PYG{o}{=} \PYG{n}{compute\PYGZus{}thermo}\PYG{p}{(}\PYG{n}{E}\PYG{o}{/}\PYG{n}{RY\PYGZus{}TO\PYGZus{}CMM1}\PYG{p}{,}\PYG{n}{dos}\PYG{o}{*}\PYG{n}{RY\PYGZus{}TO\PYGZus{}CMM1}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{)}
\PYG{n}{write\PYGZus{}thermo}\PYG{p}{(}\PYG{n}{fout}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib}\PYG{p}{,} \PYG{n}{ZPE}\PYG{p}{,} \PYG{n}{modes}\PYG{p}{)}  

\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}
\PYG{c+c1}{\PYGZsh{} plot the original phonon DOS}
\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,}\PYG{n}{dos}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E (Ryd/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phonon DOS (Ry/cell)\PYGZca{}\PYGZob{}\PYGZhy{}1\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} create several plots for the thermodynamic quantities computed}
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Evib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Evib (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}2.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Fvib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fvib (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}3.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Svib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Svib (Ry/cell/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}4.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig5} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Cvib}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig5}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}5.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

The output produced by the function \sphinxcode{compute\_thermo()} is stored in the variables \sphinxstyleemphasis{T, Evib, Svib, Cvib, Fvib, ZPE, modes} and can be written in a file using the function \sphinxcode{write\_thermo()}. This output file is as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} total modes from dos = 5.9999726114e+00
\PYGZsh{} ZPE = 5.6214272319e\PYGZhy{}03 Ry/cell
\PYGZsh{} Multiply by 13.6058 to have energies in eV/cell etc..
\PYGZsh{} Multiply by 13.6058 x 23060.35 = 313 754.5 to have energies in cal/(N mol).
\PYGZsh{} Multiply by 13.6058 x 96526.0 = 1 313 313 to have energies in J/(N mol).
\PYGZsh{} N is the number of formula units per cell.
\PYGZsh{}
\PYGZsh{} T (K) 	Evib (Ry/cell)	Fvib (Ry/cell)	Svib (Ry/cell/K)	Cvib (Ry/cell/K)
1.0000000000e+00	5.6214272416e\PYGZhy{}03	5.6214271698e\PYGZhy{}03	7.1803604634e\PYGZhy{}11	2.7457378670e\PYGZhy{}11
1.5000000000e+00	5.6214272660e\PYGZhy{}03	5.6214271296e\PYGZhy{}03	9.0971071082e\PYGZhy{}11	7.6156598111e\PYGZhy{}11
2.0000000000e+00	5.6214273247e\PYGZhy{}03	5.6214270765e\PYGZhy{}03	1.2411743622e\PYGZhy{}10	1.6670823649e\PYGZhy{}10
2.5000000000e+00	5.6214274420e\PYGZhy{}03	5.6214270023e\PYGZhy{}03	1.7586528823e\PYGZhy{}10	3.1294495785e\PYGZhy{}10
3.0000000000e+00	5.6214276492e\PYGZhy{}03	5.6214268967e\PYGZhy{}03	2.5083680991e\PYGZhy{}10	5.2875068522e\PYGZhy{}10
3.5000000000e+00	5.6214279847e\PYGZhy{}03	5.6214267469e\PYGZhy{}03	3.5365843213e\PYGZhy{}10	8.2803005242e\PYGZhy{}10
4.0000000000e+00	5.6214284935e\PYGZhy{}03	5.6214265377e\PYGZhy{}03	4.8896152188e\PYGZhy{}10	1.2247123119e\PYGZhy{}09
4.5000000000e+00	5.6214292279e\PYGZhy{}03	5.6214262517e\PYGZhy{}03	6.6138346588e\PYGZhy{}10	1.7327611278e\PYGZhy{}09
5.0000000000e+00	5.6214302472e\PYGZhy{}03	5.6214258693e\PYGZhy{}03	8.7556952905e\PYGZhy{}10	2.3661903162e\PYGZhy{}09
5.5000000000e+00	5.6214316174e\PYGZhy{}03	5.6214253684e\PYGZhy{}03	1.1361755892e\PYGZhy{}09	3.1390850039e\PYGZhy{}09
6.0000000000e+00	5.6214334118e\PYGZhy{}03	5.6214247246e\PYGZhy{}03	1.4478717445e\PYGZhy{}09	4.0656278651e\PYGZhy{}09
6.5000000000e+00	5.6214357110e\PYGZhy{}03	5.6214239112e\PYGZhy{}03	1.8153467817e\PYGZhy{}09	5.1601305330e\PYGZhy{}09
7.0000000000e+00	5.6214386024e\PYGZhy{}03	5.6214228992e\PYGZhy{}03	2.2433135214e\PYGZhy{}09	6.4370706688e\PYGZhy{}09
7.5000000000e+00	5.6214421809e\PYGZhy{}03	5.6214216571e\PYGZhy{}03	2.7365150966e\PYGZhy{}09	7.9111356177e\PYGZhy{}09
8.0000000000e+00	5.6214465489e\PYGZhy{}03	5.6214201510e\PYGZhy{}03	3.2997322753e\PYGZhy{}09	9.5972742802e\PYGZhy{}09
8.5000000000e+00	5.6214518161e\PYGZhy{}03	5.6214183448e\PYGZhy{}03	3.9377920199e\PYGZhy{}09	1.1510759902e\PYGZhy{}08
9.0000000000e+00	5.6214581001e\PYGZhy{}03	5.6214161999e\PYGZhy{}03	4.6555775947e\PYGZhy{}09	1.3667267917e\PYGZhy{}08
9.5000000000e+00	5.6214655265e\PYGZhy{}03	5.6214136752e\PYGZhy{}03	5.4580406777e\PYGZhy{}09	1.6082974484e\PYGZhy{}08
1.0000000000e+01	5.6214742291e\PYGZhy{}03	5.6214107269e\PYGZhy{}03	6.3502160901e\PYGZhy{}09	1.8774682469e\PYGZhy{}08
1.0500000000e+01	5.6214843502e\PYGZhy{}03	5.6214073091e\PYGZhy{}03	7.3372398855e\PYGZhy{}09	2.1759981704e\PYGZhy{}08
1.1000000000e+01	5.6214960411e\PYGZhy{}03	5.6214033730e\PYGZhy{}03	8.4243715943e\PYGZhy{}09	2.5057449144e\PYGZhy{}08
1.1500000000e+01	5.6215094629e\PYGZhy{}03	5.6213988672e\PYGZhy{}03	9.6170213626e\PYGZhy{}09	2.8686891747e\PYGZhy{}08
1.2000000000e+01	5.6215247869e\PYGZhy{}03	5.6213937375e\PYGZhy{}03	1.0920782549e\PYGZhy{}08	3.2669631041e\PYGZhy{}08
1.2500000000e+01	5.6215421953e\PYGZhy{}03	5.6213879269e\PYGZhy{}03	1.2341470051e\PYGZhy{}08	3.7028823823e\PYGZhy{}08
1.3000000000e+01	5.6215618826e\PYGZhy{}03	5.6213813755e\PYGZhy{}03	1.3885164240e\PYGZhy{}08	4.1789809033e\PYGZhy{}08
1.3500000000e+01	5.6215840567e\PYGZhy{}03	5.6213740202e\PYGZhy{}03	1.5558259988e\PYGZhy{}08	4.6980467173e\PYGZhy{}08
1.4000000000e+01	5.6216089398e\PYGZhy{}03	5.6213657946e\PYGZhy{}03	1.7367519841e\PYGZhy{}08	5.2631576208e\PYGZhy{}08
1.4500000000e+01	5.6216367707e\PYGZhy{}03	5.6213566288e\PYGZhy{}03	1.9320130039e\PYGZhy{}08	5.8777146866e\PYGZhy{}08
1.5000000000e+01	5.6216678056e\PYGZhy{}03	5.6213464493e\PYGZhy{}03	2.1423757831e\PYGZhy{}08	6.5454720686e\PYGZhy{}08
1.5500000000e+01	5.6217023209e\PYGZhy{}03	5.6213351785e\PYGZhy{}03	2.3686608350e\PYGZhy{}08	7.2705615875e\PYGZhy{}08
1.6000000000e+01	5.6217406143e\PYGZhy{}03	5.6213227346e\PYGZhy{}03	2.6117479280e\PYGZhy{}08	8.0575108690e\PYGZhy{}08
1.6500000000e+01	5.6217830073e\PYGZhy{}03	5.6213090314e\PYGZhy{}03	2.8725811574e\PYGZhy{}08	8.9112541358e\PYGZhy{}08
\end{sphinxVerbatim}

The first line is the simple integral of the input dos. It must be approximately equal to \(3N\), where \sphinxstyleemphasis{N} is the number of atoms in the cell. In the present case (h.c.p. Os) it is equal to 6. The second line shows the Zero Point Energy (ZPE). After a few comments lines, the vibrational energy (Evib), Helmholtz energy (Fvib), entropy (Svib) and heat capacity (Cvib) are written as a function of temperature. All quantities are calculated in the harmonic approximation, i.e. for fixed volume (and lattice parameters).

The original dos is plotted as:

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_12}.png}

The calculated thermodynaminc functions are plotted as:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_21}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_31}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_4}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_5}.png}

The following code (example4) shows how multiple dos files can be handled, a step which is preliminary to a quasi-harmonic calculation. The dos are for different volumes (for hexagonal Os).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}

\PYG{n}{fin} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fout} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{9}				

\PYG{n}{gE}\PYG{p}{,} \PYG{n}{gdos} \PYG{o}{=} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{)} 	\PYG{c+c1}{\PYGZsh{} read ngeo=9 dos files}


\PYG{c+c1}{\PYGZsh{} plot the first 5 phonon dos    }
\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{gE}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{gdos}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E (Ryd/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phonon DOS (cell/Ryd)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{TT} \PYG{o}{=}\PYG{n}{gen\PYGZus{}TT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}

\PYG{c+c1}{\PYGZsh{} compute the thermodynamic properties for all ngeo dos files and write them in fout+\PYGZdq{}i\PYGZdq{} files, where is an int from 1 to ngeo}
\PYG{n}{T}\PYG{p}{,} \PYG{n}{ggEvib}\PYG{p}{,} \PYG{n}{ggFvib}\PYG{p}{,} \PYG{n}{ggSvib}\PYG{p}{,} \PYG{n}{ggCvib}\PYG{p}{,} \PYG{n}{ggZPE}\PYG{p}{,} \PYG{n}{ggmodes} \PYG{o}{=} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{fout}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the vibrational Helmholtz energy for the first 5 phonon dos    }
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ggFvib}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}2.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the vibrational entropy for the first 5 phonon dos    }
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ggSvib}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}3.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the vibrational heat capacity for the first 5 phonon dos    }
\PYG{n}{fig4} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ggCvib}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cvib (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}4.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

The first 5 phonon dos are plotted as (color order is: black, red, blue, green, cyan for increasing volumes):

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{figure_13}.png}

The corresponding vibrational Helmoltz energies, entropies and heat capacity are plotted as:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_22}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_32}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_41}.png}


\section{Computing quasi-harmonic properties (examples 5 and 6)}
\label{tutorial:computing-quasi-harmonic-properties-examples-5-and-6}
Here we show how to do a full quasi-harmonic calculation starting from the \(E_{tot}\) at 0 K and phonon DOS. First, we show an example using the Murnaghan EOS, having \(E_{tot}(V)\) and the corresponding DOS, then using a quartic polynomial on the full grid \((a,c)\) for an hexagonal cell.

Here is the code in the Murnaghan case:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{RY\PYGZus{}KBAR}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{,} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{fitFvibV}\PYG{p}{,} \PYG{n}{write\PYGZus{}xy}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}

\PYG{c+c1}{\PYGZsh{} this part is for calculating the thermodynamic properties from the dos}
\PYG{n}{fdos}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fthermo} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{9}	\PYG{c+c1}{\PYGZsh{} this is the number of volumes for which a dos has been calculated			}

\PYG{n}{TT} \PYG{o}{=}\PYG{n}{gen\PYGZus{}TT}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}
\PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib}\PYG{p}{,} \PYG{n}{ZPE}\PYG{p}{,} \PYG{n}{modes} \PYG{o}{=} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fdos}\PYG{p}{,}\PYG{n}{fthermo}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{)}
\PYG{n}{nT} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Alternatively, read the thermodynamic data from files, if you have already}
\PYG{c+c1}{\PYGZsh{} done the calculations. Uncomment the following 2 lines and delete the previous 3 lines}
\PYG{c+c1}{\PYGZsh{}T1, Evib1, Fvib1, Svib1, Cvib1 = read\PYGZus{}thermo( fthermo, ngeo )}
\PYG{c+c1}{\PYGZsh{}T, T, Evib, Fvib, Svib, Cvib = rearrange\PYGZus{}thermo( T1, Evib1, Fvib1, Svib1, Cvib1, ngeo )    }


\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{thermodata} \PYG{o}{=} \PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} 
\PYG{n}{TT}\PYG{p}{,} \PYG{n}{Fmin}\PYG{p}{,} \PYG{n}{Vmin}\PYG{p}{,} \PYG{n}{B0}\PYG{p}{,} \PYG{n}{betaT}\PYG{p}{,} \PYG{n}{Cv}\PYG{p}{,} \PYG{n}{Cp}\PYG{p}{,} \PYG{n}{aT}\PYG{p}{,} \PYG{n}{chi} \PYG{o}{=} \PYG{n}{fitFvibV}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{)}

\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Fmin}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Vmin}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Vmin (a.u.\PYGZca{}3)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{B0}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B0 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{betaT}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{beta}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig5} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Cp}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cp (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}2.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}3.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}4.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig5}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}5.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    

\PYG{c+c1}{\PYGZsh{} save the results in a file if you want...}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Fmin}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin (Ryd/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Vmin.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{Vmin}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Vmin (a.u.\PYGZca{}3)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B0.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{B0}\PYG{o}{*}\PYG{n}{RY\PYGZus{}KBAR}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B0 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{write\PYGZus{}xy}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{beta.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,} \PYG{n}{betaT}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Beta=1/V dV/dT (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{n}{CvCp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CvCp}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Cv}
\PYG{n}{CvCp}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Cp}
\PYG{n}{fig6} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CvCp}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cv/Cp (Ry/cell/K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig6}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}6.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{print\PYGZus{}eos\PYGZus{}data}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,}\PYG{n}{E}\PYG{o}{+}\PYG{n}{Fvib}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{a}\PYG{p}{,}\PYG{n}{chi}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} print full detail at each T}

\end{sphinxVerbatim}

Note from the first line that there are some constants you can import from the module and use for unit conversions. See the documentation for more details on which ones are available.
In this example, 9 volumes are used (ngeo=9). First the harmonic thermodynamic properties are computed as in the previous example. You store these quantities in a list called \sphinxstyleemphasis{thermodata}. You also need to read the total energies as in example 1 from the file \sphinxstyleemphasis{Etot.dat}, which is taken care inside the function \sphinxcode{fitEtotV()}. This is the function which is really doing the quasi-harmonic calculations, i.e. it fits a Murnaghan EOS at each T using \(E_{tot}(V)+F_{vib}(V,T)\). It returns \sphinxstyleemphasis{TT, Fmin, Vmin, B0, betaT, Cv, Cp}, which are all numpy 1D arrays containing the temperatures where the calculations were done and the resulting minimun Helmholtz energy (at each T), minimun volume, isobaric bulk modulus, volume thermal expansion, constant volume and constant pressure heat capacities, respectively. These quantities correspond to \(P=0\).

The following lines show how to plot each quantity on a single plot (using the function \sphinxcode{simple\_plot\_xy()}), write the results in files (using the \sphinxcode{write\_xy()}) and plot both \sphinxstyleemphasis{Cv} and \sphinxstyleemphasis{Cp} in a single plot (using the function \sphinxcode{multiple\_plot\_xy()}).

If everything went well, you should get the following plots:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_14}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_23}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_33}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_42}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_51}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_6}.png}

In the following we show the code for a similar example of an hexagonal (anisotropic) system. The code is similar to the previous examples with a few important differences.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{RY\PYGZus{}KBAR}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{,} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{fitFvib}\PYG{p}{,} \PYG{n}{write\PYGZus{}celldmsT}\PYG{p}{,} \PYG{n}{write\PYGZus{}alphaT}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}

\PYG{c+c1}{\PYGZsh{} this part is for calculating the thermodynamic properties from the dos}
\PYG{n}{fdos}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fthermo} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{25}	\PYG{c+c1}{\PYGZsh{} this is the number of volumes for which a dos has been calculated			}

\PYG{c+c1}{\PYGZsh{}TT =gen\PYGZus{}TT(1,1000)	\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}
\PYG{c+c1}{\PYGZsh{}T, Evib, Fvib, Svib, Cvib, ZPE, modes = compute\PYGZus{}thermo\PYGZus{}geo(fdos,fthermo,ngeo,TT)}
\PYG{c+c1}{\PYGZsh{}nT = len(T)}

\PYG{c+c1}{\PYGZsh{} Alternatively, read the thermodynamic data from files if you have already}
\PYG{c+c1}{\PYGZsh{} done the calculations}
\PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1} \PYG{o}{=} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{fthermo}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}
\PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} \PYG{o}{=} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}    


\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{thermodata} \PYG{o}{=} \PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} 
\PYG{n}{TT}\PYG{p}{,} \PYG{n}{Fmin}\PYG{p}{,} \PYG{n}{celldmsminT}\PYG{p}{,} \PYG{n}{alphaT}\PYG{p}{,} \PYG{n}{a0}\PYG{p}{,} \PYG{n}{chi}\PYG{p}{,} \PYG{n}{aT}\PYG{p}{,} \PYG{n}{chi} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{minoptions}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gtol}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{Fmin}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fmin (Ry/cell)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{/}\PYG{n}{celldmsminT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c/a }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    
\PYG{n}{fig5} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{alphaT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}xx (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig6} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{alphaT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}zz (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} write a(T) and c(T) on a file}
\PYG{n}{write\PYGZus{}celldmsT}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{celldmminT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{celldmsminT}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} write alpha\PYGZus{}xx(T) and alpha\PYGZus{}zz(T) on a file}
\PYG{n}{write\PYGZus{}alphaT}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alphaT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{T}\PYG{p}{,}\PYG{n}{alphaT}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot several quantities at T=998+1 K as an example}
\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Ex} \PYG{o}{=} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} since the fitFvib does not return Etot data, you must read them from the original file}
\PYG{n}{iT}\PYG{o}{=}\PYG{l+m+mi}{998}                  \PYG{c+c1}{\PYGZsh{} this is the index of the temperatures array, not the temperature itself}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T= }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{TT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot only with fitted energy (Etot+Fvib)}
\PYG{n}{fig7} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{o}{+}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot fitted energy and points}
\PYG{n}{fig8} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{+}\PYG{n}{Fvib}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{o}{+}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 3D plot with fitted energy Fvib only}
\PYG{n}{fig9} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{Ex}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy (Etot+Fvib)}
\PYG{n}{fig10} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a0}\PYG{o}{+}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy Fvib only}
\PYG{n}{fig11} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{aT}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)}   

\PYG{c+c1}{\PYGZsh{} Save all plots}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}2.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}3.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}4.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig5}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}5.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    
\PYG{n}{fig6}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}6.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}      
\PYG{n}{fig7}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}7.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 
\PYG{n}{fig8}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}8.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig9}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}9.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig10}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}10.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig11}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}11.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

If everything went well,  you should get the following plots:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_15}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_24}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_34}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_43}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_52}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_61}.png}


\section{Computing quasi-static elastic constants (example 7)}
\label{tutorial:computing-quasi-static-elastic-constants-example-7}
The following code example shows how to do a calculation of a quasi-static elastic tensor as a function of temperature for an hexagonal system. This kind of calculation requires that a quasi-harmonic calculation has already be done (as in example 6). Besides, the elastic constants for different \((a,c)\) values must be available. To compute these elastic constants you can use for example the thermo\_pw code \footnote[1]{\sphinxAtStartFootnote
\url{http://qeforge.qe-forge.org/gf/project/thermo\_pw/}
}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{RY\PYGZus{}KBAR}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{,} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{fitFvib}\PYG{p}{,} \PYG{n}{write\PYGZus{}celldmsT}\PYG{p}{,} \PYG{n}{write\PYGZus{}alphaT}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{read\PYGZus{}elastic\PYGZus{}constants\PYGZus{}geo}\PYG{p}{,} \PYG{n}{write\PYGZus{}C\PYGZus{}geo}\PYG{p}{,} \PYG{n}{write\PYGZus{}CT}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}Cx}\PYG{p}{,} \PYG{n}{fitCxx}\PYG{p}{,} \PYG{n}{fitCT}

\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Ex} \PYG{o}{=} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} since the fitFvib does not return Etot data, you must read them from the original file}
    
\PYG{c+c1}{\PYGZsh{} this part is for calculating the thermodynamic properties from the dos}
\PYG{n}{fdos}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fthermo} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{25}	\PYG{c+c1}{\PYGZsh{} this is the number of volumes for which a dos has been calculated  }

\PYG{c+c1}{\PYGZsh{}TT =gen\PYGZus{}TT(1,1000)	\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}
\PYG{c+c1}{\PYGZsh{}T, Evib, Fvib, Svib, Cvib, ZPE, modes = compute\PYGZus{}thermo\PYGZus{}geo(fdos,fthermo,ngeo,TT)}
\PYG{c+c1}{\PYGZsh{}nT = len(T)}

\PYG{c+c1}{\PYGZsh{} Alternatively, read the thermodynamic data from files if you have already}
\PYG{c+c1}{\PYGZsh{} done the calculations}
\PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1} \PYG{o}{=} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{fthermo}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}
\PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} \PYG{o}{=} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}   

\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{thermodata} \PYG{o}{=} \PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} 
\PYG{n}{TT}\PYG{p}{,} \PYG{n}{Fmin}\PYG{p}{,} \PYG{n}{celldmsminT}\PYG{p}{,} \PYG{n}{alphaT}\PYG{p}{,} \PYG{n}{a0}\PYG{p}{,} \PYG{n}{chi}\PYG{p}{,} \PYG{n}{aT}\PYG{p}{,} \PYG{n}{chi} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{typeEtot}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{typeFvib}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{defaultguess}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{5.12374914}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{8.19314311}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Now start the quasi\PYGZhy{}static calculation    }
\PYG{n}{fC} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./elastic\PYGZus{}constants/output\PYGZus{}el\PYGZus{}cons.g}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Read the elastic constants and compliances from files }
\PYG{n}{Cx}\PYG{p}{,} \PYG{n}{Sx} \PYG{o}{=} \PYG{n}{read\PYGZus{}elastic\PYGZus{}constants\PYGZus{}geo}\PYG{p}{(}\PYG{n}{fC}\PYG{p}{,} \PYG{n}{ngeo}\PYG{p}{)}    
\PYG{n}{Cxx} \PYG{o}{=} \PYG{n}{rearrange\PYGZus{}Cx}\PYG{p}{(}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{ngeo}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} rearrange them in the proper order for fitting}

\PYG{c+c1}{\PYGZsh{} Optionally save them}
\PYG{n}{write\PYGZus{}C\PYGZus{}geo}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Cxx}\PYG{p}{,} \PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{fCout}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./elastic\PYGZus{}constants/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fit the elastic constants as a function of celldmsx}
\PYG{n}{aC}\PYG{p}{,} \PYG{n}{chiC} \PYG{o}{=} \PYG{n}{fitCxx}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Cxx}\PYG{p}{,} \PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{typeC}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{T}\PYG{p}{,} \PYG{n}{CT} \PYG{o}{=} \PYG{n}{fitCT}\PYG{p}{(}\PYG{n}{aC}\PYG{p}{,} \PYG{n}{chiC}\PYG{p}{,} \PYG{n}{TT}\PYG{p}{,} \PYG{n}{celldmsminT}\PYG{p}{,} \PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{typeC}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quadratic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
       
\PYG{n}{write\PYGZus{}CT}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{,}\PYG{n}{fCout}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./elastic\PYGZus{}constants/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C11 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C12 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C13 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{TT}\PYG{p}{,}\PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C33 (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}2.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}3.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}4.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} plot now 4 elastic constants in the same plot}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{n}{pCxx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{pCxx}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CT}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{Clabels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C11}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C12}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C13}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C33}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{fig5} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,}\PYG{n}{pCxx}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cxx (kbar)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{n}{Clabels}\PYG{p}{)}
\PYG{n}{fig5}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}5.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    

\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_16}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_25}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_35}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_44}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_53}.png}


\section{Numerical issues (example 8)}
\label{tutorial:numerical-issues-example-8}
It is important to realize that the practical application of the quasi-harmonic approximation relies on fitting and minimizing the free energy as a function of volume, lattice parameters and temperature, ultimately on numerical methods. \sphinxcode{pyqha} uses numpy and scipy functions to this aim. The user must select the best methods/options for the specific system under investigation and it is always better to test, test, test...

The following example shows how different methods/options may lead to different sets of results. Sometimes the differences are within the target numerical precision. Sometimes the results are simply wrong because of an improper choice of the methods/options.

First, let's compute some example results for a hypotetical hexagonal system, using total energy and phonon DOS for different values of \((a,c)\) lattice parameters. We use all default values of the function \sphinxcode{fitFvib()}, i.e. a quadratic polynomial for fitting the total energies, a quadratic polynomial for fitting the vibrational energies, BFGS algorithm for minimization with default options (see the documentation of scipy.optimize.minimize for more details).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{RY\PYGZus{}KBAR}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{gen\PYGZus{}TT}\PYG{p}{,} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{read\PYGZus{}dos\PYGZus{}geo}\PYG{p}{,} \PYG{n}{compute\PYGZus{}thermo\PYGZus{}geo}\PYG{p}{,} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{,} \PYG{n}{fitFvib}\PYG{p}{,} \PYG{n}{write\PYGZus{}celldmsT}\PYG{p}{,} \PYG{n}{write\PYGZus{}alphaT}
\PYG{k+kn}{from} \PYG{n+nn}{pyqha} \PYG{k+kn}{import} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{,} \PYG{n}{plot\PYGZus{}Etot}\PYG{p}{,} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{,} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} this part is for calculating the thermodynamic properties from the dos}
\PYG{n}{fdos}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dos\PYGZus{}files/output\PYGZus{}dos.dat.g}\PYG{l+s+s2}{\PYGZdq{}}	\PYG{c+c1}{\PYGZsh{} base name for the dos files (numbers will be added as postfix)}
\PYG{n}{fthermo} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermo}\PYG{l+s+s2}{\PYGZdq{}}		\PYG{c+c1}{\PYGZsh{} base name for the output files (numbers will be added as postfix)}

\PYG{n}{ngeo} \PYG{o}{=} \PYG{l+m+mi}{25}	\PYG{c+c1}{\PYGZsh{} this is the number of volumes for which a dos has been calculated			}

\PYG{c+c1}{\PYGZsh{}TT =gen\PYGZus{}TT(1,2000)	\PYGZsh{} generate the numpy array of temperatures for which the properties will be calculated}
\PYG{c+c1}{\PYGZsh{}T, Evib, Fvib, Svib, Cvib, ZPE, modes = compute\PYGZus{}thermo\PYGZus{}geo(fdos,fthermo,ngeo,TT)}
\PYG{c+c1}{\PYGZsh{}nT = len(T)}

\PYG{c+c1}{\PYGZsh{} Alternatively, read the thermodynamic data from files if you have already}
\PYG{c+c1}{\PYGZsh{} done the calculations}
\PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1} \PYG{o}{=} \PYG{n}{read\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{fthermo}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}
\PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} \PYG{o}{=} \PYG{n}{rearrange\PYGZus{}thermo}\PYG{p}{(} \PYG{n}{T1}\PYG{p}{,} \PYG{n}{Evib1}\PYG{p}{,} \PYG{n}{Fvib1}\PYG{p}{,} \PYG{n}{Svib1}\PYG{p}{,} \PYG{n}{Cvib1}\PYG{p}{,} \PYG{n}{ngeo} \PYG{p}{)}    


\PYG{n}{fEtot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Etot.dat}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{thermodata} \PYG{o}{=} \PYG{n}{nT}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Evib}\PYG{p}{,} \PYG{n}{Fvib}\PYG{p}{,} \PYG{n}{Svib}\PYG{p}{,} \PYG{n}{Cvib} 

\PYG{c+c1}{\PYGZsh{} Fit and minimize with default options, quadratic polynomials for both Etot and Fvib, minimization method=\PYGZdq{}BFGS\PYGZdq{}, minoptions=\PYGZob{}\PYGZsq{}gtol\PYGZsq{}: 1e\PYGZhy{}5\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}TT, Fmin, celldmsminT, alphaT, a0, chi, aT, chiT = fitFvib(fEtot,thermodata)}
\PYG{n}{res1} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{)}
\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}xx (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig4} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}zz (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

Running the above code and observing the results below, you can notice that the thermal expansions present some spikes. These quantities are obtained as numerical derivatives of the lattice parameters and are thus more sensitive to any numerical noise. The default convergence criterium, minoptions=\{`gtol': 1e-5\}, for the minimization BFGS algorithm is not sufficient to obtain good results.

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_17}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_26}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_36}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_45}.png}

Let's see what happens if we now systematically increase \sphinxstyleemphasis{gtol}, using the same minimization method (BFGS):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Fit and minimize with quadratic polynomials for both Etot and Fvib, minimization method=\PYGZdq{}BFGS\PYGZdq{}, increasing gtol}
\PYG{n}{res2} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BFGS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{minoptions}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gtol}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{res3} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BFGS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{minoptions}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gtol}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{res4} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BFGS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{minoptions}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gtol}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot together the 3 resulting thermal expansions}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res2}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res3}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res4}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{fig5} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res2}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res3}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res4}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{fig6} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res2}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res3}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res4}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{fig7} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}xx (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res2}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res3}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res4}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{fig8} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}zz (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}7}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1e\PYGZhy{}8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}


\end{sphinxVerbatim}

The results of the above code are shown here:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_54}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_62}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_7}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_8}.png}

As you can see, the thermal expansions are getting better, but there is still some noise at high temperature, even with the slowest \sphinxstyleemphasis{gtol}. If you try the ``Newton-CG'' algorithm you can finally get rid of these spikes.

Let's see now what happens if we now use different polynomial forms for fitting, but the same minimization method (Newton-CG) and convergence criterium, minoptions=\{`gtol': 1e-7\}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Refit the quadratic polynomial for Etot and quadratic for Fvib, default minimization method=\PYGZdq{}Newton\PYGZhy{}CG\PYGZdq{}, higher minoptions=\PYGZob{}\PYGZsq{}gtol\PYGZsq{}: 1e\PYGZhy{}7\PYGZcb{}}
\PYG{n}{res5} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton\PYGZhy{}CG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{minoptions}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gtol}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fit the quartic polynomial for Etot and quadratic for Fvib, default minimization method=\PYGZdq{}Newton\PYGZhy{}CG\PYGZdq{}, higher minoptions=\PYGZob{}\PYGZsq{}gtol\PYGZsq{}: 1e\PYGZhy{}7\PYGZcb{}}
\PYG{n}{res6} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton\PYGZhy{}CG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{typeEtot}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{minoptions}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gtol}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fit the quartic polynomial for Etot and quartic for Fvib, default minimization method=\PYGZdq{}Newton\PYGZhy{}CG\PYGZdq{}, higher minoptions=\PYGZob{}\PYGZsq{}gtol\PYGZsq{}: 1e\PYGZhy{}7\PYGZcb{}}
\PYG{n}{res7} \PYG{o}{=} \PYG{n}{fitFvib}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{,}\PYG{n}{thermodata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton\PYGZhy{}CG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{typeEtot}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{typeFvib}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{minoptions}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gtol}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot together the 3 resulting lattice parameters and thermal expansions}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res5}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res6}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{fig9} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quad+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quart fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res5}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res6}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{fig10} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c\PYGZus{}min (a.u.)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quad+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quart fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res5}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res6}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{fig11} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}xx (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quad+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quart fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res5}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}	
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res6}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{fig12} \PYG{o}{=} \PYG{n}{multiple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alpha\PYGZus{}zz (1/K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quad+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quad fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quart+quart fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}

\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_9}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_10}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_111}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_121}.png}

You can see that the fit with quadratic polynomials for both Etot and Fvib (quad+quad) gives a slightly different result, especially at 0 K, with a difference of the order of 0.2\%. Some minor differences remain even when using quadratic/quartic or quartic/quartic polynomials. In general, a quartic polynomial is expected to provide a better fit, but care must be paid to avoid overfitting and the best choice also depends on the shape of your energy surface.

Finally, let's see another numerical issue in quasi-harmonic calculations which is illustrated in the following code and figures:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} The minimum shifts with temperature, so does the quality of the fit (for example the chi\PYGZca{}2)}
\PYG{n}{celldmsx}\PYG{p}{,} \PYG{n}{Ex} \PYG{o}{=} \PYG{n}{read\PYGZus{}Etot}\PYG{p}{(}\PYG{n}{fEtot}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} since the fitFvib does not return Etot data, you must read them from the original file}
\PYG{n}{iT}\PYG{o}{=}\PYG{l+m+mi}{1}                  \PYG{c+c1}{\PYGZsh{} this is the index of the temperatures array, not the temperature itself}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T= }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy (Etot+Fvib)}
\PYG{n}{fig13} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{+}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)} 
\PYG{n}{iT}\PYG{o}{=}\PYG{l+m+mi}{1998}                  \PYG{c+c1}{\PYGZsh{} this is the index of the temperatures array, not the temperature itself}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T= }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 2D contour plot with fitted energy (Etot+Fvib)}
\PYG{n}{fig14} \PYG{o}{=} \PYG{n}{plot\PYGZus{}Etot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{celldmsx}\PYG{p}{,}\PYG{n}{nmesh}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,}\PYG{n}{fittype}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quartic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ibrav}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{a}\PYG{o}{=}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{+}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{[}\PYG{n}{iT}\PYG{p}{]}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} plot the chi\PYGZca{}2 as a function of temperature}
\PYG{n}{fig15} \PYG{o}{=} \PYG{n}{simple\PYGZus{}plot\PYGZus{}xy}\PYG{p}{(}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{+}\PYG{n}{res7}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T (K)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{chi\PYGZca{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   

\end{sphinxVerbatim}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_131}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_141}.png}

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{figure_151}.png}

The first two figures above show iso-contour lines for the \(E_{tot}(a,c)+F_{vib}(a,c)\) surface at T=1 K and T=1999 K. You can see that the minimum is shifting as expected because of thermal expansion (usually positive) and as a consequence it becomes closer to the boundary of the chosen \((a,c)\) grid. It is important to check that the minimun does not get too close to the boundary in order to avoid a serious decrease of the fit accuracy. In any case, the \(\chi^2\) of the fitting procedure is always slightly changing (usually increasing) with temperature, as shown in the last figure.


\chapter{pyqha package}
\label{pyqha:pyqha-package}\label{pyqha::doc}

\section{Module contents}
\label{pyqha:module-contents}
The following functions are available from \sphinxcode{pyqha} module and are the most common ones for the end user.
\phantomsection\label{pyqha:module-pyqha.fitEtot}\index{pyqha.fitEtot (module)}\index{fitEtot() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitEtot.fitEtot}\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtot}}{\emph{fin}, \emph{out=True}, \emph{ibrav=4}, \emph{fittype='quadratic'}, \emph{guess=None}, \emph{method='BFGS'}, \emph{minoptions=\{\}}}{}
This function reads the file \sphinxstyleemphasis{fin} containing the energies as a function
of the lattice parameters \(E(a,b,c)\) and fits them with a quartic (\sphinxstyleemphasis{fittype=''quartic''}) or 
quadratic (\sphinxstyleemphasis{fittype=''quadratic''}) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redirected to \sphinxstyleemphasis{stdout})
if \sphinxstyleemphasis{out=True}.
It returns the lattice parameters and energies as in the input file \sphinxstyleemphasis{fin},
the fitted coefficients of the polynomial, the corresponding \(\chi^2\),
the lattice parameters at the minimum and the minimun energy.

Note: for cubic systems use fitEtotV instead.

Advanced input parameters:

\sphinxstyleemphasis{guess}, an initial guess for the minimization. It is a 6 elements list 
{[}a,b,c,0,0,0{]}.

\sphinxstyleemphasis{method}, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details.

\sphinxstyleemphasis{minoptions}, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.

\end{fulllineitems}

\index{fitEtotV() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitEtot.fitEtotV}\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtotV}}{\emph{fin}, \emph{fout=None}}{}
This function reads \(E(V)\) data from the input file \sphinxstyleemphasis{fin}, fits them with a Murnaghan EOS,
prints the results on the \sphinxstyleemphasis{stdout} and write them in the file ``fout''.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding \(\chi^2\).

\end{fulllineitems}

\phantomsection\label{pyqha:module-pyqha.thermo}\index{pyqha.thermo (module)}\index{compute\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.compute_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo}}{\emph{E}, \emph{dos}, \emph{TT}}{}
This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays \sphinxstyleemphasis{E} 
and \sphinxstyleemphasis{dos} containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array \sphinxstyleemphasis{TT}.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to \(3*N\), with \sphinxstyleemphasis{N} the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.

\end{fulllineitems}

\index{compute\_thermo\_geo() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.compute_thermo_geo}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo\_geo}}{\emph{fin}, \emph{fout=None}, \emph{ngeo=1}, \emph{TT=array({[}1{]})}}{}
This function reads the input dos file(s) from \sphinxstyleemphasis{fin+i}, with \sphinxstyleemphasis{i} a number from
1 to \sphinxstyleemphasis{ngeo} + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
T
\unskip}\relax &
\(E_{vib}\)
&
\(F_{vib}\)
&
\(S_{vib}\)
&
\(C_{vib}\)
\\
\hline
1
&
...
&
...
&
...
&
...
\\
\hline\end{tabulary}


and are names \sphinxstyleemphasis{fout} +1, \sphinxstyleemphasis{fout} +2,... for each geometry.

Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib{[}T,geo{]} -\textgreater{} Fvib at the temperature ``T'' for the geometry ``geo''

\end{fulllineitems}

\index{dos\_integral() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.dos_integral}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{dos\_integral}}{\emph{E}, \emph{dos}, \emph{m=0}}{}
A function to compute the integral of an input phonon DOS (\sphinxstyleemphasis{dos}) with the 3/8 Simpson method.
\sphinxstyleemphasis{m} is the moment of the integral, if \(m>0\) different moments can be calculated.
For example, with \(m=0\) (default) it returns the number of modes from the dos, 
with \(m=1\) it returns the ZPE. The input energy (\sphinxstyleemphasis{E}) and phonon DOS (\sphinxstyleemphasis{dos}) are expected to be in
\(cm^{-1}\).

\end{fulllineitems}

\index{gen\_TT() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.gen_TT}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{gen\_TT}}{\emph{Tstart=1}, \emph{Tend=1000}, \emph{Tstep=1}}{}
A simple function to generate a numpy array of temperatures, starting from
\sphinxstyleemphasis{Tstart} and ending to \sphinxstyleemphasis{Tend} (or the closest \sphinxstyleemphasis{T\textless{}Tend} accorinding to the \sphinxstyleemphasis{Tstep} )
with step \sphinxstyleemphasis{Tstep} .

\end{fulllineitems}

\index{rearrange\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.thermo.rearrange_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{rearrange\_thermo}}{\emph{T}, \emph{Evib}, \emph{Fvib}, \emph{Svib}, \emph{Cvib}, \emph{ngeo=1}}{}
This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices \sphinxstyleemphasis{X} now gives all geometries at a given
\sphinxstyleemphasis{T}, i.e. \sphinxstyleemphasis{X{[}0{]}} is the vector of the property \sphinxstyleemphasis{X} a \sphinxstyleemphasis{T=T{[}0,0{]}} . \sphinxstyleemphasis{X{[}0,0{]}} for the first 
geometry, \sphinxstyleemphasis{X{[}0,1{]}} the second geometry and so on.

\end{fulllineitems}

\phantomsection\label{pyqha:module-pyqha.fitFvib}\index{pyqha.fitFvib (module)}\index{fitFvib() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitFvib.fitFvib}\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvib}}{\emph{fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess={[}0.0, 0.0, 0.0, 0.0, 0.0, 0.0{]}, method='BFGS', minoptions=\{\}, splinesoptions=None}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(a,b,c)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(a,b,c,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in \sphinxstyleemphasis{fin} file. The 
real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

The function fits \(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) with a quadratic
or quartic polynomial (as defined by \sphinxstyleemphasis{typeEtot} and \sphinxstyleemphasis{typeFvib} ) at each
temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting \(E_{tot}(a,b,c)\)
and \(F_{vib}(a,b,c)\). Then it computes the minimun energy \(E_{tot}+F_{vib}\)
and the corresponding lattice parameters \((a_{min},b_{min},c_{min})\) 
at each temperature by miniimizing the energy.

It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (\sphinxcode{compute\_alpha()}).

It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the \(\chi^2\) for \(E_{tot}(a,b,c)\) 
only (at T=0 K) and the fitted coefficients and the \(\chi^2\) for 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) at each temperature.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example6} and 
the tutorial.
\end{sphinxadmonition}

Advanced input parameters:

\sphinxstyleemphasis{guess}, an initial guess for the minimization. It is a 6 elements list 
{[}a,b,c,0,0,0{]}.

\sphinxstyleemphasis{method}, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details. Note that the 
methods which usually gives better results for quasi-harmonic calculations
are the ``BFGS'' or Newton-CG''. Default is ``BFGS''.

\sphinxstyleemphasis{minoptions}, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.
Note the the options are different for different methods.

\sphinxstyleemphasis{splinesoptions}, determines whether to use or not splines to reduce the noise
on numerical derivatives (thermal expansions). If \sphinxstyleemphasis{splinesoptions*==None, use 
finete differences for derivatives, else use splines as implemented in
scipy.interpolate (see documentation). In the latter case, *splinesoptions}
must be a dictionary. This dictionary must contains the keywords \sphinxstyleemphasis{k0}, \sphinxstyleemphasis{s0},
\sphinxstyleemphasis{k1}, \sphinxstyleemphasis{s1}, \sphinxstyleemphasis{k2}, \sphinxstyleemphasis{s2} which are passed to \sphinxcode{scipy.interpolate.splrep()}, 
one couple for each set of thermal expansions (alpha\_xx, alpha\_yy, alpha\_zz).
\sphinxstyleemphasis{k} is the order of the spline (default=3), s a smoothing condition (default=None).
If \sphinxstyleemphasis{splinesoptions==\{\}} use the default options of \sphinxcode{scipy.interpolate.splrep()}
Note: use this option with care

\end{fulllineitems}

\index{fitFvibV() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitFvib.fitFvibV}\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvibV}}{\emph{fin}, \emph{thermodata}, \emph{verbosity='low'}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(V)+F_{vib}(V,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(V)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(V,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in \sphinxstyleemphasis{fin} file.

The function fits \(E_{tot}(V)+F_{vib}(V,T)\) with a Murnaghan's EOS
at each temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (\sphinxcode{compute\_beta()}), the
constant volume heat capacity at the minimum volume at each T
(\sphinxcode{compute\_Cv()}) and the constant pression heat capacity (\sphinxcode{compute\_Cp()}).

It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the \(\chi^2\) at each T.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example5} and 
the tutorial.
\end{sphinxadmonition}

\end{fulllineitems}

\phantomsection\label{pyqha:module-pyqha.fitC}\index{pyqha.fitC (module)}
This submodule groups all functions relevant for computing elastic constants and
compliances.
\index{fS() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.fS}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fS}}{\emph{aS}, \emph{mintemp}, \emph{typeCx}}{}
An auxiliary function returning the elastic compliances 6x6 tensor at the
set of lattice parameters given in input as \sphinxstyleemphasis{mintemp}. These should be the
lattice parameters at a given temperature obtained from the free energy
minimization, so that S(T) can be obtained.
Before calling this function, the polynomial coefficients resulting from 
fitting the elastic compliances over a grid of lattice parameters, i.e. over
different geometries, must be obtained and passed as input in \sphinxstyleemphasis{aS}. 
\sphinxstyleemphasis{typeCx} defines what kind of polynomial to use for fitting (``quadratic'' or
``quartic'')

\end{fulllineitems}

\index{fitCT() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.fitCT}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCT}}{\emph{aC}, \emph{chiC}, \emph{T}, \emph{minT}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function calculates the elastic constants tensor \sphinxstyleemphasis{CT} as a function of
temperatature in the quasi-static approximation.
It takes in input \sphinxstyleemphasis{aC} and \sphinxstyleemphasis{chiC}, the fitted coefficients of the elastic 
constants as a function of \((a,b,c)\) and the corresponding \(\chi^2\).
It also takes in input an array of temperatures \sphinxstyleemphasis{T} and the corresponding
lattice parameters \sphinxstyleemphasis{minT}, i.e. \((a_{min},b_{min},c_{min})\) from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( \sphinxstyleemphasis{ibrav} ) and the type of polynomial
( \sphinxstyleemphasis{typeC} ) used for fitting the input \sphinxstyleemphasis{aC}.

The function uses the coefficients \sphinxstyleemphasis{aC} to compute the elastic tensor at
each temperature in the array \sphinxstyleemphasis{T} from the corresponding lattice parameters
\((a_{min},b_{min},c_{min})\) in \sphinxstyleemphasis{minT}.

It returns the temperature array and the a matrix \sphinxstyleemphasis{CT} with all the elastic
tensors at each T ( \sphinxstyleemphasis{CT{[}i{]}} is the elastic constants matrix for the 
temperature \sphinxstyleemphasis{T{[}i{]}})

\begin{sphinxadmonition}{warning}{Warning:}
The coefficients \sphinxstyleemphasis{aC} must be the result of fitting the elastic constants
over the same \((a,b,c)\) grid used in the quasi-harmonic calculations
corresponding to \sphinxstyleemphasis{minT} values! (See example7)
\end{sphinxadmonition}

\end{fulllineitems}

\index{fitCxx() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.fitCxx}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCxx}}{\emph{celldmsx}, \emph{Cxx}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function fits the elastic constant elements of \sphinxstyleemphasis{Cxx} as a function of the
grid of lattice parameters \((a,b,c)\). 
The real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

It returns a 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the corresponding
\(\chi^2\). If the chi squared is zero, the fitting procedure was NOT succesful

\end{fulllineitems}

\index{fitS() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.fitS}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitS}}{\emph{inputfileEtot}, \emph{inputpathCx}, \emph{ibrav}, \emph{typeSx='quadratic'}}{}
An auxiliary function for fitting the elastic compliances elements over a
grid of lattice parameters, i.e. over different geometries.

\end{fulllineitems}

\index{rearrange\_Cx() (in module pyqha.fitC)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitC.rearrange_Cx}\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{rearrange\_Cx}}{\emph{Cx}, \emph{ngeo}}{}
This function rearrange the input numpy matrix \sphinxstyleemphasis{Cx} into an equivalent matrix \sphinxstyleemphasis{Cxx}
for fitting it.
\sphinxstyleemphasis{Cx} is a \(ngeo*6*6\) matrix, each \sphinxstyleemphasis{Cx{[}i{]}} is the 6*6 \sphinxstyleemphasis{C} matrix for a given geometry ( \sphinxstyleemphasis{i} )
\sphinxstyleemphasis{Cxx} is a Lmath:\sphinxtitleref{6*6*ngeo} matrix, each \sphinxstyleemphasis{Cxx{[}i{]}{[}j{]}} is a vector with all values for different
geometries of the \sphinxstyleemphasis{Cij} elastic constant matrix element. For example, \sphinxstyleemphasis{Cxx{[}0,0{]}}
is the vector with ngeo values of the \sphinxstyleemphasis{C11} elastic constant and so on.

\end{fulllineitems}



\section{Submodules}
\label{pyqha:submodules}
Additional functions are available as submodules. Please note the documentation of these functions is still ongoing and can be incomplete or wrong.


\section{pyqha.constants module}
\label{pyqha:pyqha-constants-module}\label{pyqha:module-pyqha.constants}\index{pyqha.constants (module)}
Some useful standard constants for conversions and calculations.


\section{pyqha.eos module}
\label{pyqha:pyqha-eos-module}\label{pyqha:module-pyqha.eos}\index{pyqha.eos (module)}
This submodule groups several functions for calculating isotropic quasi-harmonic
quantities using the Murnaghan EOS.
\index{E\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.E_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{E\_Murn}}{\emph{V}, \emph{a}}{}
As {\hyperref[pyqha:pyqha.eos.E_MurnV]{\sphinxcrossref{\sphinxcode{E\_MurnV()}}}} but input parameters are given as a single list 
\sphinxstyleemphasis{a={[}a0,a1,a2,a3{]}}.

\end{fulllineitems}

\index{E\_MurnV() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.E_MurnV}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{E\_MurnV}}{\emph{V}, \emph{a0}, \emph{a1}, \emph{a2}, \emph{a3}}{}
This function implements the Murnaghan EOS (in a form which is best for fitting).
Returns the energy at the volume \sphinxstyleemphasis{V} using the coefficients \sphinxstyleemphasis{a0,a1,a2,a3} 
from the equation:
\begin{equation*}
\begin{split}E = a_0 - (a_2*a_1)/(a_3-1.0) V a_2/a_3 ( a_1/V^{a_3})/(a_3-1.0) +1.0 )\end{split}
\end{equation*}
\end{fulllineitems}

\index{H\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.H_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{H\_Murn}}{\emph{V}, \emph{a}}{}
As {\hyperref[pyqha:pyqha.eos.E_MurnV]{\sphinxcrossref{\sphinxcode{E\_MurnV()}}}} but input parameters are given as a single list 
\sphinxstyleemphasis{a={[}a0,a1,a2,a3{]}} and it returns the enthalpy not the energy from the EOS.

\end{fulllineitems}

\index{P\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.P_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{P\_Murn}}{\emph{V}, \emph{a}}{}
As {\hyperref[pyqha:pyqha.eos.E_MurnV]{\sphinxcrossref{\sphinxcode{E\_MurnV()}}}} but input parameters are given as a single list 
\sphinxstyleemphasis{a={[}a0,a1,a2,a3{]}} and it returns the pressure not the energy from the EOS.

\end{fulllineitems}

\index{calculate\_fitted\_points() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.calculate_fitted_points}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{calculate\_fitted\_points}}{\emph{V}, \emph{a}}{}
Calculates a denser mesh of E(V) points (1000) for plotting.

\end{fulllineitems}

\index{compute\_Cp() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.compute_Cp}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{compute\_Cp}}{\emph{T}, \emph{Cv}, \emph{V}, \emph{B0}, \emph{beta}}{}
This function computes the isobaric heat capacity from the equation:

\(Cp - Cv = T V beta^2 B0\)

where \sphinxstyleemphasis{Cp,Cv} are the isobaric and isocoric heat capacities respectively,
\sphinxstyleemphasis{T} is the temperature, \sphinxstyleemphasis{V} the unit cell volume, \sphinxstyleemphasis{beta} the volumetric
thermal expansion and \sphinxstyleemphasis{B0} the isothermal bulk modulus.

\end{fulllineitems}

\index{compute\_Cv() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.compute_Cv}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{compute\_Cv}}{\emph{T}, \emph{Vmin}, \emph{V}, \emph{Cvib}}{}
This function computes the isocoric heat capacity as a function of temperature.
From \sphinxstyleemphasis{Cvib}, which is a matrix with \sphinxstyleemphasis{Cvib(T,V)} as from the harmonic calculations
determines the \sphinxstyleemphasis{Cv} at each temperature by linear interpolation between the values
at the two volumes closest to Vmin(T). Vmin(T) is from the minimization of F(V,T)
and \sphinxstyleemphasis{V} is the array of volumes used for it.
Returns \sphinxstyleemphasis{Cv(T)}.

Work in progress... for now it uses all volumes in the interpolation.

\end{fulllineitems}

\index{compute\_beta() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.compute_beta}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{compute\_beta}}{\emph{minT}}{}
This function computes the volumetric thermal expansion as a numerical
derivative of the volume as a function of temperature V(T) given in the
input array \sphinxstyleemphasis{minT}. This array can obtained
from the free energy minimization which should be done before.

\end{fulllineitems}

\index{fit\_Murn() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.fit_Murn}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{fit\_Murn}}{\emph{V}, \emph{E}}{}
This is the function for fitting with the Murnaghan EOS as a function of volume only.

The input variable \sphinxstyleemphasis{V} is an 1D array of volumes, \sphinxstyleemphasis{E} are the corresponding 
energies (or other analogous quantity to be fitted with the Murnaghan EOS.

Note: volumes must be in a.u. and energies in Rydberg.

\end{fulllineitems}

\index{print\_eos\_data() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.print_eos_data}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{print\_eos\_data}}{\emph{x}, \emph{y}, \emph{a}, \emph{chi}, \emph{ylabel='Etot'}}{}
Print the data and the fitted results using the Murnaghan EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be ``Etot'', 
``Fvib'', etc.

\end{fulllineitems}

\index{write\_Etotfitted() (in module pyqha.eos)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.eos.write_Etotfitted}\pysiglinewithargsret{\sphinxcode{pyqha.eos.}\sphinxbfcode{write\_Etotfitted}}{\emph{filename}, \emph{x}, \emph{y}, \emph{a}, \emph{chi}, \emph{ylabel='E'}}{}
Write in filename the data and the fitted results using the Murnaghan EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be ``Etot'', 
``Fvib'', etc.

\end{fulllineitems}



\section{pyqha.fitC module}
\label{pyqha:pyqha-fitc-module}\label{pyqha:module-pyqha.fitC}\index{pyqha.fitC (module)}
This submodule groups all functions relevant for computing elastic constants and
compliances.
\index{fS() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fS}}{\emph{aS}, \emph{mintemp}, \emph{typeCx}}{}
An auxiliary function returning the elastic compliances 6x6 tensor at the
set of lattice parameters given in input as \sphinxstyleemphasis{mintemp}. These should be the
lattice parameters at a given temperature obtained from the free energy
minimization, so that S(T) can be obtained.
Before calling this function, the polynomial coefficients resulting from 
fitting the elastic compliances over a grid of lattice parameters, i.e. over
different geometries, must be obtained and passed as input in \sphinxstyleemphasis{aS}. 
\sphinxstyleemphasis{typeCx} defines what kind of polynomial to use for fitting (``quadratic'' or
``quartic'')

\end{fulllineitems}

\index{fitCT() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCT}}{\emph{aC}, \emph{chiC}, \emph{T}, \emph{minT}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function calculates the elastic constants tensor \sphinxstyleemphasis{CT} as a function of
temperatature in the quasi-static approximation.
It takes in input \sphinxstyleemphasis{aC} and \sphinxstyleemphasis{chiC}, the fitted coefficients of the elastic 
constants as a function of \((a,b,c)\) and the corresponding \(\chi^2\).
It also takes in input an array of temperatures \sphinxstyleemphasis{T} and the corresponding
lattice parameters \sphinxstyleemphasis{minT}, i.e. \((a_{min},b_{min},c_{min})\) from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( \sphinxstyleemphasis{ibrav} ) and the type of polynomial
( \sphinxstyleemphasis{typeC} ) used for fitting the input \sphinxstyleemphasis{aC}.

The function uses the coefficients \sphinxstyleemphasis{aC} to compute the elastic tensor at
each temperature in the array \sphinxstyleemphasis{T} from the corresponding lattice parameters
\((a_{min},b_{min},c_{min})\) in \sphinxstyleemphasis{minT}.

It returns the temperature array and the a matrix \sphinxstyleemphasis{CT} with all the elastic
tensors at each T ( \sphinxstyleemphasis{CT{[}i{]}} is the elastic constants matrix for the 
temperature \sphinxstyleemphasis{T{[}i{]}})

\begin{sphinxadmonition}{warning}{Warning:}
The coefficients \sphinxstyleemphasis{aC} must be the result of fitting the elastic constants
over the same \((a,b,c)\) grid used in the quasi-harmonic calculations
corresponding to \sphinxstyleemphasis{minT} values! (See example7)
\end{sphinxadmonition}

\end{fulllineitems}

\index{fitCxx() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitCxx}}{\emph{celldmsx}, \emph{Cxx}, \emph{ibrav=4}, \emph{typeC='quadratic'}}{}
This function fits the elastic constant elements of \sphinxstyleemphasis{Cxx} as a function of the
grid of lattice parameters \((a,b,c)\). 
The real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

It returns a 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element \sphinxstyleemphasis{{[}i,j{]}} being the corresponding
\(\chi^2\). If the chi squared is zero, the fitting procedure was NOT succesful

\end{fulllineitems}

\index{fitS() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{fitS}}{\emph{inputfileEtot}, \emph{inputpathCx}, \emph{ibrav}, \emph{typeSx='quadratic'}}{}
An auxiliary function for fitting the elastic compliances elements over a
grid of lattice parameters, i.e. over different geometries.

\end{fulllineitems}

\index{rearrange\_Cx() (in module pyqha.fitC)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitC.}\sphinxbfcode{rearrange\_Cx}}{\emph{Cx}, \emph{ngeo}}{}
This function rearrange the input numpy matrix \sphinxstyleemphasis{Cx} into an equivalent matrix \sphinxstyleemphasis{Cxx}
for fitting it.
\sphinxstyleemphasis{Cx} is a \(ngeo*6*6\) matrix, each \sphinxstyleemphasis{Cx{[}i{]}} is the 6*6 \sphinxstyleemphasis{C} matrix for a given geometry ( \sphinxstyleemphasis{i} )
\sphinxstyleemphasis{Cxx} is a Lmath:\sphinxtitleref{6*6*ngeo} matrix, each \sphinxstyleemphasis{Cxx{[}i{]}{[}j{]}} is a vector with all values for different
geometries of the \sphinxstyleemphasis{Cij} elastic constant matrix element. For example, \sphinxstyleemphasis{Cxx{[}0,0{]}}
is the vector with ngeo values of the \sphinxstyleemphasis{C11} elastic constant and so on.

\end{fulllineitems}



\section{pyqha.fitEtot module}
\label{pyqha:pyqha-fitetot-module}\label{pyqha:module-pyqha.fitEtot}\index{pyqha.fitEtot (module)}\index{fitEtot() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtot}}{\emph{fin}, \emph{out=True}, \emph{ibrav=4}, \emph{fittype='quadratic'}, \emph{guess=None}, \emph{method='BFGS'}, \emph{minoptions=\{\}}}{}
This function reads the file \sphinxstyleemphasis{fin} containing the energies as a function
of the lattice parameters \(E(a,b,c)\) and fits them with a quartic (\sphinxstyleemphasis{fittype=''quartic''}) or 
quadratic (\sphinxstyleemphasis{fittype=''quadratic''}) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redirected to \sphinxstyleemphasis{stdout})
if \sphinxstyleemphasis{out=True}.
It returns the lattice parameters and energies as in the input file \sphinxstyleemphasis{fin},
the fitted coefficients of the polynomial, the corresponding \(\chi^2\),
the lattice parameters at the minimum and the minimun energy.

Note: for cubic systems use fitEtotV instead.

Advanced input parameters:

\sphinxstyleemphasis{guess}, an initial guess for the minimization. It is a 6 elements list 
{[}a,b,c,0,0,0{]}.

\sphinxstyleemphasis{method}, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details.

\sphinxstyleemphasis{minoptions}, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.

\end{fulllineitems}

\index{fitEtotV() (in module pyqha.fitEtot)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitEtot.}\sphinxbfcode{fitEtotV}}{\emph{fin}, \emph{fout=None}}{}
This function reads \(E(V)\) data from the input file \sphinxstyleemphasis{fin}, fits them with a Murnaghan EOS,
prints the results on the \sphinxstyleemphasis{stdout} and write them in the file ``fout''.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding \(\chi^2\).

\end{fulllineitems}



\section{pyqha.fitFvib module}
\label{pyqha:pyqha-fitfvib-module}\label{pyqha:module-pyqha.fitFvib}\index{pyqha.fitFvib (module)}\index{fitFvib() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvib}}{\emph{fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess={[}0.0, 0.0, 0.0, 0.0, 0.0, 0.0{]}, method='BFGS', minoptions=\{\}, splinesoptions=None}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(a,b,c)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(a,b,c,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in \sphinxstyleemphasis{fin} file. The 
real number of lattice parameters depends on \sphinxstyleemphasis{ibrav}, for example for 
hexagonal systems (\sphinxstyleemphasis{ibrav=4}) you have only (a,c) values. \sphinxstyleemphasis{ibrav} identifies
the Bravais lattice, as in Quantum Espresso.

The function fits \(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) with a quadratic
or quartic polynomial (as defined by \sphinxstyleemphasis{typeEtot} and \sphinxstyleemphasis{typeFvib} ) at each
temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting \(E_{tot}(a,b,c)\)
and \(F_{vib}(a,b,c)\). Then it computes the minimun energy \(E_{tot}+F_{vib}\)
and the corresponding lattice parameters \((a_{min},b_{min},c_{min})\) 
at each temperature by miniimizing the energy.

It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (\sphinxcode{compute\_alpha()}).

It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the \(\chi^2\) for \(E_{tot}(a,b,c)\) 
only (at T=0 K) and the fitted coefficients and the \(\chi^2\) for 
\(E_{tot}(a,b,c)+F_{vib}(a,b,c,T)\) at each temperature.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example6} and 
the tutorial.
\end{sphinxadmonition}

Advanced input parameters:

\sphinxstyleemphasis{guess}, an initial guess for the minimization. It is a 6 elements list 
{[}a,b,c,0,0,0{]}.

\sphinxstyleemphasis{method}, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details. Note that the 
methods which usually gives better results for quasi-harmonic calculations
are the ``BFGS'' or Newton-CG''. Default is ``BFGS''.

\sphinxstyleemphasis{minoptions}, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.
Note the the options are different for different methods.

\sphinxstyleemphasis{splinesoptions}, determines whether to use or not splines to reduce the noise
on numerical derivatives (thermal expansions). If \sphinxstyleemphasis{splinesoptions*==None, use 
finete differences for derivatives, else use splines as implemented in
scipy.interpolate (see documentation). In the latter case, *splinesoptions}
must be a dictionary. This dictionary must contains the keywords \sphinxstyleemphasis{k0}, \sphinxstyleemphasis{s0},
\sphinxstyleemphasis{k1}, \sphinxstyleemphasis{s1}, \sphinxstyleemphasis{k2}, \sphinxstyleemphasis{s2} which are passed to \sphinxcode{scipy.interpolate.splrep()}, 
one couple for each set of thermal expansions (alpha\_xx, alpha\_yy, alpha\_zz).
\sphinxstyleemphasis{k} is the order of the spline (default=3), s a smoothing condition (default=None).
If \sphinxstyleemphasis{splinesoptions==\{\}} use the default options of \sphinxcode{scipy.interpolate.splrep()}
Note: use this option with care

\end{fulllineitems}

\index{fitFvibV() (in module pyqha.fitFvib)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.fitFvib.}\sphinxbfcode{fitFvibV}}{\emph{fin}, \emph{thermodata}, \emph{verbosity='low'}}{}
This function computes quasi-harmonic quantities from the 
\(E_{tot}(V)+F_{vib}(V,T)\) as a function of temperature with Murnaghan's
EOS. \(E_{tot}(V)\) is read from the \sphinxstyleemphasis{fin} file. \(F_{vib}(V,T)\)
are given in \sphinxstyleemphasis{thermodata} which is a list containing the number of temperatures
( \sphinxstyleemphasis{nT} ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in \sphinxstyleemphasis{fin} file.

The function fits \(E_{tot}(V)+F_{vib}(V,T)\) with a Murnaghan's EOS
at each temperature in \sphinxstyleemphasis{thermodata} and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (\sphinxcode{compute\_beta()}), the
constant volume heat capacity at the minimum volume at each T
(\sphinxcode{compute\_Cv()}) and the constant pression heat capacity (\sphinxcode{compute\_Cp()}).

It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the \(\chi^2\) at each T.

\begin{sphinxadmonition}{warning}{Warning:}
The quantities in \sphinxstyleemphasis{thermodata} are usually obtained from \sphinxcode{compute\_thermo\_geo()}
or from \sphinxcode{read\_thermo()} and \sphinxcode{rearrange\_thermo()}. It is
important that the order in the total energy file \sphinxstyleemphasis{fin} and the order of
the thermodynamic data in \sphinxstyleemphasis{thermodata} is the same!  See also \sphinxstyleemphasis{example5} and 
the tutorial.
\end{sphinxadmonition}

\end{fulllineitems}



\section{pyqha.alphagruneisenp module}
\label{pyqha:module-pyqha.alphagruneisenp}\label{pyqha:pyqha-alphagruneisenp-module}\index{pyqha.alphagruneisenp (module)}\index{c\_qv() (in module pyqha.alphagruneisenp)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.alphagruneisenp.c_qv}\pysiglinewithargsret{\sphinxcode{pyqha.alphagruneisenp.}\sphinxbfcode{c\_qv}}{\emph{T}, \emph{omega}}{}
This function calculates the mode contribution to the heat capacity at a given T
and omega. A similar (faster) function should be available as C extension.

\end{fulllineitems}

\index{c\_qv2() (in module pyqha.alphagruneisenp)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.alphagruneisenp.c_qv2}\pysiglinewithargsret{\sphinxcode{pyqha.alphagruneisenp.}\sphinxbfcode{c\_qv2}}{\emph{T}, \emph{omega}}{}
\end{fulllineitems}

\index{c\_qv\_python() (in module pyqha.alphagruneisenp)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.alphagruneisenp.c_qv_python}\pysiglinewithargsret{\sphinxcode{pyqha.alphagruneisenp.}\sphinxbfcode{c\_qv\_python}}{\emph{T}, \emph{omega}}{}
This function calculates the mode contribution to the heat capacity at a given T
and omega. A similar (faster) function should be available as C extension.

\end{fulllineitems}

\index{compute\_alpha\_grun() (in module pyqha.alphagruneisenp)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.alphagruneisenp.compute_alpha_grun}\pysiglinewithargsret{\sphinxcode{pyqha.alphagruneisenp.}\sphinxbfcode{compute\_alpha\_grun}}{\emph{T}, \emph{V}, \emph{S}, \emph{weights}, \emph{freq}, \emph{grun}, \emph{ibrav=4}}{}
This function computes the thermal expansions alpha using the Gruneisein 
parameters at a given temperature \sphinxstyleemphasis{T}. \sphinxstyleemphasis{V} is the unit cell volume, \sphinxstyleemphasis{S} is
the elastic compliances matrix in Voigt notation, \sphinxstyleemphasis{freq} and \sphinxstyleemphasis{weights}  are
the phonon frequencies in a grid of q-point and their corresponding weights.
\sphinxstyleemphasis{grun} are the Gruneisen parameters. \sphinxstyleemphasis{ibrav} identifies the Bravais lattice.

It implements the following equation:

:math:{}`{}`

more comments to be added

First with min0, freq and grun T-independent

More ibrav types to be implemented

\end{fulllineitems}

\index{compute\_alpha\_gruneisein() (in module pyqha.alphagruneisenp)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.alphagruneisenp.compute_alpha_gruneisein}\pysiglinewithargsret{\sphinxcode{pyqha.alphagruneisenp.}\sphinxbfcode{compute\_alpha\_gruneisein}}{\emph{TT}, \emph{ibrav}, \emph{celldmsx}, \emph{min0=None}, \emph{S=None}, \emph{weights=None}, \emph{freq=None}, \emph{grun=None}, \emph{minT=None}, \emph{afreq=None}, \emph{fittypefreq=None}, \emph{aS=None}, \emph{fittypeS=None}, \emph{nproc=1}}{}
This function computes the thermal expansions at different temperatures from
the Gruneisen parameters and other parameters.

\sphinxstyleemphasis{TT} is a numpy array of temperatures for which the thermal expansions are
computed. \sphinxstyleemphasis{ibrav} identifies the Bravais lattice. \sphinxstyleemphasis{celldmsx} contains the lattice
parameters of the computed grid \((a,b,c)\) as read with \sphinxcode{read\_Etot()}.
Different calculation options are possible, according to the optional 
input parameters given in input:

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\sphinxstylethead{\relax 
Input parameters
\unskip}\relax &\sphinxstylethead{\relax 
Meaning
\unskip}\relax \\
\hline
\sphinxstyleemphasis{min0,S,weights,freq,grun}
&
Use temperarature-independent (0 K) volume, elastic compliances,
average frequencies and Gruneisen parameters. The volume is obtained
from \sphinxstyleemphasis{min0}, the lattice parameters at the minimun 0 K energy. \sphinxstyleemphasis{S} is
the elastic compliances tensor at 0 K calculated at \sphinxstyleemphasis{min0}. \sphinxstyleemphasis{weights}
,*freq*,*grun* are the weights, phonon frequencies and Gruneisen
parameters at 0 K calculated at \sphinxstyleemphasis{min0}.
\\
\hline
\sphinxstyleemphasis{S,weights,minT,afreq,fittypefreq}
&
Use temperarature-independent (0 K) elastic compliances but
temperature-dependent volume, average frequencies and Gruneisen
parameters. The volume is obtained from \sphinxstyleemphasis{minT}, a numpy array with
the lattice parameters at the minimun free energy at each temperature
. \sphinxstyleemphasis{S} is the elastic compliances tensor at 0 K calculated at \sphinxstyleemphasis{min0}.
\sphinxstyleemphasis{weights} are the weights of the phonon frequencies.  \sphinxstyleemphasis{afreq},
\sphinxstyleemphasis{fittypefreq} are the coefficients of the fitted polynomials for the
phonon frequencies and the type of polynomial. They are used here to
compute the average frequencies and Gruneisen parameters at each
temperature.
\\
\hline
\sphinxstyleemphasis{weights,afreq,fittypefreq,aS,fittypeS}
&
Use temperarature-dependent (0 K) volume, elastic compliances,
average frequencies and Gruneisen parameters. The volume is obtained
from \sphinxstyleemphasis{minT}, a numpy array with the lattice parameters at the minimun
free energy at each temperature. \sphinxstyleemphasis{weights} are the weights of the
phonon frequencies. \sphinxstyleemphasis{afreq},
\sphinxstyleemphasis{fittypefreq} are the coefficients of the fitted polynomials for the
phonon frequencies and the type of polynomial. They are used here to
the average frequencies and Gruneisen parameters at each temperature.
\sphinxstyleemphasis{aS,fittypeS} are the coefficients of the fitted polynomials for the
elastic compliances and the polynomial type. They are used here to
compute the elastic compliances at each temperature as in the quasi-
static approximation.
\\
\hline\end{tabulary}


By default, all the input parameters in the above table are ==None and if nothing
is given in input the function will return None without computing anything.

\sphinxstyleemphasis{nproc} is the number of processes to be run in parallel.

\end{fulllineitems}

\index{compute\_alpha\_gruneisen\_loopparallel() (in module pyqha.alphagruneisenp)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.alphagruneisenp.compute_alpha_gruneisen_loopparallel}\pysiglinewithargsret{\sphinxcode{pyqha.alphagruneisenp.}\sphinxbfcode{compute\_alpha\_gruneisen\_loopparallel}}{\emph{it}}{}
This function implements the parallel loop where the alpha are computed. It  
essentially calls the compute\_alpha\_grun function with the proper parameters
according to the selected option. ``it'' is a list with all function parameters
for the call in pool.map

it{[}0{]}== 0 -\textgreater{} use V, S, average frequencies and gruneisen parameters at 0 K 
it{[}0{]}== 1 -\textgreater{} use S at 0 K, calculate V, average frequencies and gruneisen parameters at each T 
it{[}0{]}== 2 -\textgreater{}  calculate S, V, average frequencies and gruneisen parameters at each T

\end{fulllineitems}

\index{join() (in module pyqha.alphagruneisenp)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.alphagruneisenp.join}\pysiglinewithargsret{\sphinxcode{pyqha.alphagruneisenp.}\sphinxbfcode{join}}{\emph{partials}}{}
This function simply puts together the different temperature ranges where alpha
was calculated in parallel into a single numpy array

\end{fulllineitems}



\section{pyqha.fitfreqgrun module}
\label{pyqha:pyqha-fitfreqgrun-module}\label{pyqha:module-pyqha.fitfreqgrun}\index{pyqha.fitfreqgrun (module)}\index{fitfreq() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.fitfreq}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{fitfreq}}{\emph{celldmsx}, \emph{min0}, \emph{filefreq}, \emph{ibrav=4}, \emph{typefreq='quadratic'}, \emph{compute\_grun=False}}{}
An auxiliary function for fitting the frequencies.

\sphinxstyleemphasis{celldmsx} is the matrix of lattice parameters \((a,b,c)\) where the total
energies where computed. \sphinxstyleemphasis{min0} is the a set of \((a,b,c)\). \sphinxstyleemphasis{filefreq}
defines the input files (\sphinxstyleemphasis{filefreq1}, \sphinxstyleemphasis{filefreq2}, etc.) containing the 
frequencies for different geometries. The number of geometries is determined
from the size of \sphinxstyleemphasis{celldmsx}. \sphinxstyleemphasis{ibrav} is the usual Bravais lattice. 
\sphinxstyleemphasis{typefreq} can be ``quadratic'' (default) or ``quartic'', i.e. the kind of 
polynomial to be used for fitting. \sphinxstyleemphasis{compute\_grun} defines if the Gruneisen
parameters must be calculated (True) or not (False, default).

It returns a matrix of \(nq*modes\) frequencies obtained for the fitted 
polynomial coefficients (quadratic or quartic) at the 
minimun point \sphinxstyleemphasis{min0}. It also returns the weigths of each q-point where the 
frequencies are available.

\end{fulllineitems}

\index{fitfreqxx() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.fitfreqxx}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{fitfreqxx}}{\emph{celldmsx}, \emph{freqxx}, \emph{ibrav}, \emph{out}, \emph{typefreq}}{}
This function fits the frequencies in freqxx as a function of the
grid of lattice parameters \((a,b,c)\).

It returns a \(nq*modes\) matrix, whose element {[}i,j{]} is the set of coefficients of the 
polynomial fit and another \(nq*modes\) matrix, whose element {[}i,j{]} is the corresponding
\(\chi^2\). If the \(\chi^2=0\), the fitting procedure was NOT succesful

\end{fulllineitems}

\index{freqmin() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.freqmin}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{freqmin}}{\emph{afreq}, \emph{min0}, \emph{nq}, \emph{modes}, \emph{ibrav}, \emph{typefreq}}{}
This function calculates the frequencies from the fitted polynomials coeffients (one
for each q point and mode) at the minimun point \sphinxstyleemphasis{min0} given in input. 
\sphinxstyleemphasis{afreq} is a \(nq*modes\) numpy matrix containing the fitted polynomial coefficients.
It can be obtained from {\hyperref[pyqha:pyqha.fitfreqgrun.fitfreqxx]{\sphinxcrossref{\sphinxcode{fitfreqxx()}}}}.

It returns a \(nq*modes\) matrix, each element {[}i,j{]} being the fitted frequency

\end{fulllineitems}

\index{freqmingrun() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.freqmingrun}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{freqmingrun}}{\emph{afreq}, \emph{min0}, \emph{nq}, \emph{modes}, \emph{ibrav}, \emph{typefreq}}{}
This function calculates the frequencies and the Gruneisen parameters
from the fitted polynomials coeffients (one
for each q point and mode) at the minimun point \sphinxstyleemphasis{min0} given in input. 
\sphinxstyleemphasis{afreq} is a \(nq*modes\) numpy matrix containing the fitted polynomial coefficients.
It can be obtained from {\hyperref[pyqha:pyqha.fitfreqgrun.fitfreqxx]{\sphinxcrossref{\sphinxcode{fitfreqxx()}}}}.

It returns a \(nq*modes\) matrix, each element {[}i,j{]} being the fitted frequency 
In addition, it returns a \(nq*modes*6\) with the Gruneisein parameters.
Each element {[}i,j,k{]} is the the Gruneisein parameter at \sphinxstyleemphasis{nq=i}, \sphinxstyleemphasis{mode=j} and direction
\sphinxstyleemphasis{k} (for example, in hex systems \sphinxstyleemphasis{k=0} is \sphinxstyleemphasis{a} direction, \sphinxstyleemphasis{k=2} is \sphinxstyleemphasis{c} direction, others are zero)

Note that the Gruneisein parameters are not multiplied for the lattice parameters.

\end{fulllineitems}

\index{rearrange\_freqx() (in module pyqha.fitfreqgrun)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitfreqgrun.rearrange_freqx}\pysiglinewithargsret{\sphinxcode{pyqha.fitfreqgrun.}\sphinxbfcode{rearrange\_freqx}}{\emph{freqx}}{}
This function rearranges the input numpy matrix \sphinxstyleemphasis{freqx} into an equivalent 
matrix \sphinxstyleemphasis{freqxx} for the subsequent fitting.
\sphinxstyleemphasis{freqx} is a \(ngeo*nq*modes\) matrix, each \sphinxstyleemphasis{freqx{[}i{]}} is the \(nq*modes\)
frequency matrix for a given geometry \sphinxstyleemphasis{i}.
freqxx is a \(nq*modes*ngeo\) matrix, each \sphinxstyleemphasis{freqxx{[}i,j{]}} is a vector with
all values for different geometries of the frequencies at point \sphinxstyleemphasis{q=i} and \sphinxstyleemphasis{mode=j}.
For example, \sphinxstyleemphasis{freqxx{[}0,0{]}} is the vector with ngeo values of the frequencies
at the first q-point and first mode so on.

\end{fulllineitems}



\section{pyqha.fitutils module}
\label{pyqha:pyqha-fitutils-module}\label{pyqha:module-pyqha.fitutils}\index{pyqha.fitutils (module)}\index{expand\_quadratic\_to\_quartic() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.expand_quadratic_to_quartic}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{expand\_quadratic\_to\_quartic}}{\emph{a}}{}
This function gets a vector of coefficients from a quadratic fit and turns it
into a vector of coeffients as from a quartic fit (extra coeffients are set to zero).

\end{fulllineitems}

\index{fit\_anis() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.fit_anis}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{fit\_anis}}{\emph{celldmsx}, \emph{Ex}, \emph{ibrav=4}, \emph{out=False}, \emph{type='quadratic'}, \emph{ylabel='Etot'}}{}
An auxiliary function for handling fitting in the anisotropic case

\end{fulllineitems}

\index{fit\_quadratic() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.fit_quadratic}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{fit\_quadratic}}{\emph{x}, \emph{y}, \emph{ibrav=4}, \emph{out=False}, \emph{ylabel='E'}}{}
This function fits the \sphinxstyleemphasis{y} values (energies) with a quadratic polynomial of
up to 3 variables \(x1,x2,x3\) corresponding to the lattice parameters
\((a,b,c)\). In the most general form the polynomial is:

\(a1 + a2 x1 + a3 x1^2 + a4  x2 + a5  x2^2 + a6 x1*x2 +    
+ a7  x3 + a8  x3^2 + a9  x1*x3 + a10 x2*x3\)

The input variable \sphinxstyleemphasis{x} is a matrix \(ngeo*6\), where:

\sphinxstyleemphasis{x{[}:,0{]}} is the set of a values

\sphinxstyleemphasis{x{[}:,1{]}} is the set of b values

\sphinxstyleemphasis{x{[}:,2{]}} is the set of c values

and x{[}:,3{]}, x{[}:,4{]}, x{[}:,5{]} are all zeros. 
\sphinxstyleemphasis{ibrav} defines the Bravais lattice, \sphinxstyleemphasis{out} set the output verbosity (\sphinxstyleemphasis{out=True} 
verbose output), \sphinxstyleemphasis{ylabel} set a label for the quantity in \sphinxstyleemphasis{y} (can be \(E_{tot}\)
or \(E_{tot}+F_{vib}\) for example).

Note 1: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

Note 2: the polynomial fit is done using \sphinxcode{numpy.linalg.lstsq()}. 
Please refer to numpy documentation for further details.

\end{fulllineitems}

\index{fit\_quartic() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.fit_quartic}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{fit\_quartic}}{\emph{x}, \emph{y}, \emph{ibrav=4}, \emph{out=False}, \emph{ylabel='E'}}{}
This function fits the \sphinxstyleemphasis{y} values (energies) with a quartic polynomial of
up to 3 variables \(x1,x2,x3\) corresponding to the lattice parameters
\((a,b,c)\). In the most general form the polynomial is:

\(a1 + a2 x1 + a3 x1^2 + a4  x1^3 + a5  x1^4 + a6 x2 + a7  x2^2 + 
a8  x2^3 + a9  x2^4 + a10 x1*x2 + a11 x1*x2^2 + a12 x1*x2^3 +
a13 x1^2*x2 + a14 x1^2*x2^2 + a15 x1^3*x2 + a16 x3 + a17 x3^2 + a18 x3^3 +
a19 x3^4 + a20 x1*x3 + a21 x1*x3^2 + a22 x1*x3^3 + a23 x1^2*x3 + a24 x1^2*x3^2 +
a25 x1^3*x3 + a26 x2*x3 + a27 x2*x3^2 + a28 x2*x3^3 + a29 x2^2*x3 +
a30 x2^2*x3^2 + a31 x2^3*x3 + a32 x1*x2*x3 + a33 x1^2*x2*x3 +
a34 x1*x2^2*x3 + a35 x1*x2*x3^2\)

The input variable \sphinxstyleemphasis{x} is a matrix \(ngeo*6\), where:

\sphinxstyleemphasis{x{[}:,0{]}} is the set of a values

\sphinxstyleemphasis{x{[}:,1{]}} is the set of b values

\sphinxstyleemphasis{x{[}:,2{]}} is the set of c values

and x{[}:,3{]}, x{[}:,4{]}, x{[}:,5{]} are all zeros. 
\sphinxstyleemphasis{ibrav} defines the Bravais lattice, \sphinxstyleemphasis{out} set the output verbosity (\sphinxstyleemphasis{out=True} 
verbose output), \sphinxstyleemphasis{ylabel} set a label for the quantity in \sphinxstyleemphasis{y} (can be \(E_{tot}\)
or \(E_{tot}+F_{vib}\) for example).

Note 1: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

Note 2: the polynomial fit is done using \sphinxcode{numpy.linalg.lstsq()}. 
Please refer to numpy documentation for further details.

\end{fulllineitems}

\index{print\_data() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.print_data}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{print\_data}}{\emph{x}, \emph{y}, \emph{results}, \emph{A}, \emph{ibrav}, \emph{ylabel='E'}}{}
This function prints the data and the fitted results 
ylabel can be ``E'', ``Fvib'', ``Cxx'', etc. so that can be used for different
fitted quantities

\end{fulllineitems}

\index{print\_polynomial() (in module pyqha.fitutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.fitutils.print_polynomial}\pysiglinewithargsret{\sphinxcode{pyqha.fitutils.}\sphinxbfcode{print\_polynomial}}{\emph{a}, \emph{ibrav=4}}{}
This function prints the fitted polynomial, either quartic or quadratic

\end{fulllineitems}



\section{pyqha.minutils module}
\label{pyqha:module-pyqha.minutils}\label{pyqha:pyqha-minutils-module}\index{pyqha.minutils (module)}\index{calculate\_fitted\_points\_anis() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.calculate_fitted_points_anis}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{calculate\_fitted\_points\_anis}}{\emph{celldmsx}, \emph{nmesh}, \emph{fittype='quadratic'}, \emph{ibrav=4}, \emph{a=None}}{}
Calculates a denser mesh of Efitted(celldmsx) points for plotting. nmesh = (nx,ny,nz)
gives the dimensions of the mesh.

\end{fulllineitems}

\index{contract\_vector() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.contract_vector}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{contract\_vector}}{\emph{x}, \emph{ibrav=4}}{}
Utility function: contract a vector \sphinxstyleemphasis{x}, len(x)=6, into a x-dim vector (x\textless{}6) 
according to the Bravais lattice type as in \sphinxstyleemphasis{ibrav}

Note: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

\end{fulllineitems}

\index{expand\_vector() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.expand_vector}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{expand\_vector}}{\emph{x}, \emph{ibrav=4}}{}
Utility function: expands a vector \sphinxstyleemphasis{x}, len(x)\textless{}6, into a 6-dim vector according
to the Bravais lattice type as in \sphinxstyleemphasis{ibrav}

Note: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

\end{fulllineitems}

\index{find\_min() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.find_min}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{find\_min}}{\emph{a}, \emph{ibrav}, \emph{type}, \emph{guess=None}, \emph{method='BFGS'}, \emph{minoptions=\{\}}}{}
An auxiliary function for handling the minimum search.

\end{fulllineitems}

\index{find\_min\_quadratic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.find_min_quadratic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{find\_min\_quadratic}}{\emph{a}, \emph{ibrav}, \emph{guess}, \emph{method}, \emph{minoptions}}{}
This is the function for finding the minimum of the quadratic polynomial

\end{fulllineitems}

\index{find\_min\_quartic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.find_min_quartic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{find\_min\_quartic}}{\emph{a}, \emph{ibrav}, \emph{guess}, \emph{method}, \emph{minoptions}}{}
This is the function for finding the minimum of the quartic polynomial

\end{fulllineitems}

\index{fquadratic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquadratic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquadratic}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
This function implements the quadratic polynomials for fitting and miminizing
according to the Bravais lattice type as in \sphinxstyleemphasis{ibrav}.
\sphinxstyleemphasis{x} is the vector with input coordinates \((a,b,c,alpha,beta,gamma)\),
\sphinxstyleemphasis{a} is the vector
with the polynomial coeffients. The dimension of \sphinxstyleemphasis{a} depends on
\sphinxstyleemphasis{ibrav}. \sphinxstyleemphasis{x} has always 6 elements with zeros for those not used according to
\sphinxstyleemphasis{ibrav}.

Note: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

\end{fulllineitems}

\index{fquadratic\_der() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquadratic_der}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquadratic\_der}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
This function implements the first derivatives of the quadratic polynomials 
for fitting and miminizing according to the Bravais lattice type as in \sphinxstyleemphasis{ibrav}. 
\sphinxstyleemphasis{x} is the vector with input coordinates \((a,b,c,alpha,beta,gamma)\),
\sphinxstyleemphasis{a} is the vector
with the polynomial coeffients. The dimension of \sphinxstyleemphasis{a} depends on
\sphinxstyleemphasis{ibrav}. \sphinxstyleemphasis{x} has always 6 elements with zeros for those not used according to
\sphinxstyleemphasis{ibrav}.
The derivatives are returned as a numpy vector of 6 elements, each element 
being a derivative with respect to \((a,b,c,alpha,beta,gamma)\).

Note: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

\end{fulllineitems}

\index{fquartic() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquartic}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquartic}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
This function implements the quartic polynomials for fitting and miminizing
according to the Bravais lattice type as in \sphinxstyleemphasis{ibrav}.
\sphinxstyleemphasis{x} is the vector with input coordinates \((a,b,c,alpha,beta,gamma)\),
\sphinxstyleemphasis{a} is the vector
with the polynomial coeffients. The dimension of \sphinxstyleemphasis{a} depends on
\sphinxstyleemphasis{ibrav}. \sphinxstyleemphasis{x} has always 6 elements with zeros for those not used according to
\sphinxstyleemphasis{ibrav}.

Note: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

\end{fulllineitems}

\index{fquartic\_der() (in module pyqha.minutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.minutils.fquartic_der}\pysiglinewithargsret{\sphinxcode{pyqha.minutils.}\sphinxbfcode{fquartic\_der}}{\emph{x}, \emph{a}, \emph{ibrav=4}}{}
This function implements the first derivatives of the quadratic polynomials 
for fitting and miminizing according to the Bravais lattice type as in \sphinxstyleemphasis{ibrav}. 
The derivatives are returned as a numpy vector of 6 elements, each element 
being a derivative with respect to \((a,b,c,alpha,beta,gamma)\).
\sphinxstyleemphasis{x} is the vector with input coordinates \((a,b,c,alpha,beta,gamma)\),
\sphinxstyleemphasis{a} is the vector
with the polynomial coeffients. The dimension of \sphinxstyleemphasis{a} depends on
\sphinxstyleemphasis{ibrav}. \sphinxstyleemphasis{x} has always 6 elements with zeros for those not used according to
\sphinxstyleemphasis{ibrav}.

Note: implemented for cubic (\sphinxstyleemphasis{ibrav=1,2,3}), hexagonal (\sphinxstyleemphasis{ibrav=4}), 
tetragonal (\sphinxstyleemphasis{ibrav=6,7}), orthorombic (\sphinxstyleemphasis{ibrav=8,9,10,11})

\end{fulllineitems}



\section{pyqha.plotutils module}
\label{pyqha:module-pyqha.plotutils}\label{pyqha:pyqha-plotutils-module}\index{pyqha.plotutils (module)}\index{multiple\_plot\_xy() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.multiple_plot_xy}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{multiple\_plot\_xy}}{\emph{x}, \emph{y}, \emph{xlabel='`}, \emph{ylabel='`}, \emph{labels='`}}{}
This function generates a simple xy plot with matplotlib overlapping several
lines as in the matrix y. y second index refers to a line in the plot, the first 
index is for the array to be plotted.

\end{fulllineitems}

\index{plot\_EV() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.plot_EV}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{plot\_EV}}{\emph{V}, \emph{E}, \emph{a=None}, \emph{labely='Etot'}}{}
This function plots with matplotlib E(V) data and if a is given it also plot
the fitted results

\end{fulllineitems}

\index{plot\_Etot() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.plot_Etot}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{plot\_Etot}}{\emph{celldmsx}, \emph{Ex}, \emph{n}, \emph{nmesh=(50}, \emph{50}, \emph{50)}, \emph{fittype='quadratic'}, \emph{ibrav=4}, \emph{a=None}}{}
This function makes a 3D plot with matplotlib Ex(celldmsx) data and if a is given it also plot
the fitted results. The plot type depends on ibrav.

\end{fulllineitems}

\index{plot\_Etot\_contour() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.plot_Etot_contour}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{plot\_Etot\_contour}}{\emph{celldmsx}, \emph{nmesh=(50}, \emph{50}, \emph{50)}, \emph{fittype='quadratic'}, \emph{ibrav=4}, \emph{a=None}}{}
This function makes a countour plot with matplotlib of Ex(celldmsx) fitted results. 
The plot type depends on ibrav.

\end{fulllineitems}

\index{simple\_plot\_xy() (in module pyqha.plotutils)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.plotutils.simple_plot_xy}\pysiglinewithargsret{\sphinxcode{pyqha.plotutils.}\sphinxbfcode{simple\_plot\_xy}}{\emph{x}, \emph{y}, \emph{xlabel='`}, \emph{ylabel='`}}{}
This function generates a simple xy plot with matplotlib.

\end{fulllineitems}



\section{pyqha.properties\_anis module}
\label{pyqha:module-pyqha.properties_anis}\label{pyqha:pyqha-properties-anis-module}\index{pyqha.properties\_anis (module)}\index{compute\_Ceps() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_Ceps}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_Ceps}}{\emph{min0}, \emph{celldmsx}, \emph{T}, \emph{Cvib}, \emph{ibrav=4}, \emph{typeCvib='quadratic'}}{}
This function calculates the constant strain heat capacity \(C_{\epsilon}\)
as a function of temperature. 
By definition \(C_{\epsilon} = -T(dS/dT)_{\epsilon}=-T(d^2F/dT^2)_{\epsilon}\). 
As for the entropy, we have \sphinxstyleemphasis{F(T)} from the
minimization of \sphinxstyleemphasis{F} at each T with \(\sigma=0\). However, if we use finite
difference for the derivatives, we can assume that  \(\epsilon\) is 
approximately constant over the temperatures where the numerical derivative 
is done.

To avoid the numerical derivation and the above issue, within the quasi-harmonic
approximation it is better to derive it from fitting the harmonic heat capacities
results on the grid \((a,b,c)\) at the equilibrium lattic parameters given
in \sphinxstyleemphasis{min0}. \sphinxstyleemphasis{celldms} is the grid \((a,b,c)\), \sphinxstyleemphasis{Cvib} are the harmonic 
heat capacity on the grid.
The procedure is the same as the for the \(E_{tot}+F_{vib}\) in the quasi-harmonic
calculation but without the minimization step.

Note: a better way would be to do a full harmonic calculation at exactly \sphinxstyleemphasis{min0}.
The difference with the above way is usually negligible.

\sphinxstylestrong{Important}: the above procedure relies on the quasi-harmonic approximation,
i.e. on the fact that anharmonic contribution are only due to the change of
phonon frequencies with the lattice parameters. In reality, this is not the 
case and the entropy so obtained can only be taken as an approximation of the
real one.

\end{fulllineitems}

\index{compute\_Csigma() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_Csigma}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_Csigma}}{\emph{TT}, \emph{Ceps}, \emph{minT}, \emph{alphaT}, \emph{C}, \emph{ibrav=4}}{}
This function calculates the constant strain heat capacity \(C_{\sigma}\)
as a function of temperature. 
By definition \(C_{\sigma} = -T(dS/dT)_{\sigma}=-T(d^2F/dT^2)_{\epsilon,\sigma}\). 
To avoid the numerical derivation, within the quasi-harmonic
approximation it is better to derive it from fitting the harmonic heat capacities
results on the grid \((a,b,c)\) at the equilibrium lattic parameters given
in \sphinxstyleemphasis{min0}. \sphinxstyleemphasis{celldms} is the grid \((a,b,c)\), \sphinxstyleemphasis{Cvib} are the harmonic 
heat capacity on the grid.
The procedure is the same as the for the \(E_{tot}+F_{vib}\) in the quasi-harmonic
calculation but without the minimization step.

Note: a better way would be to do a full harmonic calculation at exactly \sphinxstyleemphasis{min0}.
The difference with the above way is usually negligible.

\sphinxstylestrong{Important}: the above procedure relies on the quasi-harmonic approximation,
i.e. on the fact that anharmonic contribution are only due to the change of
phonon frequencies with the lattice parameters. In reality, this is not the 
case and the entropy so obtained can only be taken as an approximation of the
real one.

\begin{sphinxadmonition}{warning}{Warning:}
Still very experimental...
\end{sphinxadmonition}

\end{fulllineitems}

\index{compute\_Csigma\_from\_alphaandC() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_Csigma_from_alphaandC}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_Csigma\_from\_alphaandC}}{\emph{TT}, \emph{minT}, \emph{alphaT}, \emph{CT}, \emph{ibrav=4}}{}
This function calculate the difference between the constant stress heat capacity
\(C_{\sigma}\) and the constant strain heat capacity \(C_{\epsilon}\) 
from the \sphinxstyleemphasis{V} (obtained from the input lattice parameters \sphinxstyleemphasis{minT}, the thermal
expansion tensor \sphinxstyleemphasis{alphaT} and the elastic constant tensor \sphinxstyleemphasis{CT}, all as a function
of temperature. This is essentially the anisotropic equivalent of the equation
\(Cp - Cv = T V beta^2 B0\) for the isotropic case (volume only)
and it avoids a further numerical derivation to obtain \(C_{\sigma}\). 
It is however more complex in the anisotropic case since \sphinxstyleemphasis{minT}, \sphinxstyleemphasis{alphaT} and
in particul the elastic constant tensor \sphinxstyleemphasis{CT} must me known in principle 
including their temperature dependence.

\begin{sphinxadmonition}{warning}{Warning:}
Still very experimental...
\end{sphinxadmonition}

\end{fulllineitems}

\index{compute\_S() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_S}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_S}}{\emph{min0}, \emph{celldmsx}, \emph{T}, \emph{Svib}, \emph{ibrav=4}, \emph{typeSvib='quadratic'}}{}
This function calculates the entropy as a function of temperature. By definition
\(S = -(dF/dT)_{\epsilon}\). The problem is that we have \sphinxstyleemphasis{F(T)} from the
minimization of \sphinxstyleemphasis{F} at each T with \(\sigma=0\). However, if we use finite
difference for the derivatives, we can assume that  \(\epsilon\) is 
approximately constant over the temperatures where the numerical derivative 
is done.

To avoid the numerical derivation and the above issue, within the quasi-harmonic
approximation it is possible to derive the entropy from fitting the harmonic 
results on the grid \((a,b,c)\) at the equilibrium lattic parameters given
in \sphinxstyleemphasis{min0}. \sphinxstyleemphasis{celldms} is the grid \((a,b,c)\), \sphinxstyleemphasis{Svib} are the harmonic 
entropies on the grid.
The procedure is the same as the for the \(E_{tot}+F_{vib}\) in the quasi-harmonic
calculation but without the minimization step.

Note: a better way would be to do a full harmonic calculation at exactly \sphinxstyleemphasis{min0}.
The difference with the above way is usually negligible.

\sphinxstylestrong{Important}: the above procedure relies on the quasi-harmonic approximation,
i.e. on the fact that anharmonic contribution are only due to the change of
phonon frequencies with the lattice parameters. In reality, this is not the 
case and the entropy so obtained can only be taken as an approximation of the
real one.

\end{fulllineitems}

\index{compute\_alpha() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_alpha}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_alpha}}{\emph{minT}, \emph{ibrav}}{}
This function calculates the thermal expansion alphaT at different temperatures
from the input minT matrix by computing the numerical derivatives with numpy.
The input matrix minT has shape nT*6, where the first index is the temperature 
and the second the lattice parameter. For example, minT{[}i,0{]} and minT{[}i,2{]} are
the lattice parameters a and c at the temperature i.

More ibrav types must be implemented

\end{fulllineitems}

\index{compute\_alpha\_splines() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_alpha_splines}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_alpha\_splines}}{\emph{TT}, \emph{minT}, \emph{ibrav}, \emph{splinesoptions}}{}
This function calculates the thermal expansions alphaT at different temperatures
as the previous function but using spline interpolation as implemented in
scipy.interpolate.

\end{fulllineitems}

\index{compute\_volume() (in module pyqha.properties\_anis)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.properties_anis.compute_volume}\pysiglinewithargsret{\sphinxcode{pyqha.properties\_anis.}\sphinxbfcode{compute\_volume}}{\emph{celldms}, \emph{ibrav=4}}{}
Compute the volume given the \sphinxstyleemphasis{celldms}. Only for ibrav=4 for now, else 
returns 0.

\end{fulllineitems}



\section{pyqha.read module}
\label{pyqha:pyqha-read-module}\label{pyqha:module-pyqha.read}\index{pyqha.read (module)}\index{read\_Etot() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_Etot}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_Etot}}{\emph{fname}, \emph{ibrav=4}, \emph{bc\_as\_a\_ratio=True}}{}
Read cell parameters \sphinxstyleemphasis{(a,b,c)} and the corresponding energies from input file \sphinxstyleemphasis{fname}. 
Each set of cell parameters is stored in a numpy array of lenght 6 
for \sphinxstyleemphasis{(a,b,c,alpha,beta,gamma)} respectively. This is done for a future possible 
extension but for now only the first 3 elements are used (the others are always 0).
All sets are stored in \sphinxstyleemphasis{celldmsx} and \sphinxstyleemphasis{Ex}, the former is a nE*6 matrix, 
the latter is a nE array.

\sphinxstyleemphasis{ibrav} identifies the Bravais lattice as in Quantum Espresso and is needed 
in input (default is 4, i.e. hexagonal cell). The input file format depends
on \sphinxstyleemphasis{ibrav}, for example in the hex case, the first two columns are for \sphinxstyleemphasis{a} and
\sphinxstyleemphasis{c} and the third is for the energies.

If \sphinxstyleemphasis{bc\_as\_a\_ratio=True}, the input data are assumed to be given as 
\((a,b/a,c/a)\) in the input file and hence converted into \((a,b,c)\)
which is how they are always stored internally in \sphinxcode{pyqha}.

Units must be \(a.u.\) and \(Ryd/cell\)

\end{fulllineitems}

\index{read\_EtotV() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_EtotV}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_EtotV}}{\emph{fname}}{}
Read cell volumes and the corresponding energies from input file \sphinxstyleemphasis{fname}
(1st col, volumes, 2nd col energies). Units must be \(a.u.^3\) and 
\(Ryd/cell\)

\end{fulllineitems}

\index{read\_alpha() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_alpha}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_alpha}}{\emph{fname}}{}
\end{fulllineitems}

\index{read\_celldmt\_hex() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_celldmt_hex}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_celldmt\_hex}}{\emph{filename}}{}
\end{fulllineitems}

\index{read\_dos() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_dos}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_dos}}{\emph{filename}}{}
Read the phonon density of states (y axis) and the corresponding energies (x axis)
from the input file \sphinxstyleemphasis{filename} (1st col energies, 2nd col DOS) and store it
in two numpy arrays which are returned.

\end{fulllineitems}

\index{read\_dos\_geo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_dos_geo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_dos\_geo}}{\emph{fin}, \emph{ngeo}}{}
Read the phonon density of states and energies as in {\hyperref[pyqha:pyqha.read.read_dos]{\sphinxcrossref{\sphinxcode{read\_dos()}}}} from \sphinxstyleemphasis{ngeo} input files
\sphinxstyleemphasis{fin1}, \sphinxstyleemphasis{fin2}, etc. and store it in two numpy matrices which are returned.

\end{fulllineitems}

\index{read\_elastic\_constants() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_elastic_constants}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_elastic\_constants}}{\emph{fname}}{}
This function reads and returns the elastic constants and compliances from
the file \sphinxstyleemphasis{fname} .
Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape {[}6,6{]}
So, the elastic constant C11 is in C{[}0,0{]}, C12 in C{[}0,1{]} and so on.
Same for the elastic compliances.

\end{fulllineitems}

\index{read\_elastic\_constants\_geo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_elastic_constants_geo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_elastic\_constants\_geo}}{\emph{fC}, \emph{ngeo}}{}
Read elastic constants calculated on a multidimensional grid of lattice parameters
\sphinxstyleemphasis{ngeo} defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!

\end{fulllineitems}

\index{read\_freq() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq}}{\emph{fname}}{}
Read the phonon frequencies at each q point from a frequency file \sphinxstyleemphasis{fname}.
The format of this file is different from the one read by the {\hyperref[pyqha:pyqha.read.read_freq]{\sphinxcrossref{\sphinxcode{read\_freq()}}}} and
contains usually more frequencies, each with a weight, but no q-point coordinates.

The input frequency file is expected to have the following format:
1st line contains the number of atoms in the unit cell, the q-point grid 
\((nqx, nqy, nqz)\) and the total number of q-points listed \sphinxstyleemphasis{nq}.
2nd line not read.   
For the 3rd line on, the following scheme is repeated:
1st line: the \sphinxstyleemphasis{weight} of the q-point (they can be different because of simmetry)
n modes lines, each with the corresponding phonon frequency

Returning values are a \sphinxstyleemphasis{nq} vector of weights, each \sphinxstyleemphasis{weights{[}i{]}} being the weight of given q-point 
and a \(nq*modes\) matrix \sphinxstyleemphasis{freq}, each element \sphinxstyleemphasis{freq{[}i{]}} being the phonon frequencies
(vector of modes elements) at the q-point \sphinxstyleemphasis{i}

\end{fulllineitems}

\index{read\_freq\_geo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq_geo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq\_geo}}{\emph{fname}, \emph{ngeo=1}}{}
Read the frequencies as in {\hyperref[pyqha:pyqha.read.read_freq]{\sphinxcrossref{\sphinxcode{read\_freq()}}}} but for \sphinxstyleemphasis{ngeo} geometries.
Input files are \sphinxstyleemphasis{fname1}, \sphinxstyleemphasis{fname2}, \sphinxstyleemphasis{fname3}, etc.

\end{fulllineitems}

\index{read\_freq\_geo\_old() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq_geo_old}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq\_geo\_old}}{\emph{inputfilefreq}, \emph{rangegeo}}{}
Read the frequencies for all geometries where the gruneisen parameters must be
calculated. Start, stop, step must be given accordingly. It can be used to read
the frequencies only at some geometries from a larger set, if necessary, 
providing the proper start, stop and step values.

Notes:
nq = qgeo.shape{[}1{]} -\textgreater{} total number of q points read
modes = freqgeo.shape{[}2{]} -\textgreater{} number of frequency modes

\end{fulllineitems}

\index{read\_freq\_old() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_freq_old}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_freq\_old}}{\emph{filename}}{}
This function reads the phonon frequencies at each q-point from a frequency file.  
Input file has the following format (to be done).

Returning values are a nq*3 matrix q, each q{[}i{]} being a q point (vector of 3 elements)
and a nq*modes matrix freq, each element freq{[}i{]} being the phonon frequencies
(vector of modes elements)

\end{fulllineitems}

\index{read\_thermo() (in module pyqha.read)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.read.read_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.read.}\sphinxbfcode{read\_thermo}}{\emph{fname}, \emph{ngeo=1}}{}
Read vibrational thermodynamic functions (Evib, Fvib, Svib, Cvib) as a 
function of temperature from the input file \sphinxstyleemphasis{fname}. \sphinxstyleemphasis{ngeo} is the number
of input files to read, corresponding for example to different geometries
in a quasi-harmonic calculation.
If \sphinxstyleemphasis{ngeo\textgreater{}1} reads from the files \sphinxstyleemphasis{fname1}, \sphinxstyleemphasis{fname2}, etc. up to \sphinxstyleemphasis{ngeo}  
Input file(s) have the following format:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
T
\unskip}\relax &
\(E_{vib}\)
&
\(F_{vib}\)
&
\(S_{vib}\)
&
\(C_{vib}\)
\\
\hline
1
&
...
&
...
&
...
&
...
\\
\hline\end{tabulary}


Lines starting with ``\#'' are not read (comments).

Returning values are \(nT*ngeo\) numpy matrices (T,Evib,Fvib,Svib,Cvib) containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib{[}T,geo{]} -\textgreater{} Fvib at the temperature \sphinxstyleemphasis{T} for the geometry \sphinxstyleemphasis{geo}

Units must be \sphinxstyleemphasis{K} for temperature, \sphinxstyleemphasis{Ryd/cell} for energies, \sphinxstyleemphasis{Ryd/cell/K} for
entropy and heat capacity.

\end{fulllineitems}



\section{pyqha.thermo module}
\label{pyqha:pyqha-thermo-module}\label{pyqha:module-pyqha.thermo}\index{pyqha.thermo (module)}\index{compute\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo}}{\emph{E}, \emph{dos}, \emph{TT}}{}
This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays \sphinxstyleemphasis{E} 
and \sphinxstyleemphasis{dos} containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array \sphinxstyleemphasis{TT}.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to \(3*N\), with \sphinxstyleemphasis{N} the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.

\end{fulllineitems}

\index{compute\_thermo\_geo() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{compute\_thermo\_geo}}{\emph{fin}, \emph{fout=None}, \emph{ngeo=1}, \emph{TT=array({[}1{]})}}{}
This function reads the input dos file(s) from \sphinxstyleemphasis{fin+i}, with \sphinxstyleemphasis{i} a number from
1 to \sphinxstyleemphasis{ngeo} + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
T
\unskip}\relax &
\(E_{vib}\)
&
\(F_{vib}\)
&
\(S_{vib}\)
&
\(C_{vib}\)
\\
\hline
1
&
...
&
...
&
...
&
...
\\
\hline\end{tabulary}


and are names \sphinxstyleemphasis{fout} +1, \sphinxstyleemphasis{fout} +2,... for each geometry.

Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib{[}T,geo{]} -\textgreater{} Fvib at the temperature ``T'' for the geometry ``geo''

\end{fulllineitems}

\index{dos\_integral() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{dos\_integral}}{\emph{E}, \emph{dos}, \emph{m=0}}{}
A function to compute the integral of an input phonon DOS (\sphinxstyleemphasis{dos}) with the 3/8 Simpson method.
\sphinxstyleemphasis{m} is the moment of the integral, if \(m>0\) different moments can be calculated.
For example, with \(m=0\) (default) it returns the number of modes from the dos, 
with \(m=1\) it returns the ZPE. The input energy (\sphinxstyleemphasis{E}) and phonon DOS (\sphinxstyleemphasis{dos}) are expected to be in
\(cm^{-1}\).

\end{fulllineitems}

\index{gen\_TT() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{gen\_TT}}{\emph{Tstart=1}, \emph{Tend=1000}, \emph{Tstep=1}}{}
A simple function to generate a numpy array of temperatures, starting from
\sphinxstyleemphasis{Tstart} and ending to \sphinxstyleemphasis{Tend} (or the closest \sphinxstyleemphasis{T\textless{}Tend} accorinding to the \sphinxstyleemphasis{Tstep} )
with step \sphinxstyleemphasis{Tstep} .

\end{fulllineitems}

\index{rearrange\_thermo() (in module pyqha.thermo)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{pyqha.thermo.}\sphinxbfcode{rearrange\_thermo}}{\emph{T}, \emph{Evib}, \emph{Fvib}, \emph{Svib}, \emph{Cvib}, \emph{ngeo=1}}{}
This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices \sphinxstyleemphasis{X} now gives all geometries at a given
\sphinxstyleemphasis{T}, i.e. \sphinxstyleemphasis{X{[}0{]}} is the vector of the property \sphinxstyleemphasis{X} a \sphinxstyleemphasis{T=T{[}0,0{]}} . \sphinxstyleemphasis{X{[}0,0{]}} for the first 
geometry, \sphinxstyleemphasis{X{[}0,1{]}} the second geometry and so on.

\end{fulllineitems}



\section{pyqha.write module}
\label{pyqha:pyqha-write-module}\label{pyqha:module-pyqha.write}\index{pyqha.write (module)}\index{write\_CT() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_CT}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_CT}}{\emph{Ts}, \emph{CT}, \emph{fCout='`}}{}
Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!

\end{fulllineitems}

\index{write\_C\_geo() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_C_geo}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_C\_geo}}{\emph{celldmsx}, \emph{C}, \emph{ibrav=4}, \emph{fCout='`}}{}
Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies in the quasi-harmonic calculations!

\end{fulllineitems}

\index{write\_Etot() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_Etot}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_Etot}}{\emph{celldmsx}, \emph{Ex}, \emph{fname}, \emph{ibrav=4}}{}
Read cell parameters (a,b,c,alpha,beta,gamma) and energies for a grid of cell
parameters values from file output\_energy1. 
Each celldms is a vector of lenght 6 containing a,b,c,alpha,beta,gamma respectively
celldmsx and Ex contains the grid of values of celldms and E so that:
celldmsx{[}0{]} = celldms0      Ex{[}0{]} = E0
celldmsx{[}1{]} = celldms1      Ex{[}1{]} = E1
celldmsx{[}2{]} = celldms2      Ex{[}2{]} = E2
........
values are taken from the file ``fname''
ibrav is the Bravais lattice as in Quantum Espresso and is needed in input (default is cubic)

\end{fulllineitems}

\index{write\_alphaT() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_alphaT}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_alphaT}}{\emph{fname}, \emph{T}, \emph{alphaT}, \emph{ibrav=4}}{}
\end{fulllineitems}

\index{write\_celldmsT() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_celldmsT}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_celldmsT}}{\emph{fname}, \emph{T}, \emph{x}, \emph{ibrav=4}}{}
\end{fulllineitems}

\index{write\_elastic\_constants() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_elastic_constants}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_elastic\_constants}}{\emph{C}, \emph{S}, \emph{fname}}{}
Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape {[}6,6{]}
So, the elastic constant C11 is in C{[}0{]}{[}0{]}, C12 in C{[}0{]}{[}1{]} and so on.
Same for the elastic compliances

\end{fulllineitems}

\index{write\_freq() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_freq}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_freq}}{\emph{weights}, \emph{freq}, \emph{filename}}{}
Write frequencies (or Gruneisen parameters) on an extended mesh in a file.
In this format, q points coordinates are NOT written but the weight of each point yes.
It can be used to write the Gruneisen mode parameters, giving them in input as freq
Write the gruneisen parameters

\end{fulllineitems}

\index{write\_freq\_old() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_freq_old}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_freq\_old}}{\emph{qgeo}, \emph{freq}, \emph{filename}}{}
Write frequencies (or Gruneisen parameters) in a file. In this format also q points
coordinates are written but not the weight of each point.
It can be used to write the Gruneisen mode parameters, giving them in input as freq

\end{fulllineitems}

\index{write\_thermo() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_thermo}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_thermo}}{\emph{fname}, \emph{T}, \emph{Evib}, \emph{Fvib}, \emph{Svib}, \emph{Cvib}, \emph{ZPE}, \emph{modes}}{}
\end{fulllineitems}

\index{write\_xy() (in module pyqha.write)}

\begin{fulllineitems}
\phantomsection\label{pyqha:pyqha.write.write_xy}\pysiglinewithargsret{\sphinxcode{pyqha.write.}\sphinxbfcode{write\_xy}}{\emph{fname}, \emph{x}, \emph{y}, \emph{labelx}, \emph{labely}}{}
This function writes a quantity y versus quantity x into the file fname.
y and x are arrays and should have the same lenght. labelx and labely
are the axis labels (possibly with units), written in the header of the file
(first line).

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\sphinxstyleindexentry{pyqha.alphagruneisenp}}\sphinxstyleindexpageref{pyqha:module-pyqha.alphagruneisenp}
\item {\sphinxstyleindexentry{pyqha.constants}}\sphinxstyleindexpageref{pyqha:module-pyqha.constants}
\item {\sphinxstyleindexentry{pyqha.eos}}\sphinxstyleindexpageref{pyqha:module-pyqha.eos}
\item {\sphinxstyleindexentry{pyqha.fitC}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitC}
\item {\sphinxstyleindexentry{pyqha.fitEtot}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitEtot}
\item {\sphinxstyleindexentry{pyqha.fitfreqgrun}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitfreqgrun}
\item {\sphinxstyleindexentry{pyqha.fitFvib}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitFvib}
\item {\sphinxstyleindexentry{pyqha.fitutils}}\sphinxstyleindexpageref{pyqha:module-pyqha.fitutils}
\item {\sphinxstyleindexentry{pyqha.minutils}}\sphinxstyleindexpageref{pyqha:module-pyqha.minutils}
\item {\sphinxstyleindexentry{pyqha.plotutils}}\sphinxstyleindexpageref{pyqha:module-pyqha.plotutils}
\item {\sphinxstyleindexentry{pyqha.properties\_anis}}\sphinxstyleindexpageref{pyqha:module-pyqha.properties_anis}
\item {\sphinxstyleindexentry{pyqha.read}}\sphinxstyleindexpageref{pyqha:module-pyqha.read}
\item {\sphinxstyleindexentry{pyqha.thermo}}\sphinxstyleindexpageref{pyqha:module-pyqha.thermo}
\item {\sphinxstyleindexentry{pyqha.write}}\sphinxstyleindexpageref{pyqha:module-pyqha.write}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}