<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyqha package &#8212; pyqha 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="pyqha 0.1 documentation" href="index.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" /> 
  </head>
  <body role="document">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><h1 style="font-size: 3em;">pyqha</h1></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyqha package</a><ul>
<li><a class="reference internal" href="#module-contents">Module contents</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pyqha.constants">pyqha.constants module</a></li>
<li><a class="reference internal" href="#module-pyqha.eos">pyqha.eos module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitC">pyqha.fitC module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitEtot">pyqha.fitEtot module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitFvib">pyqha.fitFvib module</a></li>
<li><a class="reference internal" href="#module-pyqha.alphagruneisenp">pyqha.alphagruneisenp module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitfreqgrun">pyqha.fitfreqgrun module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitutils">pyqha.fitutils module</a></li>
<li><a class="reference internal" href="#module-pyqha.minutils">pyqha.minutils module</a></li>
<li><a class="reference internal" href="#module-pyqha.plotutils">pyqha.plotutils module</a></li>
<li><a class="reference internal" href="#module-pyqha.properties_anis">pyqha.properties_anis module</a></li>
<li><a class="reference internal" href="#module-pyqha.read">pyqha.read module</a></li>
<li><a class="reference internal" href="#module-pyqha.thermo">pyqha.thermo module</a></li>
<li><a class="reference internal" href="#module-pyqha.write">pyqha.write module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial.html"
                        title="previous chapter">Tutorial</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pyqha.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pyqha-package">
<h1>pyqha package<a class="headerlink" href="#pyqha-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-contents">
<h2>Module contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
<p>The following functions are available from <code class="xref py py-mod docutils literal"><span class="pre">pyqha</span></code> module and are the most common ones for the end user.</p>
<span class="target" id="module-pyqha.fitEtot"></span><dl class="function">
<dt id="pyqha.fitEtot.fitEtot">
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtot</code><span class="sig-paren">(</span><em>fin</em>, <em>out=True</em>, <em>ibrav=4</em>, <em>fittype='quadratic'</em>, <em>guess=None</em>, <em>method='BFGS'</em>, <em>minoptions={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitEtot.fitEtot" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads the file <em>fin</em> containing the energies as a function
of the lattice parameters <img class="math" src="_images/math/4a2cd023907894f80fe62bbfe347513bc4954331.png" alt="E(a,b,c)"/> and fits them with a quartic (<em>fittype=&#8221;quartic&#8221;</em>) or 
quadratic (<em>fittype=&#8221;quadratic&#8221;</em>) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redirected to <em>stdout</em>)
if <em>out=True</em>.
It returns the lattice parameters and energies as in the input file <em>fin</em>,
the fitted coefficients of the polynomial, the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>,
the lattice parameters at the minimum and the minimun energy.</p>
<p>Note: for cubic systems use fitEtotV instead.</p>
<p>Advanced input parameters:</p>
<p><em>guess</em>, an initial guess for the minimization. It is a 6 elements list 
[a,b,c,0,0,0].</p>
<p><em>method</em>, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details.</p>
<p><em>minoptions</em>, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitEtot.fitEtotV">
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtotV</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtotV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitEtot.fitEtotV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads <img class="math" src="_images/math/7d28b83e95abf8aa59bcd91638cd7497b0045c5f.png" alt="E(V)"/> data from the input file <em>fin</em>, fits them with a Murnaghan EOS,
prints the results on the <em>stdout</em> and write them in the file &#8220;fout&#8221;.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.</p>
</dd></dl>

<span class="target" id="module-pyqha.thermo"></span><dl class="function">
<dt id="pyqha.thermo.compute_thermo">
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>TT</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.compute_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays <em>E</em> 
and <em>dos</em> containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array <em>TT</em>.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to <img class="math" src="_images/math/7fd84257c87ff8dc9ee27bd300875a6bdc8e2161.png" alt="3*N"/>, with <em>N</em> the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.compute_thermo_geo">
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo_geo</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em>, <em>ngeo=1</em>, <em>TT=array([1])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.compute_thermo_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads the input dos file(s) from <em>fin+i</em>, with <em>i</em> a number from
1 to <em>ngeo</em> + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">T</th>
<th class="head"><img class="math" src="_images/math/9fbdb84aec610808b553f187fc1ac99b95993006.png" alt="E_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/55b3ed38f962644f1072ee6a112740f24b78ed7b.png" alt="F_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/1ec0b0b14b11bd65993b7ac59a1fa3b78e78688c.png" alt="S_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/03ba745362038f7a468482e89419d50637d84353.png" alt="C_{vib}"/></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>and are names <em>fout</em> +1, <em>fout</em> +2,... for each geometry.</p>
<p>Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib[T,geo] -&gt; Fvib at the temperature &#8220;T&#8221; for the geometry &#8220;geo&#8221;</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.dos_integral">
<code class="descclassname">pyqha.thermo.</code><code class="descname">dos_integral</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>m=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#dos_integral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.dos_integral" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to compute the integral of an input phonon DOS (<em>dos</em>) with the 3/8 Simpson method.
<em>m</em> is the moment of the integral, if <img class="math" src="_images/math/9fe942a3b863852d1099e24ee69ed6068dce0933.png" alt="m&gt;0"/> different moments can be calculated.
For example, with <img class="math" src="_images/math/57e7fcd1e7c250f9afe8510738fcc25150cd46f8.png" alt="m=0"/> (default) it returns the number of modes from the dos, 
with <img class="math" src="_images/math/59c39884c40bf8420da99bdbc1f350c83b9acf63.png" alt="m=1"/> it returns the ZPE. The input energy (<em>E</em>) and phonon DOS (<em>dos</em>) are expected to be in
<img class="math" src="_images/math/8ef74976bf2a6e3a7790f40f153ad625f3fb9d60.png" alt="cm^{-1}"/>.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.gen_TT">
<code class="descclassname">pyqha.thermo.</code><code class="descname">gen_TT</code><span class="sig-paren">(</span><em>Tstart=1</em>, <em>Tend=1000</em>, <em>Tstep=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#gen_TT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.gen_TT" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple function to generate a numpy array of temperatures, starting from
<em>Tstart</em> and ending to <em>Tend</em> (or the closest <em>T&lt;Tend</em> accorinding to the <em>Tstep</em> )
with step <em>Tstep</em> .</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.rearrange_thermo">
<code class="descclassname">pyqha.thermo.</code><code class="descname">rearrange_thermo</code><span class="sig-paren">(</span><em>T</em>, <em>Evib</em>, <em>Fvib</em>, <em>Svib</em>, <em>Cvib</em>, <em>ngeo=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#rearrange_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.rearrange_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices <em>X</em> now gives all geometries at a given
<em>T</em>, i.e. <em>X[0]</em> is the vector of the property <em>X</em> a <em>T=T[0,0]</em> . <em>X[0,0]</em> for the first 
geometry, <em>X[0,1]</em> the second geometry and so on.</p>
</dd></dl>

<span class="target" id="module-pyqha.fitFvib"></span><dl class="function">
<dt id="pyqha.fitFvib.fitFvib">
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvib</code><span class="sig-paren">(</span><em>fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], method='BFGS', minoptions={}, splinesoptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvib"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitFvib.fitFvib" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/1883c3f030ec103c67e7fb6fb02fa7b0a39aacf7.png" alt="F_{vib}(a,b,c,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in <em>fin</em> file. The 
real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>The function fits <img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> with a quadratic
or quartic polynomial (as defined by <em>typeEtot</em> and <em>typeFvib</em> ) at each
temperature in <em>thermodata</em> and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/>
and <img class="math" src="_images/math/50048175b5237f76e7863c156fa66afda1f1be9d.png" alt="F_{vib}(a,b,c)"/>. Then it computes the minimun energy <img class="math" src="_images/math/6fad90a8a0bf48bf469ab26edc21276d3b35748d.png" alt="E_{tot}+F_{vib}"/>
and the corresponding lattice parameters <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> 
at each temperature by miniimizing the energy.</p>
<p>It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_alpha()</span></code>).</p>
<p>It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> 
only (at T=0 K) and the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> at each temperature.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example6</em> and 
the tutorial.</p>
</div>
<p>Advanced input parameters:</p>
<p><em>guess</em>, an initial guess for the minimization. It is a 6 elements list 
[a,b,c,0,0,0].</p>
<p><em>method</em>, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details. Note that the 
methods which usually gives better results for quasi-harmonic calculations
are the &#8220;BFGS&#8221; or Newton-CG&#8221;. Default is &#8220;BFGS&#8221;.</p>
<p><em>minoptions</em>, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.
Note the the options are different for different methods.</p>
<p><em>splinesoptions</em>, determines whether to use or not splines to reduce the noise
on numerical derivatives (thermal expansions). If <em>splinesoptions*==None, use 
finete differences for derivatives, else use splines as implemented in
scipy.interpolate (see documentation). In the latter case, *splinesoptions</em>
must be a dictionary. This dictionary must contains the keywords <em>k0</em>, <em>s0</em>,
<em>k1</em>, <em>s1</em>, <em>k2</em>, <em>s2</em> which are passed to <code class="xref py py-func docutils literal"><span class="pre">scipy.interpolate.splrep()</span></code>, 
one couple for each set of thermal expansions (alpha_xx, alpha_yy, alpha_zz).
<em>k</em> is the order of the spline (default=3), s a smoothing condition (default=None).
If <em>splinesoptions=={}</em> use the default options of <code class="xref py py-func docutils literal"><span class="pre">scipy.interpolate.splrep()</span></code>
Note: use this option with care</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitFvib.fitFvibV">
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvibV</code><span class="sig-paren">(</span><em>fin</em>, <em>thermodata</em>, <em>verbosity='low'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvibV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitFvib.fitFvibV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/1b43a9b9fc946c5e4302c3dd56be1b79358f3d66.png" alt="E_{tot}(V)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/b6911133133a6937356b958128d1e99cd4969b81.png" alt="F_{vib}(V,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in <em>fin</em> file.</p>
<p>The function fits <img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> with a Murnaghan&#8217;s EOS
at each temperature in <em>thermodata</em> and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_beta()</span></code>), the
constant volume heat capacity at the minimum volume at each T
(<code class="xref py py-func docutils literal"><span class="pre">compute_Cv()</span></code>) and the constant pression heat capacity (<code class="xref py py-func docutils literal"><span class="pre">compute_Cp()</span></code>).</p>
<p>It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> at each T.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example5</em> and 
the tutorial.</p>
</div>
</dd></dl>

<span class="target" id="module-pyqha.fitC"></span><dl class="function">
<dt id="pyqha.fitC.fS">
<code class="descclassname">pyqha.fitC.</code><code class="descname">fS</code><span class="sig-paren">(</span><em>aS</em>, <em>mintemp</em>, <em>typeCx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.fS" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function returning the elastic compliances 6x6 tensor at the
set of lattice parameters given in input as mintemp. These should be the
lattice parameters at a given temperature obtained from the free energy
minimization, so that S(T) can be obtained.
Before calling this function, the polynomial coefficients resulting from 
fitting the elastic compliances over a grid of lattice parameters, i.e. over
different geometries, must be obtained and passed as input in aS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitC.fitCT">
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCT</code><span class="sig-paren">(</span><em>aC</em>, <em>chiC</em>, <em>T</em>, <em>minT</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.fitCT" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the elastic constants tensor <em>CT</em> as a function of
temperatature in the quasi-static approximation.
It takes in input <em>aC</em> and <em>chiC</em>, the fitted coefficients of the elastic 
constants as a function of <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.
It also takes in input an array of temperatures <em>T</em> and the corresponding
lattice parameters <em>minT</em>, i.e. <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( <em>ibrav</em> ) and the type of polynomial
( <em>typeC</em> ) used for fitting the input <em>aC</em>.</p>
<p>The function uses the coefficients <em>aC</em> to compute the elastic tensor at
each temperature in the array <em>T</em> from the corresponding lattice parameters
<img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> in <em>minT</em>.</p>
<p>It returns the temperature array and the a matrix <em>CT</em> with all the elastic
tensors at each T ( <em>CT[i]</em> is the elastic constants matrix for the 
temperature <em>T[i]</em>)</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The coefficients <em>aC</em> must be the result of fitting the elastic constants
over the same <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> grid used in the quasi-harmonic calculations
corresponding to <em>minT</em> values! (See example7)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitC.fitCxx">
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCxx</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Cxx</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCxx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.fitCxx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function fits the elastic constant elements of <em>Cxx</em> as a function of the
grid of lattice parameters <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>. 
The real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>It returns a 6*6 matrix, each element <em>[i,j]</em> being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element <em>[i,j]</em> being the corresponding
<img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>. If the chi squared is zero, the fitting procedure was NOT succesful</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitC.fitS">
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitS</code><span class="sig-paren">(</span><em>inputfileEtot</em>, <em>inputpathCx</em>, <em>ibrav</em>, <em>typeSx='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.fitS" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function for fitting the elastic compliances elements over a
grid of lattice parameters, i.e. over different geometries.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitC.rearrange_Cx">
<code class="descclassname">pyqha.fitC.</code><code class="descname">rearrange_Cx</code><span class="sig-paren">(</span><em>Cx</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#rearrange_Cx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.rearrange_Cx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function rearrange the input numpy matrix <em>Cx</em> into an equivalent matrix <em>Cxx</em>
for fitting it.
<em>Cx</em> is a <img class="math" src="_images/math/d87cb9d32bf68941207e822102899f34a2e64732.png" alt="ngeo*6*6"/> matrix, each <em>Cx[i]</em> is the 6*6 <em>C</em> matrix for a given geometry ( <em>i</em> )
<em>Cxx</em> is a Lmath:<cite>6*6*ngeo</cite> matrix, each <em>Cxx[i][j]</em> is a vector with all values for different
geometries of the <em>Cij</em> elastic constant matrix element. For example, <em>Cxx[0,0]</em>
is the vector with ngeo values of the <em>C11</em> elastic constant and so on.</p>
</dd></dl>

</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<p>Additional functions are available as submodules. Please note the documentation of these functions is still ongoing and can be incomplete or wrong.</p>
</div>
<div class="section" id="module-pyqha.constants">
<span id="pyqha-constants-module"></span><h2>pyqha.constants module<a class="headerlink" href="#module-pyqha.constants" title="Permalink to this headline">¶</a></h2>
<p>Some useful standard constants for conversions and calculations.</p>
</div>
<div class="section" id="module-pyqha.eos">
<span id="pyqha-eos-module"></span><h2>pyqha.eos module<a class="headerlink" href="#module-pyqha.eos" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.eos.E_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">E_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#E_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.E_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>As <a class="reference internal" href="#pyqha.eos.E_MurnV" title="pyqha.eos.E_MurnV"><code class="xref py py-func docutils literal"><span class="pre">E_MurnV()</span></code></a> but input parameters are given as a single list 
<em>a=[a0,a1,a2,a3]</em>.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.E_MurnV">
<code class="descclassname">pyqha.eos.</code><code class="descname">E_MurnV</code><span class="sig-paren">(</span><em>V</em>, <em>a0</em>, <em>a1</em>, <em>a2</em>, <em>a3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#E_MurnV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.E_MurnV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements the Murnaghan EOS (in a form which is best for fitting).
Returns the energy at the volume <em>V</em> using the coefficients <em>a0,a1,a2,a3</em> 
from the equation:</p>
<div class="math">
<p><img src="_images/math/e892012b52d6eb84a56e82f7fe739c804129f748.png" alt="a_0 - (a_2*a_1)/(a_3-1.0) V a_2/a_3 ( a_1/V^{a_3})/(a_3-1.0) +1.0 )"/></p>
</div></dd></dl>

<dl class="function">
<dt id="pyqha.eos.H_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">H_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#H_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.H_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>This function return</p>
<p>As <a class="reference internal" href="#pyqha.eos.E_MurnV" title="pyqha.eos.E_MurnV"><code class="xref py py-func docutils literal"><span class="pre">E_MurnV()</span></code></a> but input parameters are given as a single list 
<em>a=[a0,a1,a2,a3]</em> and it returns the pressure not the energy from the EOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.P_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">P_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#P_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.P_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>As <a class="reference internal" href="#pyqha.eos.E_MurnV" title="pyqha.eos.E_MurnV"><code class="xref py py-func docutils literal"><span class="pre">E_MurnV()</span></code></a> but input parameters are given as a single list 
<em>a=[a0,a1,a2,a3]</em> and it returns the pressure not the energy from the EOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.calculate_fitted_points">
<code class="descclassname">pyqha.eos.</code><code class="descname">calculate_fitted_points</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#calculate_fitted_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.calculate_fitted_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a denser mesh of E(V) points for plotting...</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.compute_Cp">
<code class="descclassname">pyqha.eos.</code><code class="descname">compute_Cp</code><span class="sig-paren">(</span><em>T</em>, <em>Cv</em>, <em>V</em>, <em>B0</em>, <em>beta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#compute_Cp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.compute_Cp" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the isobaric heat capacity from the eq. Cp-Cv=...
Not implemented yet.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.compute_Cv">
<code class="descclassname">pyqha.eos.</code><code class="descname">compute_Cv</code><span class="sig-paren">(</span><em>T</em>, <em>Vmin</em>, <em>V</em>, <em>Cvib</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#compute_Cv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.compute_Cv" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the isocoric heat capacity as a function of temperature.
From <em>Cvib</em>, which is a matrix with <em>Cvib(T,V)</em> as from the harmonic calculations
determines the <em>Cv</em> at each temperature by linear interpolation between the values
at the two volumes closest to Vmin(T). Vmin(T) is from the minimization of F(V,T)
and <em>V</em> is the array of volumes used for it.
Returns <em>Cv(T)</em>.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.compute_beta">
<code class="descclassname">pyqha.eos.</code><code class="descname">compute_beta</code><span class="sig-paren">(</span><em>minT</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#compute_beta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.compute_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the volumetric thermal expansion as a numerical
derivative of the volume as a function of temperature V(T). This is obtained
from the free energy minimization which should be done before.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.fit_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">fit_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>E</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#fit_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.fit_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for fitting with the Murnaghan EOS as a function of volume only.</p>
<p>The input variable V is an 1D array of volumes, E are the corresponding 
energies (or other analogous quantity to be fitted with the Murnaghan EOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.print_eos_data">
<code class="descclassname">pyqha.eos.</code><code class="descname">print_eos_data</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>a</em>, <em>chi</em>, <em>ylabel='Etot'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#print_eos_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.print_eos_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the data and the fitted results using the EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be &#8220;Etot&#8221;, 
&#8220;Fvib&#8221;, etc.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.write_Etotfitted">
<code class="descclassname">pyqha.eos.</code><code class="descname">write_Etotfitted</code><span class="sig-paren">(</span><em>filename</em>, <em>x</em>, <em>y</em>, <em>a</em>, <em>chi</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#write_Etotfitted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.write_Etotfitted" title="Permalink to this definition">¶</a></dt>
<dd><p>Write in filename the data and the fitted results using the EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be &#8220;Etot&#8221;, 
&#8220;Fvib&#8221;, etc.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitC">
<span id="pyqha-fitc-module"></span><h2>pyqha.fitC module<a class="headerlink" href="#module-pyqha.fitC" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">fS</code><span class="sig-paren">(</span><em>aS</em>, <em>mintemp</em>, <em>typeCx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fS"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>An auxiliary function returning the elastic compliances 6x6 tensor at the
set of lattice parameters given in input as mintemp. These should be the
lattice parameters at a given temperature obtained from the free energy
minimization, so that S(T) can be obtained.
Before calling this function, the polynomial coefficients resulting from 
fitting the elastic compliances over a grid of lattice parameters, i.e. over
different geometries, must be obtained and passed as input in aS.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCT</code><span class="sig-paren">(</span><em>aC</em>, <em>chiC</em>, <em>T</em>, <em>minT</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCT"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function calculates the elastic constants tensor <em>CT</em> as a function of
temperatature in the quasi-static approximation.
It takes in input <em>aC</em> and <em>chiC</em>, the fitted coefficients of the elastic 
constants as a function of <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.
It also takes in input an array of temperatures <em>T</em> and the corresponding
lattice parameters <em>minT</em>, i.e. <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( <em>ibrav</em> ) and the type of polynomial
( <em>typeC</em> ) used for fitting the input <em>aC</em>.</p>
<p>The function uses the coefficients <em>aC</em> to compute the elastic tensor at
each temperature in the array <em>T</em> from the corresponding lattice parameters
<img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> in <em>minT</em>.</p>
<p>It returns the temperature array and the a matrix <em>CT</em> with all the elastic
tensors at each T ( <em>CT[i]</em> is the elastic constants matrix for the 
temperature <em>T[i]</em>)</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The coefficients <em>aC</em> must be the result of fitting the elastic constants
over the same <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> grid used in the quasi-harmonic calculations
corresponding to <em>minT</em> values! (See example7)</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCxx</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Cxx</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCxx"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function fits the elastic constant elements of <em>Cxx</em> as a function of the
grid of lattice parameters <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>. 
The real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>It returns a 6*6 matrix, each element <em>[i,j]</em> being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element <em>[i,j]</em> being the corresponding
<img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>. If the chi squared is zero, the fitting procedure was NOT succesful</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitS</code><span class="sig-paren">(</span><em>inputfileEtot</em>, <em>inputpathCx</em>, <em>ibrav</em>, <em>typeSx='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitS"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>An auxiliary function for fitting the elastic compliances elements over a
grid of lattice parameters, i.e. over different geometries.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">rearrange_Cx</code><span class="sig-paren">(</span><em>Cx</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#rearrange_Cx"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function rearrange the input numpy matrix <em>Cx</em> into an equivalent matrix <em>Cxx</em>
for fitting it.
<em>Cx</em> is a <img class="math" src="_images/math/d87cb9d32bf68941207e822102899f34a2e64732.png" alt="ngeo*6*6"/> matrix, each <em>Cx[i]</em> is the 6*6 <em>C</em> matrix for a given geometry ( <em>i</em> )
<em>Cxx</em> is a Lmath:<cite>6*6*ngeo</cite> matrix, each <em>Cxx[i][j]</em> is a vector with all values for different
geometries of the <em>Cij</em> elastic constant matrix element. For example, <em>Cxx[0,0]</em>
is the vector with ngeo values of the <em>C11</em> elastic constant and so on.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitEtot">
<span id="pyqha-fitetot-module"></span><h2>pyqha.fitEtot module<a class="headerlink" href="#module-pyqha.fitEtot" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtot</code><span class="sig-paren">(</span><em>fin</em>, <em>out=True</em>, <em>ibrav=4</em>, <em>fittype='quadratic'</em>, <em>guess=None</em>, <em>method='BFGS'</em>, <em>minoptions={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtot"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function reads the file <em>fin</em> containing the energies as a function
of the lattice parameters <img class="math" src="_images/math/4a2cd023907894f80fe62bbfe347513bc4954331.png" alt="E(a,b,c)"/> and fits them with a quartic (<em>fittype=&#8221;quartic&#8221;</em>) or 
quadratic (<em>fittype=&#8221;quadratic&#8221;</em>) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redirected to <em>stdout</em>)
if <em>out=True</em>.
It returns the lattice parameters and energies as in the input file <em>fin</em>,
the fitted coefficients of the polynomial, the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>,
the lattice parameters at the minimum and the minimun energy.</p>
<p>Note: for cubic systems use fitEtotV instead.</p>
<p>Advanced input parameters:</p>
<p><em>guess</em>, an initial guess for the minimization. It is a 6 elements list 
[a,b,c,0,0,0].</p>
<p><em>method</em>, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details.</p>
<p><em>minoptions</em>, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtotV</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtotV"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function reads <img class="math" src="_images/math/7d28b83e95abf8aa59bcd91638cd7497b0045c5f.png" alt="E(V)"/> data from the input file <em>fin</em>, fits them with a Murnaghan EOS,
prints the results on the <em>stdout</em> and write them in the file &#8220;fout&#8221;.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitFvib">
<span id="pyqha-fitfvib-module"></span><h2>pyqha.fitFvib module<a class="headerlink" href="#module-pyqha.fitFvib" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvib</code><span class="sig-paren">(</span><em>fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], method='BFGS', minoptions={}, splinesoptions=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvib"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/1883c3f030ec103c67e7fb6fb02fa7b0a39aacf7.png" alt="F_{vib}(a,b,c,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in <em>fin</em> file. The 
real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>The function fits <img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> with a quadratic
or quartic polynomial (as defined by <em>typeEtot</em> and <em>typeFvib</em> ) at each
temperature in <em>thermodata</em> and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/>
and <img class="math" src="_images/math/50048175b5237f76e7863c156fa66afda1f1be9d.png" alt="F_{vib}(a,b,c)"/>. Then it computes the minimun energy <img class="math" src="_images/math/6fad90a8a0bf48bf469ab26edc21276d3b35748d.png" alt="E_{tot}+F_{vib}"/>
and the corresponding lattice parameters <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> 
at each temperature by miniimizing the energy.</p>
<p>It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_alpha()</span></code>).</p>
<p>It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> 
only (at T=0 K) and the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> at each temperature.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example6</em> and 
the tutorial.</p>
</div>
<p>Advanced input parameters:</p>
<p><em>guess</em>, an initial guess for the minimization. It is a 6 elements list 
[a,b,c,0,0,0].</p>
<p><em>method</em>, the method to be used in the minimization procedure, as in the
scipy.optimize.minimize. See its documentation for details. Note that the 
methods which usually gives better results for quasi-harmonic calculations
are the &#8220;BFGS&#8221; or Newton-CG&#8221;. Default is &#8220;BFGS&#8221;.</p>
<p><em>minoptions</em>, a dictionary with additional options for the minimization 
procedure, as in the scipy.optimize.minimize. See its documentation for details.
Note the the options are different for different methods.</p>
<p><em>splinesoptions</em>, determines whether to use or not splines to reduce the noise
on numerical derivatives (thermal expansions). If <em>splinesoptions*==None, use 
finete differences for derivatives, else use splines as implemented in
scipy.interpolate (see documentation). In the latter case, *splinesoptions</em>
must be a dictionary. This dictionary must contains the keywords <em>k0</em>, <em>s0</em>,
<em>k1</em>, <em>s1</em>, <em>k2</em>, <em>s2</em> which are passed to <code class="xref py py-func docutils literal"><span class="pre">scipy.interpolate.splrep()</span></code>, 
one couple for each set of thermal expansions (alpha_xx, alpha_yy, alpha_zz).
<em>k</em> is the order of the spline (default=3), s a smoothing condition (default=None).
If <em>splinesoptions=={}</em> use the default options of <code class="xref py py-func docutils literal"><span class="pre">scipy.interpolate.splrep()</span></code>
Note: use this option with care</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvibV</code><span class="sig-paren">(</span><em>fin</em>, <em>thermodata</em>, <em>verbosity='low'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvibV"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/1b43a9b9fc946c5e4302c3dd56be1b79358f3d66.png" alt="E_{tot}(V)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/b6911133133a6937356b958128d1e99cd4969b81.png" alt="F_{vib}(V,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in <em>fin</em> file.</p>
<p>The function fits <img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> with a Murnaghan&#8217;s EOS
at each temperature in <em>thermodata</em> and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_beta()</span></code>), the
constant volume heat capacity at the minimum volume at each T
(<code class="xref py py-func docutils literal"><span class="pre">compute_Cv()</span></code>) and the constant pression heat capacity (<code class="xref py py-func docutils literal"><span class="pre">compute_Cp()</span></code>).</p>
<p>It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> at each T.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example5</em> and 
the tutorial.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyqha.alphagruneisenp">
<span id="pyqha-alphagruneisenp-module"></span><h2>pyqha.alphagruneisenp module<a class="headerlink" href="#module-pyqha.alphagruneisenp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.alphagruneisenp.c_qv">
<code class="descclassname">pyqha.alphagruneisenp.</code><code class="descname">c_qv</code><span class="sig-paren">(</span><em>T</em>, <em>omega</em><span class="sig-paren">)</span><a class="headerlink" href="#pyqha.alphagruneisenp.c_qv" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the mode contribution to the heat capacity at a given T
and omega. A similar (faster) function should be available as C extension.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.alphagruneisenp.c_qv2">
<code class="descclassname">pyqha.alphagruneisenp.</code><code class="descname">c_qv2</code><span class="sig-paren">(</span><em>T</em>, <em>omega</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/alphagruneisenp.html#c_qv2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.alphagruneisenp.c_qv2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.alphagruneisenp.c_qv_python">
<code class="descclassname">pyqha.alphagruneisenp.</code><code class="descname">c_qv_python</code><span class="sig-paren">(</span><em>T</em>, <em>omega</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/alphagruneisenp.html#c_qv_python"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.alphagruneisenp.c_qv_python" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the mode contribution to the heat capacity at a given T
and omega. A similar (faster) function should be available as C extension.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.alphagruneisenp.compute_alpha_grun">
<code class="descclassname">pyqha.alphagruneisenp.</code><code class="descname">compute_alpha_grun</code><span class="sig-paren">(</span><em>T</em>, <em>V</em>, <em>S</em>, <em>weights</em>, <em>freq</em>, <em>grun</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/alphagruneisenp.html#compute_alpha_grun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.alphagruneisenp.compute_alpha_grun" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the thermal expansions alpha using the Gruneisein 
parameters at a given temperature <em>T</em>. <em>V</em> is the unit cell volume, <em>S</em> is
the elastic compliances matrix in Voigt notation, <em>freq</em> and <em>weights</em>  are
the phonon frequencies in a grid of q-point and their corresponding weights.
<em>grun</em> are the Gruneisen parameters. <em>ibrav</em> identifies the Bravais lattice.</p>
<p>It implements the following equation:</p>
<p>:math:``</p>
<p>more comments to be added</p>
<p>First with min0, freq and grun T-independent</p>
<p>More ibrav types to be implemented</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.alphagruneisenp.compute_alpha_gruneisein">
<code class="descclassname">pyqha.alphagruneisenp.</code><code class="descname">compute_alpha_gruneisein</code><span class="sig-paren">(</span><em>TT</em>, <em>ibrav</em>, <em>celldmsx</em>, <em>min0=None</em>, <em>S=None</em>, <em>weights=None</em>, <em>freq=None</em>, <em>grun=None</em>, <em>minT=None</em>, <em>afreq=None</em>, <em>fittypefreq=None</em>, <em>aS=None</em>, <em>fittypeS=None</em>, <em>nproc=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/alphagruneisenp.html#compute_alpha_gruneisein"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.alphagruneisenp.compute_alpha_gruneisein" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the thermal expansions at different temperatures from
the Gruneisen parameters and other parameters.</p>
<p><em>TT</em> is a numpy array of temperatures for which the thermal expansions are
computed. <em>ibrav</em> identifies the Bravais lattice. <em>celldmsx</em> contains the lattice
parameters of the computed grid <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> as read with <code class="xref py py-func docutils literal"><span class="pre">read_Etot()</span></code>.
Different calculation options are possible, according to the optional 
input parameters given in input:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Input parameters</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>min0,S,weights,freq,grun</em></td>
<td>Use temperarature-independent (0 K) volume, elastic compliances,
average frequencies and Gruneisen parameters. The volume is obtained
from <em>min0</em>, the lattice parameters at the minimun 0 K energy. <em>S</em> is
the elastic compliances tensor at 0 K calculated at <em>min0</em>. <em>weights</em>
,*freq*,*grun* are the weights, phonon frequencies and Gruneisen
parameters at 0 K calculated at <em>min0</em>.</td>
</tr>
<tr class="row-odd"><td><em>S,weights,minT,afreq,fittypefreq</em></td>
<td>Use temperarature-independent (0 K) elastic compliances but
temperature-dependent volume, average frequencies and Gruneisen
parameters. The volume is obtained from <em>minT</em>, a numpy array with
the lattice parameters at the minimun free energy at each temperature
. <em>S</em> is the elastic compliances tensor at 0 K calculated at <em>min0</em>.
<em>weights</em> are the weights of the phonon frequencies.  <em>afreq</em>,
<em>fittypefreq</em> are the coefficients of the fitted polynomials for the
phonon frequencies and the type of polynomial. They are used here to
compute the average frequencies and Gruneisen parameters at each
temperature.</td>
</tr>
<tr class="row-even"><td><em>weights,afreq,fittypefreq,aS,fittypeS</em></td>
<td><blockquote class="first">
<div>Use temperarature-dependent (0 K) volume, elastic compliances,
average frequencies and Gruneisen parameters. The volume is obtained
from <em>minT</em>, a numpy array with the lattice parameters at the minimun
free energy at each temperature. <em>weights</em> are the weights of the
phonon frequencies. <em>afreq</em>,
<em>fittypefreq</em> are the coefficients of the fitted polynomials for the
phonon frequencies and the type of polynomial. They are used here to
the average frequencies and Gruneisen parameters at each temperature.
<em>aS,fittypeS</em> are the coefficients of the fitted polynomials for the
elastic compliances and the polynomial type. They are used here to
compute the elastic compliances at each temperature as in the quasi-s</div></blockquote>
<p class="last">tatic approximation.</p>
</td>
</tr>
</tbody>
</table>
<p>By default, all the input parameters in the above table are ==None and if nothing
is given in input the function will return None without computing anything.</p>
<p><em>nproc</em> is the number of processes to be run in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.alphagruneisenp.compute_alpha_gruneisen_loopparallel">
<code class="descclassname">pyqha.alphagruneisenp.</code><code class="descname">compute_alpha_gruneisen_loopparallel</code><span class="sig-paren">(</span><em>it</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/alphagruneisenp.html#compute_alpha_gruneisen_loopparallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.alphagruneisenp.compute_alpha_gruneisen_loopparallel" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements the parallel loop where the alpha are computed. It  
essentially calls the compute_alpha_grun function with the proper parameters
according to the selected option. &#8220;it&#8221; is a list with all function parameters
for the call in pool.map</p>
<p>it[0]== 0 -&gt; use V, S, average frequencies and gruneisen parameters at 0 K 
it[0]== 1 -&gt; use S at 0 K, calculate V, average frequencies and gruneisen parameters at each T 
it[0]== 2 -&gt;  calculate S, V, average frequencies and gruneisen parameters at each T</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.alphagruneisenp.join">
<code class="descclassname">pyqha.alphagruneisenp.</code><code class="descname">join</code><span class="sig-paren">(</span><em>partials</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/alphagruneisenp.html#join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.alphagruneisenp.join" title="Permalink to this definition">¶</a></dt>
<dd><p>This function simply puts together the different temperature ranges where alpha
was calculated in parallel into a single numpy array</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitfreqgrun">
<span id="pyqha-fitfreqgrun-module"></span><h2>pyqha.fitfreqgrun module<a class="headerlink" href="#module-pyqha.fitfreqgrun" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.fitfreqgrun.fitfreq">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">fitfreq</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>min0</em>, <em>filefreq</em>, <em>ibrav=4</em>, <em>typefreq='quadratic'</em>, <em>compute_grun=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#fitfreq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.fitfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function for fitting the frequencies.</p>
<p><em>celldmsx</em> is the matrix of lattice parameters <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> where the total
energies where computed. <em>min0</em> is the a set of <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>. <em>filefreq</em>
defines the input files (<em>filefreq1</em>, <em>filefreq2</em>, etc.) containing the 
frequencies for different geometries. The number of geometries is determined
from the size of <em>celldmsx</em>. <em>ibrav</em> is the usual Bravais lattice. 
<em>typefreq</em> can be &#8220;quadratic&#8221; (default) or &#8220;quartic&#8221;, i.e. the kind of 
polynomial to be used for fitting. <em>compute_grun</em> defines if the Gruneisen
parameters must be calculated (True) or not (False, default).</p>
<p>It returns a matrix of <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> frequencies obtained for the fitted 
polynomial coefficients (quadratic or quartic) at the 
minimun point <em>min0</em>. It also returns the weigths of each q-point where the 
frequencies are available.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.fitfreqxx">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">fitfreqxx</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>freqxx</em>, <em>ibrav</em>, <em>out</em>, <em>typefreq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#fitfreqxx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.fitfreqxx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function fits the frequencies in freqxx as a function of the
grid of lattice parameters <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>.</p>
<p>It returns a <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> matrix, whose element [i,j] is the set of coefficients of the 
polynomial fit and another <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> matrix, whose element [i,j] is the corresponding
<img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>. If the <img class="math" src="_images/math/16120330347af8c5298e190c52e64265abe76b6a.png" alt="\chi^2=0"/>, the fitting procedure was NOT succesful</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.freqmin">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">freqmin</code><span class="sig-paren">(</span><em>afreq</em>, <em>min0</em>, <em>nq</em>, <em>modes</em>, <em>ibrav</em>, <em>typefreq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#freqmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.freqmin" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the frequencies from the fitted polynomials coeffients (one
for each q point and mode) at the minimun point <em>min0</em> given in input. 
<em>afreq</em> is a <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> numpy matrix containing the fitted polynomial coefficients.
It can be obtained from <a class="reference internal" href="#pyqha.fitfreqgrun.fitfreqxx" title="pyqha.fitfreqgrun.fitfreqxx"><code class="xref py py-func docutils literal"><span class="pre">fitfreqxx()</span></code></a>.</p>
<p>It returns a <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> matrix, each element [i,j] being the fitted frequency</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.freqmingrun">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">freqmingrun</code><span class="sig-paren">(</span><em>afreq</em>, <em>min0</em>, <em>nq</em>, <em>modes</em>, <em>ibrav</em>, <em>typefreq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#freqmingrun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.freqmingrun" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the frequencies and the Gruneisen parameters
from the fitted polynomials coeffients (one
for each q point and mode) at the minimun point <em>min0</em> given in input. 
<em>afreq</em> is a <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> numpy matrix containing the fitted polynomial coefficients.
It can be obtained from <a class="reference internal" href="#pyqha.fitfreqgrun.fitfreqxx" title="pyqha.fitfreqgrun.fitfreqxx"><code class="xref py py-func docutils literal"><span class="pre">fitfreqxx()</span></code></a>.</p>
<p>It returns a <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> matrix, each element [i,j] being the fitted frequency 
In addition, it returns a <img class="math" src="_images/math/6c76511fdaaf3b2aa8122c156052cbd9f543bcaa.png" alt="nq*modes*6"/> with the Gruneisein parameters.
Each element [i,j,k] is the the Gruneisein parameter at <em>nq=i</em>, <em>mode=j</em> and direction
<em>k</em> (for example, in hex systems <em>k=0</em> is <em>a</em> direction, <em>k=2</em> is <em>c</em> direction, others are zero)</p>
<p>Note that the Gruneisein parameters are not multiplied for the lattice parameters.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.rearrange_freqx">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">rearrange_freqx</code><span class="sig-paren">(</span><em>freqx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#rearrange_freqx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.rearrange_freqx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function rearranges the input numpy matrix <em>freqx</em> into an equivalent 
matrix <em>freqxx</em> for the subsequent fitting.
<em>freqx</em> is a <img class="math" src="_images/math/9976af8adbcafa865a36c71e69f2f8a5bc235d39.png" alt="ngeo*nq*modes"/> matrix, each <em>freqx[i]</em> is the <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/>
frequency matrix for a given geometry <em>i</em>.
freqxx is a <img class="math" src="_images/math/f125b6381f3c495dd47f4b8fcd7bee7b8eb39843.png" alt="nq*modes*ngeo"/> matrix, each <em>freqxx[i,j]</em> is a vector with
all values for different geometries of the frequencies at point <em>q=i</em> and <em>mode=j</em>.
For example, <em>freqxx[0,0]</em> is the vector with ngeo values of the frequencies
at the first q-point and first mode so on.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitutils">
<span id="pyqha-fitutils-module"></span><h2>pyqha.fitutils module<a class="headerlink" href="#module-pyqha.fitutils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.fitutils.expand_quadratic_to_quartic">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">expand_quadratic_to_quartic</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#expand_quadratic_to_quartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.expand_quadratic_to_quartic" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a vector of coefficients from a quadratic fit and turns it
into a vector of coeffients as from a quartic fit (extra coeffients are set to zero).</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.fit_anis">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">fit_anis</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Ex</em>, <em>ibrav=1</em>, <em>out=False</em>, <em>type='quadratic'</em>, <em>ylabel='Etot'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#fit_anis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.fit_anis" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function for handling fitting in the anisotropic case</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.fit_quadratic">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">fit_quadratic</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>ibrav=4</em>, <em>out=False</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#fit_quadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.fit_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for fitting with a quadratic polynomial</p>
<p>The most general fitting multidimensional quadratic polynomial for a triclinic
system is:
a1 + a2 x1 + a3 x1^2 + a4  x2 + a5  x2^2 + a6 x1*x2 +    
+ a7  x3 + a8  x3^2 + a9  x1*x3 + a10 x2*x3 +         
+ a11 x4 + a12 x4^2 + a13 x1*x4 + a14 x2*x4 + a15 x3*x4 +        
+ a16 x5 + a17 x5^2 + a18 x1*x5 + a19 x2*x5 + a20 x3*x5 + a21 x4*x5 
+ a22 x6 + a23 x6^2 + a24 x1*x6 + a25 x2*x6 + a26 x3*x6 + a27 x4*x6 + a28 x5*x6</p>
<p>ONLY THE HEXAGONAL AND GENERAL CASE ARE IMPLEMENTED, more to be done</p>
<p>The input variable x is a matrix ngeo*6, where
x[:,0] is the set of a values  
x[:,1] is the set of b values  
x[:,2] is the set of c values  
x[:,3] is the set of alpha values  
x[:,4] is the set of beta values   
x[:,5] is the set of gamma values</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.fit_quartic">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">fit_quartic</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>ibrav=4</em>, <em>out=False</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#fit_quartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.fit_quartic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for fitting with a quartic polynomial</p>
<p>The most general fitting multidimensional quadratic polynomial for a triclinic
system is:</p>
<p>ONLY THE HEXAGONAL CASE IS IMPLEMENTED, more to be done</p>
<p>The input variable x is a matrix ngeo*6, where
x[:,0] is the set of a values  
x[:,1] is the set of b values  
x[:,2] is the set of c or c/a values  
x[:,3] is the set of alpha values  
x[:,4] is the set of beta values   
x[:,5] is the set of gamma values</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.print_data">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">print_data</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>results</em>, <em>A</em>, <em>ibrav</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#print_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.print_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prints the data and the fitted results 
ylabel can be &#8220;E&#8221;, &#8220;Fvib&#8221;, &#8220;Cxx&#8221;, etc. so that can be used for different
fitted quantities</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.print_polynomial">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">print_polynomial</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#print_polynomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.print_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prints the fitted polynomial, either quartic or quadratic</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.minutils">
<span id="pyqha-minutils-module"></span><h2>pyqha.minutils module<a class="headerlink" href="#module-pyqha.minutils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.minutils.calculate_fitted_points_anis">
<code class="descclassname">pyqha.minutils.</code><code class="descname">calculate_fitted_points_anis</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>nmesh</em>, <em>fittype='quadratic'</em>, <em>ibrav=4</em>, <em>a=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#calculate_fitted_points_anis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.calculate_fitted_points_anis" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a denser mesh of Efitted(celldmsx) points for plotting. nmesh = (nx,ny,nz)
gives the dimensions of the mesh.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.contract_vector">
<code class="descclassname">pyqha.minutils.</code><code class="descname">contract_vector</code><span class="sig-paren">(</span><em>x</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#contract_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.contract_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function: contract a vector x, len(x)=6, into a x-dim vector (x&lt;6) 
according to ibrav
Note: not all ibrav are implemented yet</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.expand_vector">
<code class="descclassname">pyqha.minutils.</code><code class="descname">expand_vector</code><span class="sig-paren">(</span><em>x</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#expand_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.expand_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function: expands a vector x, len(x)&lt;6, into a 6-dim vector according
to ibrav
Note: not all ibrav are implemented yet</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.find_min">
<code class="descclassname">pyqha.minutils.</code><code class="descname">find_min</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav</em>, <em>type</em>, <em>guess=None</em>, <em>method='BFGS'</em>, <em>minoptions={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#find_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.find_min" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function for handling the minimum search</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.find_min_quadratic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">find_min_quadratic</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav</em>, <em>guess</em>, <em>method</em>, <em>minoptions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#find_min_quadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.find_min_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for finding the minimum of the quadratic polynomial</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.find_min_quartic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">find_min_quartic</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav</em>, <em>guess</em>, <em>method</em>, <em>minoptions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#find_min_quartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.find_min_quartic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for finding the minimum of the quartic polynomial</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquadratic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquadratic</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Implemented polynomials for fitting and miminizing</p>
<p>only ibrav=4 and the most general case are implemented for now</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquadratic_der">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquadratic_der</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquadratic_der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquadratic_der" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquartic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquartic</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquartic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquartic_der">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquartic_der</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquartic_der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquartic_der" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyqha.plotutils">
<span id="pyqha-plotutils-module"></span><h2>pyqha.plotutils module<a class="headerlink" href="#module-pyqha.plotutils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.plotutils.multiple_plot_xy">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">multiple_plot_xy</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>xlabel=''</em>, <em>ylabel=''</em>, <em>labels=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#multiple_plot_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.multiple_plot_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a simple xy plot with matplotlib overlapping several
lines as in the matrix y. y second index refers to a line in the plot, the first 
index is for the array to be plotted.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.plot_EV">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">plot_EV</code><span class="sig-paren">(</span><em>V</em>, <em>E</em>, <em>a=None</em>, <em>labely='Etot'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#plot_EV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.plot_EV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function plots with matplotlib E(V) data and if a is given it also plot
the fitted results</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.plot_Etot">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">plot_Etot</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Ex</em>, <em>n</em>, <em>nmesh=(50</em>, <em>50</em>, <em>50)</em>, <em>fittype='quadratic'</em>, <em>ibrav=4</em>, <em>a=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#plot_Etot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.plot_Etot" title="Permalink to this definition">¶</a></dt>
<dd><p>This function makes a 3D plot with matplotlib Ex(celldmsx) data and if a is given it also plot
the fitted results. The plot type depends on ibrav.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.plot_Etot_contour">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">plot_Etot_contour</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>nmesh=(50</em>, <em>50</em>, <em>50)</em>, <em>fittype='quadratic'</em>, <em>ibrav=4</em>, <em>a=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#plot_Etot_contour"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.plot_Etot_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>This function makes a countour plot with matplotlib of Ex(celldmsx) fitted results. 
The plot type depends on ibrav.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.simple_plot_xy">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">simple_plot_xy</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>xlabel=''</em>, <em>ylabel=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#simple_plot_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.simple_plot_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a simple xy plot with matplotlib.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.properties_anis">
<span id="pyqha-properties-anis-module"></span><h2>pyqha.properties_anis module<a class="headerlink" href="#module-pyqha.properties_anis" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.properties_anis.compute_Ceps">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_Ceps</code><span class="sig-paren">(</span><em>min0</em>, <em>celldmsx</em>, <em>T</em>, <em>Cvib</em>, <em>ibrav=4</em>, <em>typeCvib='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_Ceps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_Ceps" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the constant strain heat capacity <img class="math" src="_images/math/ee29b3ad0e4252ec431d0c2ef077fdcefc108abb.png" alt="C_{\epsilon}"/>
as a function of temperature. 
By definition <img class="math" src="_images/math/038d251a0746c17a0d1cfbc315be3ce66082fd28.png" alt="C_{\epsilon} = -T(dS/dT)_{\epsilon}=-T(d^2F/dT^2)_{\epsilon}"/>. 
To avoid the numerical derivation, within the quasi-harmonic
approximation it is better to derive it from fitting the harmonic heat capacities
results on the grid <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> at the equilibrium lattic parameters given
in <em>min0</em>. <em>celldms</em> is the grid <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>, <em>Cvib</em> are the harmonic 
heat capacity on the grid.
The procedure is the same as the for the <img class="math" src="_images/math/6fad90a8a0bf48bf469ab26edc21276d3b35748d.png" alt="E_{tot}+F_{vib}"/> in the quasi-harmonic
calculation but without the minimization step.</p>
<p>Note: a better way would be to do a full harmonic calculation at exactly <em>min0</em>.
The difference with the above way is usually negligible.</p>
<p><strong>Important</strong>: the above procedure relies on the quasi-harmonic approximation,
i.e. on the fact that anharmonic contribution are only due to the change of
phonon frequencies with the lattice parameters. In reality, this is not the 
case and the entropy so obtained can only be taken as an approximation of the
real one.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_Csigma">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_Csigma</code><span class="sig-paren">(</span><em>min0</em>, <em>celldmsx</em>, <em>T</em>, <em>Cvib</em>, <em>ibrav=4</em>, <em>typeCvib='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_Csigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_Csigma" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the constant strain heat capacity <img class="math" src="_images/math/51da4686722e2c5d315b23d1e7a76a826fde1ac3.png" alt="C_{\sigma}"/>
as a function of temperature. 
By definition <img class="math" src="_images/math/b578189d5a7282d475e8b7a5f70f9940d810b112.png" alt="C_{\sigma} = -T(dS/dT)_{\sigma}=-T(d^2F/dT^2)_{\epsilon,\sigma}"/>. 
To avoid the numerical derivation, within the quasi-harmonic
approximation it is better to derive it from fitting the harmonic heat capacities
results on the grid <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> at the equilibrium lattic parameters given
in <em>min0</em>. <em>celldms</em> is the grid <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>, <em>Cvib</em> are the harmonic 
heat capacity on the grid.
The procedure is the same as the for the <img class="math" src="_images/math/6fad90a8a0bf48bf469ab26edc21276d3b35748d.png" alt="E_{tot}+F_{vib}"/> in the quasi-harmonic
calculation but without the minimization step.</p>
<p>Note: a better way would be to do a full harmonic calculation at exactly <em>min0</em>.
The difference with the above way is usually negligible.</p>
<p><strong>Important</strong>: the above procedure relies on the quasi-harmonic approximation,
i.e. on the fact that anharmonic contribution are only due to the change of
phonon frequencies with the lattice parameters. In reality, this is not the 
case and the entropy so obtained can only be taken as an approximation of the
real one.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_S">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_S</code><span class="sig-paren">(</span><em>min0</em>, <em>celldmsx</em>, <em>T</em>, <em>Svib</em>, <em>ibrav=4</em>, <em>typeSvib='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_S" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the entropy as a function of temperature. By definition
<img class="math" src="_images/math/166f4b7b66c208378be1ee04c19977c94c9e2e28.png" alt="S = -(dF/dT)_{\epsilon}"/>. To avoid the numerical derivation, within the quasi-harmonic
approximation it is better to derive it from fitting the harmonic entropy
results on the grid <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> at the equilibrium lattic parameters given
in <em>min0</em>. <em>celldms</em> is the grid <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>, <em>Svib</em> are the harmonic 
entropies on the grid.
The procedure is the same as the for the <img class="math" src="_images/math/6fad90a8a0bf48bf469ab26edc21276d3b35748d.png" alt="E_{tot}+F_{vib}"/> in the quasi-harmonic
calculation but without the minimization step.</p>
<p>Note: a better way would be to do a full harmonic calculation at exactly <em>min0</em>.
The difference with the above way is usually negligible.</p>
<p><strong>Important</strong>: the above procedure relies on the quasi-harmonic approximation,
i.e. on the fact that anharmonic contribution are only due to the change of
phonon frequencies with the lattice parameters. In reality, this is not the 
case and the entropy so obtained can only be taken as an approximation of the
real one.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_alpha">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_alpha</code><span class="sig-paren">(</span><em>minT</em>, <em>ibrav</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the thermal expansion alphaT at different temperatures
from the input minT matrix by computing the numerical derivatives with numpy.
The input matrix minT has shape nT*6, where the first index is the temperature 
and the second the lattice parameter. For example, minT[i,0] and minT[i,2] are
the lattice parameters a and c at the temperature i.</p>
<p>More ibrav types must be implemented</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_alpha_splines">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_alpha_splines</code><span class="sig-paren">(</span><em>TT</em>, <em>minT</em>, <em>ibrav</em>, <em>splinesoptions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_alpha_splines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_alpha_splines" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the thermal expansions alphaT at different temperatures
as the previous function but using spline interpolation as implemented in
scipy.interpolate.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_heat_capacity">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_heat_capacity</code><span class="sig-paren">(</span><em>TT</em>, <em>minT</em>, <em>alphaT</em>, <em>C</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_heat_capacity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_heat_capacity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the difference between the constant stress heat capacity
C_sigma and the constant strain heat capacity C_epsilon from the V, the thermal
expansions and the elastic constant tensor C</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_volume">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_volume</code><span class="sig-paren">(</span><em>celldms</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the volume given the <em>celldms</em>. Only for ibrav=4 for now, else 
returns 0.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.read">
<span id="pyqha-read-module"></span><h2>pyqha.read module<a class="headerlink" href="#module-pyqha.read" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.read.read_Etot">
<code class="descclassname">pyqha.read.</code><code class="descname">read_Etot</code><span class="sig-paren">(</span><em>fname</em>, <em>ibrav=4</em>, <em>bc_as_a_ratio=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_Etot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_Etot" title="Permalink to this definition">¶</a></dt>
<dd><p>Read cell parameters <em>(a,b,c)</em> and the corresponding energies from input file <em>fname</em>. 
Each set of cell parameters is stored in a numpy array of lenght 6 
for <em>(a,b,c,alpha,beta,gamma)</em> respectively. This is done for a future possible 
extension but for now only the first 3 elements are used (the others are always 0).
All sets are stored in <em>celldmsx</em> and <em>Ex</em>, the former is a nE*6 matrix, 
the latter is a nE array.</p>
<p><em>ibrav</em> identifies the Bravais lattice as in Quantum Espresso and is needed 
in input (default is 4, i.e. hexagonal cell). The input file format depends
on <em>ibrav</em>, for example in the hex case, the first two columns are for <em>a</em> and
<em>c</em> and the third is for the energies.</p>
<p>If <em>bc_as_a_ratio=True</em>, the input data are assumed to be given as 
<img class="math" src="_images/math/6feb653eb0c50d525d449bc1145229e56ee50dc6.png" alt="(a,b/a,c/a)"/> in the input file and hence converted into <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>
which is how they are always stored internally in <code class="xref py py-mod docutils literal"><span class="pre">pyqha</span></code>.</p>
<p>Units must be <img class="math" src="_images/math/d935fd0b17b6d0138bea48d11efd237fba1a7468.png" alt="a.u."/> and <img class="math" src="_images/math/f66ef80fce797aaa395a5db0d9139dc35c1c6b41.png" alt="Ryd/cell"/></p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_EtotV">
<code class="descclassname">pyqha.read.</code><code class="descname">read_EtotV</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_EtotV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_EtotV" title="Permalink to this definition">¶</a></dt>
<dd><p>Read cell volumes and the corresponding energies from input file <em>fname</em>
(1st col, volumes, 2nd col energies). Units must be <img class="math" src="_images/math/2992e67f1f6a95b9e595c21733afd4498b8aa5b8.png" alt="a.u.^3"/> and 
<img class="math" src="_images/math/f66ef80fce797aaa395a5db0d9139dc35c1c6b41.png" alt="Ryd/cell"/></p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_alpha">
<code class="descclassname">pyqha.read.</code><code class="descname">read_alpha</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.read.read_celldmt_hex">
<code class="descclassname">pyqha.read.</code><code class="descname">read_celldmt_hex</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_celldmt_hex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_celldmt_hex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.read.read_dos">
<code class="descclassname">pyqha.read.</code><code class="descname">read_dos</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_dos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_dos" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the phonon density of states (y axis) and the corresponding energies (x axis)
from the input file <em>filename</em> (1st col energies, 2nd col DOS) and store it
in two numpy arrays which are returned.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_dos_geo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_dos_geo</code><span class="sig-paren">(</span><em>fin</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_dos_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_dos_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the phonon density of states and energies as in <a class="reference internal" href="#pyqha.read.read_dos" title="pyqha.read.read_dos"><code class="xref py py-func docutils literal"><span class="pre">read_dos()</span></code></a> from <em>ngeo</em> input files
<em>fin1</em>, <em>fin2</em>, etc. and store it in two numpy matrices which are returned.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_elastic_constants">
<code class="descclassname">pyqha.read.</code><code class="descname">read_elastic_constants</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_elastic_constants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_elastic_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads and returns the elastic constants and compliances from
the file <em>fname</em> .
Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape [6,6]
So, the elastic constant C11 is in C[0,0], C12 in C[0,1] and so on.
Same for the elastic compliances.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_elastic_constants_geo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_elastic_constants_geo</code><span class="sig-paren">(</span><em>fC</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_elastic_constants_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_elastic_constants_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read elastic constants calculated on a multidimensional grid of lattice parameters
<em>ngeo</em> defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the phonon frequencies at each q point from a frequency file <em>fname</em>.
The format of this file is different from the one read by the <a class="reference internal" href="#pyqha.read.read_freq" title="pyqha.read.read_freq"><code class="xref py py-func docutils literal"><span class="pre">read_freq()</span></code></a> and
contains usually more frequencies, each with a weight, but no q-point coordinates.</p>
<p>The input frequency file is expected to have the following format:
1st line contains the number of atoms in the unit cell, the q-point grid 
<img class="math" src="_images/math/e55cf04e9e01b9770168b3ac814ea35fc873940b.png" alt="(nqx, nqy, nqz)"/> and the total number of q-points listed <em>nq</em>.
2nd line not read.   
For the 3rd line on, the following scheme is repeated:
1st line: the <em>weight</em> of the q-point (they can be different because of simmetry)
n modes lines, each with the corresponding phonon frequency</p>
<p>Returning values are a <em>nq</em> vector of weights, each <em>weights[i]</em> being the weight of given q-point 
and a <img class="math" src="_images/math/ae1c094bfe793cbfa6cddab702f3ba102011da57.png" alt="nq*modes"/> matrix <em>freq</em>, each element <em>freq[i]</em> being the phonon frequencies
(vector of modes elements) at the q-point <em>i</em></p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq_geo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq_geo</code><span class="sig-paren">(</span><em>fname</em>, <em>ngeo=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the frequencies as in <a class="reference internal" href="#pyqha.read.read_freq" title="pyqha.read.read_freq"><code class="xref py py-func docutils literal"><span class="pre">read_freq()</span></code></a> but for <em>ngeo</em> geometries.
Input files are <em>fname1</em>, <em>fname2</em>, <em>fname3</em>, etc.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq_geo_old">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq_geo_old</code><span class="sig-paren">(</span><em>inputfilefreq</em>, <em>rangegeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq_geo_old"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq_geo_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the frequencies for all geometries where the gruneisen parameters must be
calculated. Start, stop, step must be given accordingly. It can be used to read
the frequencies only at some geometries from a larger set, if necessary, 
providing the proper start, stop and step values.</p>
<p>Notes:
nq = qgeo.shape[1] -&gt; total number of q points read
modes = freqgeo.shape[2] -&gt; number of frequency modes</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq_old">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq_old</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq_old"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq_old" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads the phonon frequencies at each q-point from a frequency file.  
Input file has the following format (to be done).</p>
<p>Returning values are a nq*3 matrix q, each q[i] being a q point (vector of 3 elements)
and a nq*modes matrix freq, each element freq[i] being the phonon frequencies
(vector of modes elements)</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_thermo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_thermo</code><span class="sig-paren">(</span><em>fname</em>, <em>ngeo=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read vibrational thermodynamic functions (Evib, Fvib, Svib, Cvib) as a 
function of temperature from the input file <em>fname</em>. <em>ngeo</em> is the number
of input files to read, corresponding for example to different geometries
in a quasi-harmonic calculation.
If <em>ngeo&gt;1</em> reads from the files <em>fname1</em>, <em>fname2</em>, etc. up to <em>ngeo</em>  
Input file(s) have the following format:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">T</th>
<th class="head"><img class="math" src="_images/math/9fbdb84aec610808b553f187fc1ac99b95993006.png" alt="E_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/55b3ed38f962644f1072ee6a112740f24b78ed7b.png" alt="F_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/1ec0b0b14b11bd65993b7ac59a1fa3b78e78688c.png" alt="S_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/03ba745362038f7a468482e89419d50637d84353.png" alt="C_{vib}"/></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>Lines starting with &#8220;#&#8221; are not read (comments).</p>
<p>Returning values are <img class="math" src="_images/math/368f789921bf6861b596ea6ff0b6d4ca99ad5d5e.png" alt="nT*ngeo"/> numpy matrices (T,Evib,Fvib,Svib,Cvib) containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib[T,geo] -&gt; Fvib at the temperature <em>T</em> for the geometry <em>geo</em></p>
<p>Units must be <em>K</em> for temperature, <em>Ryd/cell</em> for energies, <em>Ryd/cell/K</em> for
entropy and heat capacity.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.thermo">
<span id="pyqha-thermo-module"></span><h2>pyqha.thermo module<a class="headerlink" href="#module-pyqha.thermo" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>TT</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays <em>E</em> 
and <em>dos</em> containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array <em>TT</em>.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to <img class="math" src="_images/math/7fd84257c87ff8dc9ee27bd300875a6bdc8e2161.png" alt="3*N"/>, with <em>N</em> the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo_geo</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em>, <em>ngeo=1</em>, <em>TT=array([1])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo_geo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function reads the input dos file(s) from <em>fin+i</em>, with <em>i</em> a number from
1 to <em>ngeo</em> + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">T</th>
<th class="head"><img class="math" src="_images/math/9fbdb84aec610808b553f187fc1ac99b95993006.png" alt="E_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/55b3ed38f962644f1072ee6a112740f24b78ed7b.png" alt="F_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/1ec0b0b14b11bd65993b7ac59a1fa3b78e78688c.png" alt="S_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/03ba745362038f7a468482e89419d50637d84353.png" alt="C_{vib}"/></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>and are names <em>fout</em> +1, <em>fout</em> +2,... for each geometry.</p>
<p>Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib[T,geo] -&gt; Fvib at the temperature &#8220;T&#8221; for the geometry &#8220;geo&#8221;</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">dos_integral</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>m=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#dos_integral"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>A function to compute the integral of an input phonon DOS (<em>dos</em>) with the 3/8 Simpson method.
<em>m</em> is the moment of the integral, if <img class="math" src="_images/math/9fe942a3b863852d1099e24ee69ed6068dce0933.png" alt="m&gt;0"/> different moments can be calculated.
For example, with <img class="math" src="_images/math/57e7fcd1e7c250f9afe8510738fcc25150cd46f8.png" alt="m=0"/> (default) it returns the number of modes from the dos, 
with <img class="math" src="_images/math/59c39884c40bf8420da99bdbc1f350c83b9acf63.png" alt="m=1"/> it returns the ZPE. The input energy (<em>E</em>) and phonon DOS (<em>dos</em>) are expected to be in
<img class="math" src="_images/math/8ef74976bf2a6e3a7790f40f153ad625f3fb9d60.png" alt="cm^{-1}"/>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">gen_TT</code><span class="sig-paren">(</span><em>Tstart=1</em>, <em>Tend=1000</em>, <em>Tstep=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#gen_TT"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>A simple function to generate a numpy array of temperatures, starting from
<em>Tstart</em> and ending to <em>Tend</em> (or the closest <em>T&lt;Tend</em> accorinding to the <em>Tstep</em> )
with step <em>Tstep</em> .</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">rearrange_thermo</code><span class="sig-paren">(</span><em>T</em>, <em>Evib</em>, <em>Fvib</em>, <em>Svib</em>, <em>Cvib</em>, <em>ngeo=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#rearrange_thermo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices <em>X</em> now gives all geometries at a given
<em>T</em>, i.e. <em>X[0]</em> is the vector of the property <em>X</em> a <em>T=T[0,0]</em> . <em>X[0,0]</em> for the first 
geometry, <em>X[0,1]</em> the second geometry and so on.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.write">
<span id="pyqha-write-module"></span><h2>pyqha.write module<a class="headerlink" href="#module-pyqha.write" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.write.write_CT">
<code class="descclassname">pyqha.write.</code><code class="descname">write_CT</code><span class="sig-paren">(</span><em>Ts</em>, <em>CT</em>, <em>fCout=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_CT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_CT" title="Permalink to this definition">¶</a></dt>
<dd><p>Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_C_geo">
<code class="descclassname">pyqha.write.</code><code class="descname">write_C_geo</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>C</em>, <em>ibrav=4</em>, <em>fCout=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_C_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_C_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies in the quasi-harmonic calculations!</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_Etot">
<code class="descclassname">pyqha.write.</code><code class="descname">write_Etot</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Ex</em>, <em>fname</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_Etot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_Etot" title="Permalink to this definition">¶</a></dt>
<dd><p>Read cell parameters (a,b,c,alpha,beta,gamma) and energies for a grid of cell
parameters values from file output_energy1. 
Each celldms is a vector of lenght 6 containing a,b,c,alpha,beta,gamma respectively
celldmsx and Ex contains the grid of values of celldms and E so that:
celldmsx[0] = celldms0      Ex[0] = E0
celldmsx[1] = celldms1      Ex[1] = E1
celldmsx[2] = celldms2      Ex[2] = E2
........
values are taken from the file &#8220;fname&#8221;
ibrav is the Bravais lattice as in Quantum Espresso and is needed in input (default is cubic)</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_alphaT">
<code class="descclassname">pyqha.write.</code><code class="descname">write_alphaT</code><span class="sig-paren">(</span><em>fname</em>, <em>T</em>, <em>alphaT</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_alphaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_alphaT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.write.write_celldmsT">
<code class="descclassname">pyqha.write.</code><code class="descname">write_celldmsT</code><span class="sig-paren">(</span><em>fname</em>, <em>T</em>, <em>x</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_celldmsT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_celldmsT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.write.write_elastic_constants">
<code class="descclassname">pyqha.write.</code><code class="descname">write_elastic_constants</code><span class="sig-paren">(</span><em>C</em>, <em>S</em>, <em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_elastic_constants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_elastic_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape [6,6]
So, the elastic constant C11 is in C[0][0], C12 in C[0][1] and so on.
Same for the elastic compliances</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_freq">
<code class="descclassname">pyqha.write.</code><code class="descname">write_freq</code><span class="sig-paren">(</span><em>weights</em>, <em>freq</em>, <em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Write frequencies (or Gruneisen parameters) on an extended mesh in a file.
In this format, q points coordinates are NOT written but the weight of each point yes.
It can be used to write the Gruneisen mode parameters, giving them in input as freq
Write the gruneisen parameters</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_freq_old">
<code class="descclassname">pyqha.write.</code><code class="descname">write_freq_old</code><span class="sig-paren">(</span><em>qgeo</em>, <em>freq</em>, <em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_freq_old"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_freq_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Write frequencies (or Gruneisen parameters) in a file. In this format also q points
coordinates are written but not the weight of each point.
It can be used to write the Gruneisen mode parameters, giving them in input as freq</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_thermo">
<code class="descclassname">pyqha.write.</code><code class="descname">write_thermo</code><span class="sig-paren">(</span><em>fname</em>, <em>T</em>, <em>Evib</em>, <em>Fvib</em>, <em>Svib</em>, <em>Cvib</em>, <em>ZPE</em>, <em>modes</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_thermo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.write.write_xy">
<code class="descclassname">pyqha.write.</code><code class="descname">write_xy</code><span class="sig-paren">(</span><em>fname</em>, <em>x</em>, <em>y</em>, <em>labelx</em>, <em>labely</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function writes a quantity y versus quantity x into the file fname.
y and x are arrays and should have the same lenght. labelx and labely
are the axis labels (possibly with units), written in the header of the file
(first line).</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Mauro Palumbo.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5a1.
    </div>
  </body>
</html>