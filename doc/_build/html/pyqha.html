<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyqha package &#8212; pyqha 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="pyqha 0.1 documentation" href="index.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" /> 
  </head>
  <body role="document">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><h1 style="font-size: 3em;">pyqha</h1></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyqha package</a><ul>
<li><a class="reference internal" href="#module-contents">Module contents</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pyqha.constants">pyqha.constants module</a></li>
<li><a class="reference internal" href="#module-pyqha.eos">pyqha.eos module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitC">pyqha.fitC module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitEtot">pyqha.fitEtot module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitFvib">pyqha.fitFvib module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitfreqgrun">pyqha.fitfreqgrun module</a></li>
<li><a class="reference internal" href="#module-pyqha.fitutils">pyqha.fitutils module</a></li>
<li><a class="reference internal" href="#module-pyqha.gruneisen1D">pyqha.gruneisen1D module</a></li>
<li><a class="reference internal" href="#module-pyqha.minutils">pyqha.minutils module</a></li>
<li><a class="reference internal" href="#module-pyqha.plotutils">pyqha.plotutils module</a></li>
<li><a class="reference internal" href="#module-pyqha.properties_anis">pyqha.properties_anis module</a></li>
<li><a class="reference internal" href="#module-pyqha.read">pyqha.read module</a></li>
<li><a class="reference internal" href="#module-pyqha.thermo">pyqha.thermo module</a></li>
<li><a class="reference internal" href="#module-pyqha.write">pyqha.write module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial.html"
                        title="previous chapter">Tutorial</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pyqha.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pyqha-package">
<h1>pyqha package<a class="headerlink" href="#pyqha-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-contents">
<h2>Module contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
<p>The following functions are available from <code class="xref py py-mod docutils literal"><span class="pre">pyqha</span></code> module and are the most common ones for the end user.</p>
<span class="target" id="module-pyqha.fitEtot"></span><dl class="function">
<dt id="pyqha.fitEtot.fitEtot">
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtot</code><span class="sig-paren">(</span><em>fin</em>, <em>out=True</em>, <em>ibrav=4</em>, <em>fittype='quadratic'</em>, <em>guess=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitEtot.fitEtot" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads the file <em>fin</em> containing the energies as a function
of the lattice parameters <img class="math" src="_images/math/4a2cd023907894f80fe62bbfe347513bc4954331.png" alt="E(a,b,c)"/> and fits them with a quartic (<em>fittype=&#8221;quartic&#8221;</em>) or 
quadratic (<em>fittype=&#8221;quadratic&#8221;</em>) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redericted to <em>stdout</em>)
if <em>out=True</em>.
It returns the lattice parameters and energies as in the input file <em>fin</em>,
the fitted coefficients of the polynomial, the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>,
the lattice parameters at the minimum and the minimun energy.</p>
<p>Note: for cubic systems use fitEtotV instead.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitEtot.fitEtotV">
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtotV</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtotV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitEtot.fitEtotV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads <img class="math" src="_images/math/7d28b83e95abf8aa59bcd91638cd7497b0045c5f.png" alt="E(V)"/> data from the input file <em>fin</em>, fits them with a Murnaghan EOS,
prints the results on the <em>stdout</em> and write them in the file &#8220;fout&#8221;.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.</p>
</dd></dl>

<span class="target" id="module-pyqha.thermo"></span><dl class="function">
<dt id="pyqha.thermo.compute_thermo">
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>TT</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.compute_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays <em>E</em> 
and <em>dos</em> containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array <em>TT</em>.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to <img class="math" src="_images/math/7fd84257c87ff8dc9ee27bd300875a6bdc8e2161.png" alt="3*N"/>, with <em>N</em> the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.compute_thermo_geo">
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo_geo</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em>, <em>ngeo=1</em>, <em>TT=array([1])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.compute_thermo_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads the input dos file(s) from <em>fin+i</em>, with <em>i</em> a number from
1 to <em>ngeo</em> + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">T</th>
<th class="head"><img class="math" src="_images/math/9fbdb84aec610808b553f187fc1ac99b95993006.png" alt="E_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/55b3ed38f962644f1072ee6a112740f24b78ed7b.png" alt="F_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/1ec0b0b14b11bd65993b7ac59a1fa3b78e78688c.png" alt="S_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/03ba745362038f7a468482e89419d50637d84353.png" alt="C_{vib}"/></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>and are names <em>fout</em> +1, <em>fout</em> +2,... for each geometry.</p>
<p>Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib[T,geo] -&gt; Fvib at the temperature &#8220;T&#8221; for the geometry &#8220;geo&#8221;</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.dos_integral">
<code class="descclassname">pyqha.thermo.</code><code class="descname">dos_integral</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>m=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#dos_integral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.dos_integral" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to compute the integral of an input phonon DOS (<em>dos</em>) with the 3/8 Simpson method.
<em>m</em> is the moment of the integral, if <img class="math" src="_images/math/9fe942a3b863852d1099e24ee69ed6068dce0933.png" alt="m&gt;0"/> different moments can be calculated.
For example, with <img class="math" src="_images/math/57e7fcd1e7c250f9afe8510738fcc25150cd46f8.png" alt="m=0"/> (default) it returns the number of modes from the dos, 
with <img class="math" src="_images/math/59c39884c40bf8420da99bdbc1f350c83b9acf63.png" alt="m=1"/> it returns the ZPE. The input energy (<em>E</em>) and phonon DOS (<em>dos</em>) are expected to be in
<img class="math" src="_images/math/8ef74976bf2a6e3a7790f40f153ad625f3fb9d60.png" alt="cm^{-1}"/>.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.gen_TT">
<code class="descclassname">pyqha.thermo.</code><code class="descname">gen_TT</code><span class="sig-paren">(</span><em>Tstart=1</em>, <em>Tend=1000</em>, <em>Tstep=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#gen_TT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.gen_TT" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple function to generate a numpy array of temperatures, starting from
<em>Tstart</em> and ending to <em>Tend</em> (or the closest <em>T&lt;Tend</em> accorinding to the <em>Tstep</em> )
with step <em>Tstep</em> .</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.thermo.rearrange_thermo">
<code class="descclassname">pyqha.thermo.</code><code class="descname">rearrange_thermo</code><span class="sig-paren">(</span><em>T</em>, <em>Evib</em>, <em>Fvib</em>, <em>Svib</em>, <em>Cvib</em>, <em>ngeo=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#rearrange_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.thermo.rearrange_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices <em>X</em> now gives all geometries at a given
<em>T</em>, i.e. <em>X[0]</em> is the vector of the property <em>X</em> a <em>T=T[0,0]</em> . <em>X[0,0]</em> for the first 
geometry, <em>X[0,1]</em> the second geometry and so on.</p>
</dd></dl>

<span class="target" id="module-pyqha.fitFvib"></span><dl class="function">
<dt id="pyqha.fitFvib.fitFvib">
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvib</code><span class="sig-paren">(</span><em>fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvib"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitFvib.fitFvib" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/1883c3f030ec103c67e7fb6fb02fa7b0a39aacf7.png" alt="F_{vib}(a,b,c,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in <em>fin</em> file. The 
real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>The function fits <img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> with a quadratic
or quartic polynomial (as defined by <em>typeEtot</em> and <em>typeFvib</em> ) at each
temperature in <em>thermodata</em> and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/>
and <img class="math" src="_images/math/50048175b5237f76e7863c156fa66afda1f1be9d.png" alt="F_{vib}(a,b,c)"/>. Then it computes the minimun energy <img class="math" src="_images/math/6fad90a8a0bf48bf469ab26edc21276d3b35748d.png" alt="E_{tot}+F_{vib}"/>
and the corresponding lattice parameters <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> 
at each temperature by miniimizing the energy.</p>
<p>It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_alpha()</span></code>).</p>
<p>It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> 
only (at T=0 K) and the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> at each temperature.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example6</em> and 
the tutorial.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitFvib.fitFvibV">
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvibV</code><span class="sig-paren">(</span><em>fin</em>, <em>thermodata</em>, <em>verbosity='low'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvibV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitFvib.fitFvibV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/1b43a9b9fc946c5e4302c3dd56be1b79358f3d66.png" alt="E_{tot}(V)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/b6911133133a6937356b958128d1e99cd4969b81.png" alt="F_{vib}(V,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in <em>fin</em> file.</p>
<p>The function fits <img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> with a Murnaghan&#8217;s EOS
at each temperature in <em>thermodata</em> and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_beta()</span></code>), the
constant volume heat capacity at the minimum volume at each T
(<code class="xref py py-func docutils literal"><span class="pre">compute_Cv()</span></code>) and the constant pression heat capacity (<code class="xref py py-func docutils literal"><span class="pre">compute_Cp()</span></code>).</p>
<p>It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> at each T.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example5</em> and 
the tutorial.</p>
</div>
</dd></dl>

<span class="target" id="module-pyqha.fitC"></span><dl class="function">
<dt id="pyqha.fitC.fitCT">
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCT</code><span class="sig-paren">(</span><em>aC</em>, <em>chiC</em>, <em>T</em>, <em>minT</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.fitCT" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the elastic constants tensor <em>CT</em> as a function of
temperatature in the quasi-static approximation.
It takes in input <em>aC</em> and <em>chiC</em>, the fitted coefficients of the elastic 
constants as a function of <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.
It also takes in input an array of temperatures <em>T</em> and the corresponding
lattice parameters <em>minT</em>, i.e. <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( <em>ibrav</em> ) and the type of polynomial
( <em>typeC</em> ) used for fitting the input <em>aC</em>.</p>
<p>The function uses the coefficients <em>aC</em> to compute the elastic tensor at
each temperature in the array <em>T</em> from the corresponding lattice parameters
<img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> in <em>minT</em>.</p>
<p>It returns the temperature array and the a matrix <em>CT</em> with all the elastic
tensors at each T ( <em>CT[i]</em> is the elastic constants matrix for the 
temperature <em>T[i]</em>)</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The coefficients <em>aC</em> must be the result of fitting the elastic constants
over the same <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> grid used in the quasi-harmonic calculations
corresponding to <em>minT</em> values! (See example7)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitC.fitCxx">
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCxx</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Cxx</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCxx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.fitCxx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function fits the elastic constant elements of <em>Cxx</em> as a function of the
grid of lattice parameters <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>. 
The real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>It returns a 6*6 matrix, each element <em>[i,j]</em> being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element <em>[i,j]</em> being the corresponding
<img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>. If the chi squared is zero, the fitting procedure was NOT succesful</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitC.rearrange_Cx">
<code class="descclassname">pyqha.fitC.</code><code class="descname">rearrange_Cx</code><span class="sig-paren">(</span><em>Cx</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#rearrange_Cx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitC.rearrange_Cx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function rearrange the input numpy matrix <em>Cx</em> into an equivalent matrix <em>Cxx</em>
for fitting it.
<em>Cx</em> is a <img class="math" src="_images/math/d87cb9d32bf68941207e822102899f34a2e64732.png" alt="ngeo*6*6"/> matrix, each <em>Cx[i]</em> is the 6*6 <em>C</em> matrix for a given geometry ( <em>i</em> )
<em>Cxx</em> is a Lmath:<cite>6*6*ngeo</cite> matrix, each <em>Cxx[i][j]</em> is a vector with all values for different
geometries of the <em>Cij</em> elastic constant matrix element. For example, <em>Cxx[0,0]</em>
is the vector with ngeo values of the <em>C11</em> elastic constant and so on.</p>
</dd></dl>

</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<p>Additional functions are available as submodules. Please note the documentation of these functions is still ongoing and can be incomplete or wrong.</p>
</div>
<div class="section" id="module-pyqha.constants">
<span id="pyqha-constants-module"></span><h2>pyqha.constants module<a class="headerlink" href="#module-pyqha.constants" title="Permalink to this headline">¶</a></h2>
<p>Some useful standard constants for conversions and calculations.</p>
</div>
<div class="section" id="module-pyqha.eos">
<span id="pyqha-eos-module"></span><h2>pyqha.eos module<a class="headerlink" href="#module-pyqha.eos" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.eos.E_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">E_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#E_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.E_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>As <a class="reference internal" href="#pyqha.eos.E_MurnV" title="pyqha.eos.E_MurnV"><code class="xref py py-func docutils literal"><span class="pre">E_MurnV()</span></code></a> but input parameters are given as a single list 
<em>a=[a0,a1,a2,a3]</em>.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.E_MurnV">
<code class="descclassname">pyqha.eos.</code><code class="descname">E_MurnV</code><span class="sig-paren">(</span><em>V</em>, <em>a0</em>, <em>a1</em>, <em>a2</em>, <em>a3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#E_MurnV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.E_MurnV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function implements the Murnaghan EOS (in a form which is best for fitting).
Returns the energy at the volume <em>V</em> using the coefficients <em>a0,a1,a2,a3</em> 
from the equation:</p>
<div class="math">
<p><img src="_images/math/e892012b52d6eb84a56e82f7fe739c804129f748.png" alt="a_0 - (a_2*a_1)/(a_3-1.0) V a_2/a_3 ( a_1/V^{a_3})/(a_3-1.0) +1.0 )"/></p>
</div></dd></dl>

<dl class="function">
<dt id="pyqha.eos.H_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">H_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#H_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.H_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>This function return</p>
<p>As <a class="reference internal" href="#pyqha.eos.E_MurnV" title="pyqha.eos.E_MurnV"><code class="xref py py-func docutils literal"><span class="pre">E_MurnV()</span></code></a> but input parameters are given as a single list 
<em>a=[a0,a1,a2,a3]</em> and it returns the pressure not the energy from the EOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.P_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">P_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#P_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.P_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>As <a class="reference internal" href="#pyqha.eos.E_MurnV" title="pyqha.eos.E_MurnV"><code class="xref py py-func docutils literal"><span class="pre">E_MurnV()</span></code></a> but input parameters are given as a single list 
<em>a=[a0,a1,a2,a3]</em> and it returns the pressure not the energy from the EOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.calculate_fitted_points">
<code class="descclassname">pyqha.eos.</code><code class="descname">calculate_fitted_points</code><span class="sig-paren">(</span><em>V</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#calculate_fitted_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.calculate_fitted_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a denser mesh of E(V) points for plotting...</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.compute_Cp">
<code class="descclassname">pyqha.eos.</code><code class="descname">compute_Cp</code><span class="sig-paren">(</span><em>T</em>, <em>Cv</em>, <em>V</em>, <em>B0</em>, <em>beta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#compute_Cp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.compute_Cp" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the isobaric heat capacity from the eq. Cp-Cv=...
Not implemented yet.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.compute_Cv">
<code class="descclassname">pyqha.eos.</code><code class="descname">compute_Cv</code><span class="sig-paren">(</span><em>T</em>, <em>Vmin</em>, <em>V</em>, <em>Cvib</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#compute_Cv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.compute_Cv" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the isocoric heat capacity as a function of temperature.
From <em>Cvib</em>, which is a matrix with <em>Cvib(T,V)</em> as from the harmonic calculations
determines the <em>Cv</em> at each temperature by linear interpolation between the values
at the two volumes closest to Vmin(T). Vmin(T) is from the minimization of F(V,T)
and <em>V</em> is the array of volumes used for it.
Returns <em>Cv(T)</em>.</p>
<p>Not implemented yet.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.compute_beta">
<code class="descclassname">pyqha.eos.</code><code class="descname">compute_beta</code><span class="sig-paren">(</span><em>minT</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#compute_beta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.compute_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the volumetric thermal expansion as a numerical
derivative of the volume as a function of temperature V(T). This is obtained
from the free energy minimization which should be done before.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.fit_Murn">
<code class="descclassname">pyqha.eos.</code><code class="descname">fit_Murn</code><span class="sig-paren">(</span><em>V</em>, <em>E</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#fit_Murn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.fit_Murn" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for fitting with the Murnaghan EOS as a function of volume only.</p>
<p>The input variable V is an 1D array of volumes, E are the corresponding 
energies (or other analogous quantity to be fitted with the Murnaghan EOS.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.print_eos_data">
<code class="descclassname">pyqha.eos.</code><code class="descname">print_eos_data</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>a</em>, <em>chi</em>, <em>ylabel='Etot'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#print_eos_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.print_eos_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the data and the fitted results using the EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be &#8220;Etot&#8221;, 
&#8220;Fvib&#8221;, etc.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.eos.write_Etotfitted">
<code class="descclassname">pyqha.eos.</code><code class="descname">write_Etotfitted</code><span class="sig-paren">(</span><em>filename</em>, <em>x</em>, <em>y</em>, <em>a</em>, <em>chi</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/eos.html#write_Etotfitted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.eos.write_Etotfitted" title="Permalink to this definition">¶</a></dt>
<dd><p>Write in filename the data and the fitted results using the EOS. It can be used for
different fitted quantities using the proper ylabel. ylabel can be &#8220;Etot&#8221;, 
&#8220;Fvib&#8221;, etc.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitC">
<span id="pyqha-fitc-module"></span><h2>pyqha.fitC module<a class="headerlink" href="#module-pyqha.fitC" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCT</code><span class="sig-paren">(</span><em>aC</em>, <em>chiC</em>, <em>T</em>, <em>minT</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCT"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function calculates the elastic constants tensor <em>CT</em> as a function of
temperatature in the quasi-static approximation.
It takes in input <em>aC</em> and <em>chiC</em>, the fitted coefficients of the elastic 
constants as a function of <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.
It also takes in input an array of temperatures <em>T</em> and the corresponding
lattice parameters <em>minT</em>, i.e. <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> from a 
previous quasi-harmonic calculations (as in example6). 
It also needs in input the Bravais lattice ( <em>ibrav</em> ) and the type of polynomial
( <em>typeC</em> ) used for fitting the input <em>aC</em>.</p>
<p>The function uses the coefficients <em>aC</em> to compute the elastic tensor at
each temperature in the array <em>T</em> from the corresponding lattice parameters
<img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> in <em>minT</em>.</p>
<p>It returns the temperature array and the a matrix <em>CT</em> with all the elastic
tensors at each T ( <em>CT[i]</em> is the elastic constants matrix for the 
temperature <em>T[i]</em>)</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The coefficients <em>aC</em> must be the result of fitting the elastic constants
over the same <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/> grid used in the quasi-harmonic calculations
corresponding to <em>minT</em> values! (See example7)</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">fitCxx</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Cxx</em>, <em>ibrav=4</em>, <em>typeC='quadratic'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#fitCxx"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function fits the elastic constant elements of <em>Cxx</em> as a function of the
grid of lattice parameters <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>. 
The real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>It returns a 6*6 matrix, each element <em>[i,j]</em> being the set of coefficients of the 
polynomial fit and another 6*6 matrix, each element <em>[i,j]</em> being the corresponding
<img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>. If the chi squared is zero, the fitting procedure was NOT succesful</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitC.</code><code class="descname">rearrange_Cx</code><span class="sig-paren">(</span><em>Cx</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitC.html#rearrange_Cx"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function rearrange the input numpy matrix <em>Cx</em> into an equivalent matrix <em>Cxx</em>
for fitting it.
<em>Cx</em> is a <img class="math" src="_images/math/d87cb9d32bf68941207e822102899f34a2e64732.png" alt="ngeo*6*6"/> matrix, each <em>Cx[i]</em> is the 6*6 <em>C</em> matrix for a given geometry ( <em>i</em> )
<em>Cxx</em> is a Lmath:<cite>6*6*ngeo</cite> matrix, each <em>Cxx[i][j]</em> is a vector with all values for different
geometries of the <em>Cij</em> elastic constant matrix element. For example, <em>Cxx[0,0]</em>
is the vector with ngeo values of the <em>C11</em> elastic constant and so on.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitEtot">
<span id="pyqha-fitetot-module"></span><h2>pyqha.fitEtot module<a class="headerlink" href="#module-pyqha.fitEtot" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtot</code><span class="sig-paren">(</span><em>fin</em>, <em>out=True</em>, <em>ibrav=4</em>, <em>fittype='quadratic'</em>, <em>guess=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtot"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function reads the file <em>fin</em> containing the energies as a function
of the lattice parameters <img class="math" src="_images/math/4a2cd023907894f80fe62bbfe347513bc4954331.png" alt="E(a,b,c)"/> and fits them with a quartic (<em>fittype=&#8221;quartic&#8221;</em>) or 
quadratic (<em>fittype=&#8221;quadratic&#8221;</em>) polynomial. Then it finds the minimun energy
and the corresponding lattice parameters. 
ibrav is the Bravais lattice, guess is an initial guess for the minimization.
Depending on ibrav, a different number of lattice parameters is considered.
It prints fitting results on the screen (which can be redericted to <em>stdout</em>)
if <em>out=True</em>.
It returns the lattice parameters and energies as in the input file <em>fin</em>,
the fitted coefficients of the polynomial, the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>,
the lattice parameters at the minimum and the minimun energy.</p>
<p>Note: for cubic systems use fitEtotV instead.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitEtot.</code><code class="descname">fitEtotV</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitEtot.html#fitEtotV"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function reads <img class="math" src="_images/math/7d28b83e95abf8aa59bcd91638cd7497b0045c5f.png" alt="E(V)"/> data from the input file <em>fin</em>, fits them with a Murnaghan EOS,
prints the results on the <em>stdout</em> and write them in the file &#8220;fout&#8221;.
It returns the volumes and energies read from the input file, the fitted coefficients 
of the EOS and the corresponding <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/>.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitFvib">
<span id="pyqha-fitfvib-module"></span><h2>pyqha.fitFvib module<a class="headerlink" href="#module-pyqha.fitFvib" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvib</code><span class="sig-paren">(</span><em>fEtot, thermodata, ibrav=4, typeEtot='quadratic', typeFvib='quadratic', defaultguess=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvib"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/1883c3f030ec103c67e7fb6fb02fa7b0a39aacf7.png" alt="F_{vib}(a,b,c,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each (a,b,c) as in <em>fin</em> file. The 
real number of lattice parameters depends on <em>ibrav</em>, for example for 
hexagonal systems (<em>ibrav=4</em>) you have only (a,c) values. <em>ibrav</em> identifies
the Bravais lattice, as in Quantum Espresso.</p>
<p>The function fits <img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> with a quadratic
or quartic polynomial (as defined by <em>typeEtot</em> and <em>typeFvib</em> ) at each
temperature in <em>thermodata</em> and then stores the fitted coefficients.    
Note that you can chose a different polynomial type for fitting <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/>
and <img class="math" src="_images/math/50048175b5237f76e7863c156fa66afda1f1be9d.png" alt="F_{vib}(a,b,c)"/>. Then it computes the minimun energy <img class="math" src="_images/math/6fad90a8a0bf48bf469ab26edc21276d3b35748d.png" alt="E_{tot}+F_{vib}"/>
and the corresponding lattice parameters <img class="math" src="_images/math/7ba91eab7e1964054dcbd4eed8266f1d32e28820.png" alt="(a_{min},b_{min},c_{min})"/> 
at each temperature by miniimizing the energy.</p>
<p>It also computes the linear thermal expansion tensor (as a numerical derivative of
the minimum lattice parameters as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_alpha()</span></code>).</p>
<p>It returns the numpy arrays and matrices containing the temperatures (as in input), the
minimun energy, minimun lattice parameters, linear thermal expansions. It also
returns the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for <img class="math" src="_images/math/7ba79c6f386b207848b357cb4da8456964768dd1.png" alt="E_{tot}(a,b,c)"/> 
only (at T=0 K) and the fitted coefficients and the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> for 
<img class="math" src="_images/math/ef0c0737fcead988ed54b2d38a9f0eda9215bcef.png" alt="E_{tot}(a,b,c)+F_{vib}(a,b,c,T)"/> at each temperature.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example6</em> and 
the tutorial.</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.fitFvib.</code><code class="descname">fitFvibV</code><span class="sig-paren">(</span><em>fin</em>, <em>thermodata</em>, <em>verbosity='low'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitFvib.html#fitFvibV"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function computes quasi-harmonic quantities from the 
<img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> as a function of temperature with Murnaghan&#8217;s
EOS. <img class="math" src="_images/math/1b43a9b9fc946c5e4302c3dd56be1b79358f3d66.png" alt="E_{tot}(V)"/> is read from the <em>fin</em> file. <img class="math" src="_images/math/b6911133133a6937356b958128d1e99cd4969b81.png" alt="F_{vib}(V,T)"/>
are given in <em>thermodata</em> which is a list containing the number of temperatures
( <em>nT</em> ) for which the calculations are done and the numpy matrices for 
temperatures, vibrational energy, Helmholtz energy, entropy and
heat capacity. All these quantities are for each volume as in <em>fin</em> file.</p>
<p>The function fits <img class="math" src="_images/math/174aa3d7370f21e26a82adeba71760a12acc82f1.png" alt="E_{tot}(V)+F_{vib}(V,T)"/> with a Murnaghan&#8217;s EOS
at each temperature in <em>thermodata</em> and then stores the fitted coefficients.
It also computes the volume thermal expansion as a numerical derivative of
the minimum volume as a function of temperature (<code class="xref py py-func docutils literal"><span class="pre">compute_beta()</span></code>), the
constant volume heat capacity at the minimum volume at each T
(<code class="xref py py-func docutils literal"><span class="pre">compute_Cv()</span></code>) and the constant pression heat capacity (<code class="xref py py-func docutils literal"><span class="pre">compute_Cp()</span></code>).</p>
<p>It returns the numpy 1D arrays containing the temperatures (as in input), the
minimun energy, minimun volume, bulk modulus, volume thermal expansion, constant
volume and constant pressure heat capacities, one matrix with all fitted 
coefficients at each T and finally an array with the <img class="math" src="_images/math/b0a677c7b64a9ce46bca897eabaf2af1c84de1a5.png" alt="\chi^2"/> at each T.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The quantities in <em>thermodata</em> are usually obtained from <code class="xref py py-func docutils literal"><span class="pre">compute_thermo_geo()</span></code>
or from <code class="xref py py-func docutils literal"><span class="pre">read_thermo()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rearrange_thermo()</span></code>. It is
important that the order in the total energy file <em>fin</em> and the order of
the thermodynamic data in <em>thermodata</em> is the same!  See also <em>example5</em> and 
the tutorial.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitfreqgrun">
<span id="pyqha-fitfreqgrun-module"></span><h2>pyqha.fitfreqgrun module<a class="headerlink" href="#module-pyqha.fitfreqgrun" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.fitfreqgrun.fitfreq">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">fitfreq</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>min0</em>, <em>inputfilefreq</em>, <em>ibrav=4</em>, <em>typefreq='quadratic'</em>, <em>compute_grun=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#fitfreq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.fitfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function for fitting the frequencies. It returns a matrix of nq*modes
frequencies obtained for the fitted polynomial (quadratic or quartic) at the 
minimun point min0. It also returns the weigths of each q point where the 
frequencies are available.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.fitfreqxx">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">fitfreqxx</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>freqxx</em>, <em>ibrav</em>, <em>out</em>, <em>typefreq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#fitfreqxx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.fitfreqxx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function fits the frequencies in freqxx as a function of the
grid of lattice parameters.</p>
<p>It returns a nq*modes matrix, whose element [i,j] is the set of coefficients of the 
polynomial fit and another nq*modes matrix, whose element [i,j] is the corresponding
chi squared. If the chi squared is zero, the fitting procedure was NOT succesful</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.freqmin">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">freqmin</code><span class="sig-paren">(</span><em>afreq</em>, <em>min0</em>, <em>nq</em>, <em>modes</em>, <em>ibrav</em>, <em>typefreq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#freqmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.freqmin" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the frequencies from the fitted polynomials at the 
minimun point min0. afreq contains the fitted polynomial coefficients.</p>
<p>It returns a nq*modes matrix, whose element [i,j] is the fitted frequency</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.freqmingrun">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">freqmingrun</code><span class="sig-paren">(</span><em>afreq</em>, <em>min0</em>, <em>nq</em>, <em>modes</em>, <em>ibrav</em>, <em>typefreq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#freqmingrun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.freqmingrun" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the frequencies and the gruneisen parameters 
from the fitted polynomials at the minimun point min0. afreq contains the 
fitted polynomial coefficients.</p>
<p>It returns a nq*modes matrix, whose element [i,j] is the fitted frequency 
In addition, it returns a nq*modes*6 with the Gruneisein parameters.
Each element [i,j,k] is the the Gruneisein parameter at nq=i, mode=j and direction
k (for example, in hex systems k=0 is a direction, k=2 is c direction, other are zero)</p>
<p>Note that the Gruneisein parameters are not multiplied for the lattice parameters</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitfreqgrun.rearrange_freqx">
<code class="descclassname">pyqha.fitfreqgrun.</code><code class="descname">rearrange_freqx</code><span class="sig-paren">(</span><em>freqx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitfreqgrun.html#rearrange_freqx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitfreqgrun.rearrange_freqx" title="Permalink to this definition">¶</a></dt>
<dd><p>This function rearrange the input numpy matrix freqx into an equivalent matrix freqxx
for the subsequent fitting.
freqx is a ngeo*nq*modes matrix, each freqx[i] is the nq*modes freq matrix for a given geometry (i)
freqxx is a nq*modes*ngeo matrix, each freqxx[i][j] is a vector with all values for different
geometries of the frequencies at point q=i and mode=j. For example, freqxx[0][0]
is the vector with ngeo values of the frequencies at the first q-point and first mode so on.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.fitutils">
<span id="pyqha-fitutils-module"></span><h2>pyqha.fitutils module<a class="headerlink" href="#module-pyqha.fitutils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.fitutils.expand_quadratic_to_quartic">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">expand_quadratic_to_quartic</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#expand_quadratic_to_quartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.expand_quadratic_to_quartic" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a vector of coefficients from a quadratic fit and turns it
into a vector of coeffients as from a quartic fit (extra coeffients are set to zero)</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.fit_anis">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">fit_anis</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Ex</em>, <em>ibrav=1</em>, <em>out=False</em>, <em>type='quadratic'</em>, <em>ylabel='Etot'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#fit_anis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.fit_anis" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function for handling fitting in the anisotropic case</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.fit_quadratic">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">fit_quadratic</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>ibrav=4</em>, <em>out=False</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#fit_quadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.fit_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for fitting with a quadratic polynomial</p>
<p>The most general fitting multidimensional quadratic polynomial for a triclinic
system is:
a1 + a2 x1 + a3 x1^2 + a4  x2 + a5  x2^2 + a6 x1*x2 +    
+ a7  x3 + a8  x3^2 + a9  x1*x3 + a10 x2*x3 +         
+ a11 x4 + a12 x4^2 + a13 x1*x4 + a14 x2*x4 + a15 x3*x4 +        
+ a16 x5 + a17 x5^2 + a18 x1*x5 + a19 x2*x5 + a20 x3*x5 + a21 x4*x5 
+ a22 x6 + a23 x6^2 + a24 x1*x6 + a25 x2*x6 + a26 x3*x6 + a27 x4*x6 + a28 x5*x6</p>
<p>ONLY THE HEXAGONAL AND GENERAL CASE ARE IMPLEMENTED, more to be done</p>
<p>The input variable x is a matrix ngeo*6, where
x[:,0] is the set of a values  
x[:,1] is the set of b values  
x[:,2] is the set of c values  
x[:,3] is the set of alpha values  
x[:,4] is the set of beta values   
x[:,5] is the set of gamma values</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.fit_quartic">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">fit_quartic</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>ibrav=4</em>, <em>out=False</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#fit_quartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.fit_quartic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for fitting with a quartic polynomial</p>
<p>The most general fitting multidimensional quadratic polynomial for a triclinic
system is:</p>
<dl class="docutils">
<dt>a1 + a2  x1 + a3  x1^2 + a4  x1^3 + a5 x1^4        </dt>
<dd><ul class="first last">
<li><p class="first">a6  x2 + a7  x2^2 + a8  x2^3 + a9 x2^4</p>
</li>
<li><dl class="first docutils">
<dt>a10 x1*x2 + a11 x1*x2^2 + a12  x1*x2^3</dt>
<dd><ul class="first last simple">
<li>a13 x1^2*x2 + a14  x1^2*x2^2</li>
<li>a15 x1^3*x2</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">a16 x3 + a17 x3^2 + a18 x3^3 + a19 x3^4</p>
</li>
<li><dl class="first docutils">
<dt>a20 x1*x3 + a21 x1*x3^2 + a22  x1*x3^3</dt>
<dd><ul class="first last simple">
<li>a23 x1^2*x3 + a24  x1^2*x3^2</li>
<li>a25 x1^3*x3</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a26 x2*x3 + a27 x2*x3^2 + a28  x2*x3^3</dt>
<dd><ul class="first last simple">
<li>a29 x2^2*x3 + a30  x2^2*x3^2</li>
<li>a31 x2^3*x3</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">a32 x1 * x2 * x3 + a33 x1 * x2^2 * x3</p>
</li>
<li><p class="first">a34 x1 * x2 * x3^2 + a35 x1^2 * x2 * x3</p>
</li>
<li><p class="first">a36 x4 + a37 x4^2 + a38 x4^3 + a39 x4^4</p>
</li>
<li><dl class="first docutils">
<dt>a40 x1*x4 + a41 x1*x4^2 + a42  x1*x4^3</dt>
<dd><ul class="first last simple">
<li>a43 x1^2*x4 + a44  x1^2*x4^2</li>
<li>a45 x1^3*x4</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a46 x2*x4 + a47 x2*x4^2 + a48  x2*x4^3</dt>
<dd><ul class="first last simple">
<li>a49 x2^2*x4 + a50  x2^2*x4^2</li>
<li>a51 x2^3*x4</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a52 x3*x4 + a53 x3*x4^2 + a54  x3*x4^3</dt>
<dd><ul class="first last simple">
<li>a55 x3^2*x4 + a56  x3^2*x4^2</li>
<li>a57 x3^3*x4</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">a58 x1 * x2 * x4 + a59 x1 * x2^2 * x4</p>
</li>
<li><p class="first">a60 x1 * x2 * x4^2 + a61 x1^2 * x2 * x4</p>
</li>
<li><p class="first">a62 x1 * x3 * x4 + a63 x1 * x3^2 * x4</p>
</li>
<li><p class="first">a64 x1 * x3 * x4^2 + a65 x1^2 * x3 * x4</p>
</li>
<li><p class="first">a66 x2 * x3 * x4 + a67 x2 * x3^2 * x4</p>
</li>
<li><p class="first">a68 x2 * x3 * x4^2 + a69 x2^2 * x3 * x4</p>
</li>
<li><p class="first">a70 x1 * x2 * x3 * x4</p>
</li>
<li><p class="first">a71 x5 + a72 x5^2 + a73 x5^3 + a74 x5^4</p>
</li>
<li><dl class="first docutils">
<dt>a75 x1*x5 + a76 x1*x5^2 + a77 x1*x5^3</dt>
<dd><ul class="first last simple">
<li>a78 x1^2*x5 + a79 x1^2*x5^2</li>
<li>a80 x1^3*x5</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a81 x2*x5 + a82 x2*x5^2 + a83 x2*x5^3</dt>
<dd><ul class="first last simple">
<li>a84 x2^2*x5 + a85 x2^2*x5^2</li>
<li>a86 x2^3*x5</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a87 x3*x5 + a88 x3*x5^2 + a89 x3*x5^3</dt>
<dd><ul class="first last simple">
<li>a90 x3^2*x5 + a91 x3^2*x5^2</li>
<li>a92 x3^3*x5</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a93 x4*x5 + a94 x4*x5^2 + a95 x4*x5^3</dt>
<dd><ul class="first last simple">
<li>a96 x4^2*x5 + a97 x4^2*x5^2</li>
<li>a98 x4^3*x5</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">a99  x1 * x2 * x5 + a100 x1 * x2^2 * x5</p>
</li>
<li><p class="first">a101 x1 * x2 * x5^2 + a102 x1^2 * x2 * x5</p>
</li>
<li><p class="first">a103 x1 * x3 * x5 + a104 x1 * x3^2 * x5</p>
</li>
<li><p class="first">a105 x1 * x3 * x5^2 + a106 x1^2 * x3 * x5</p>
</li>
<li><p class="first">a107 x1 * x4 * x5 + a108 x1 * x4^2 * x5</p>
</li>
<li><p class="first">a109 x1 * x4 * x5^2 + a110 x1^2 * x4 * x5</p>
</li>
<li><p class="first">a111 x2 * x3 * x5 + a112 x2 * x3^2 * x5</p>
</li>
<li><p class="first">a113 x2 * x3 * x5^2 + a114 x2^2 * x3 * x5</p>
</li>
<li><p class="first">a115 x2 * x4 * x5 + a116 x2 * x4^2 * x5</p>
</li>
<li><p class="first">a117 x2 * x4 * x5^2 + a118 x2^2 * x4 * x5</p>
</li>
<li><p class="first">a119 x3 * x4 * x5 + a120 x3 * x4^2 * x5</p>
</li>
<li><p class="first">a121 x3 * x4 * x5^2 + a122 x3^2 * x4 * x5</p>
</li>
<li><p class="first">a123 x1 * x2 * x3 * x5</p>
</li>
<li><p class="first">a124 x1 * x2 * x4 * x5</p>
</li>
<li><p class="first">a125 x1 * x3 * x4 * x5</p>
</li>
<li><p class="first">a126 x2 * x3 * x4 * x5</p>
</li>
<li><p class="first">a127 x6 + a128 x6^2 + a129 x6^3 + a130 x6^4</p>
</li>
<li><dl class="first docutils">
<dt>a131 x1*x6 + a132 x1*x6^2 + a133 x1*x6^3</dt>
<dd><ul class="first last simple">
<li>a134 x1^2*x6 + a135 x1^2*x6^2</li>
<li>a136 x1^3*x6</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a137 x2*x6 + a138 x2*x6^2 + a139 x2*x6^3</dt>
<dd><ul class="first last simple">
<li>a140 x2^2*x6 + a141 x2^2*x6^2</li>
<li>a142 x2^3*x6</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a143 x3*x6 + a144 x3*x6^2 + a145 x3*x6^3</dt>
<dd><ul class="first last simple">
<li>a146 x3^2*x6 + a147 x3^2*x6^2</li>
<li>a148 x3^3*x6</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a149 x4*x6 + a150 x4*x6^2 + a151 x4*x6^3</dt>
<dd><ul class="first last simple">
<li>a152 x4^2*x6 + a153 x4^2*x6^2</li>
<li>a154 x4^3*x6</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>a155 x5*x6 + a156 x5*x6^2 + a157 x5*x6^3</dt>
<dd><ul class="first last simple">
<li>a158 x5^2*x6 + a159 x5^2*x6^2</li>
<li>a160 x5^3*x6</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">a161 x1 * x2 * x6 + a162 x1 * x2^2 * x6</p>
</li>
<li><p class="first">a163 x1 * x2 * x6^2 + a164 x1^2 * x2 * x6</p>
</li>
<li><p class="first">a165 x1 * x3 * x6 + a166 x1 * x3^2 * x6</p>
</li>
<li><p class="first">a167 x1 * x3 * x6^2 + a168 x1^2 * x3 * x6</p>
</li>
<li><p class="first">a169 x1 * x4 * x6 + a170 x1 * x4^2 * x6</p>
</li>
<li><p class="first">a171 x1 * x4 * x6^2 + a172 x1^2 * x4 * x6</p>
</li>
<li><p class="first">a173 x1 * x5 * x6 + a174 x1 * x5^2 * x6</p>
</li>
<li><p class="first">a175 x1 * x5 * x6^2 + a176 x1^2 * x5 * x6</p>
</li>
<li><p class="first">a177 x2 * x3 * x6 + a178 x2 * x3^2 * x6</p>
</li>
<li><p class="first">a179 x2 * x3 * x6^2 + a180 x2^2 * x3 * x6</p>
</li>
<li><p class="first">a181 x2 * x4 * x6 + a182 x2 * x4^2 * x6</p>
</li>
<li><p class="first">a183 x2 * x4 * x6^2 + a184 x2^2 * x4 * x6</p>
</li>
<li><p class="first">a185 x2 * x5 * x6 + a186 x2 * x5^2 * x6</p>
</li>
<li><p class="first">a187 x2 * x5 * x6^2 + a188 x2^2 * x5 * x6</p>
</li>
<li><p class="first">a189 x3 * x4 * x6 + a190 x3 * x4^2 * x6</p>
</li>
<li><p class="first">a191 x3 * x4 * x6^2 + a192 x3^2 * x4 * x6</p>
</li>
<li><p class="first">a193 x3 * x5 * x6 + a194 x3 * x5^2 * x6</p>
</li>
<li><p class="first">a195 x3 * x5 * x6^2 + a196 x3^2 * x5 * x6</p>
</li>
<li><p class="first">a197 x4 * x5 * x6 + a198 x4 * x5^2 * x6</p>
</li>
<li><p class="first">a199 x4 * x5 * x6^2 + a200 x4^2 * x5 * x6</p>
</li>
<li><p class="first">a201 x1 * x2 * x3 * x6</p>
</li>
<li><p class="first">a202 x1 * x2 * x4 * x6</p>
</li>
<li><p class="first">a203 x1 * x2 * x5 * x6</p>
</li>
<li><p class="first">a204 x1 * x3 * x4 * x6</p>
</li>
<li><p class="first">a205 x1 * x3 * x5 * x6</p>
</li>
<li><p class="first">a206 x1 * x4 * x5 * x6</p>
</li>
<li><p class="first">a207 x2 * x3 * x4 * x6</p>
</li>
<li><p class="first">a208 x2 * x3 * x5 * x6</p>
</li>
<li><p class="first">a209 x2 * x4 * x5 * x6</p>
</li>
<li><p class="first">a210 x3 * x4 * x5 * x6</p>
</li>
</ul>
</dd>
</dl>
<p>ONLY THE HEXAGONAL CASE IS IMPLEMENTED, more to be done</p>
<p>The input variable x is a matrix ngeo*6, where
x[:,0] is the set of a values  
x[:,1] is the set of b values  
x[:,2] is the set of c or c/a values  
x[:,3] is the set of alpha values  
x[:,4] is the set of beta values   
x[:,5] is the set of gamma values</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.print_data">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">print_data</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>results</em>, <em>A</em>, <em>ibrav</em>, <em>ylabel='E'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#print_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.print_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prints the data and the fitted results 
ylabel can be &#8220;E&#8221;, &#8220;Fvib&#8221;, &#8220;Cxx&#8221;, etc. so that can be used for different
fitted quantities</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.fitutils.print_polynomial">
<code class="descclassname">pyqha.fitutils.</code><code class="descname">print_polynomial</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/fitutils.html#print_polynomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.fitutils.print_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prints the fitted polynomial, either quartic or quadratic</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.gruneisen1D">
<span id="pyqha-gruneisen1d-module"></span><h2>pyqha.gruneisen1D module<a class="headerlink" href="#module-pyqha.gruneisen1D" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.gruneisen1D.compute_grun">
<code class="descclassname">pyqha.gruneisen1D.</code><code class="descname">compute_grun</code><span class="sig-paren">(</span><em>ngeo</em>, <em>celldmsx</em>, <em>inputfilefreq</em>, <em>ibrav=4</em>, <em>ext=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/gruneisen1D.html#compute_grun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.gruneisen1D.compute_grun" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the frequencies for all geometries where the gruneisen parameters must be
calculated. This depends on the direction (along a, along c, etc.)
According to the direction chosen, start,stop,step must be given to loop over 
all geometries as listed in the file containing the energies</p>
<p>More work to do: entend to other ibrav types, etc.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.gruneisen1D.compute_grun_along_one_direction">
<code class="descclassname">pyqha.gruneisen1D.</code><code class="descname">compute_grun_along_one_direction</code><span class="sig-paren">(</span><em>nq</em>, <em>modes</em>, <em>ngeo</em>, <em>cgeo</em>, <em>celldmsx</em>, <em>freqgeo</em>, <em>rangegeo</em>, <em>xindex=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/gruneisen1D.html#compute_grun_along_one_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.gruneisen1D.compute_grun_along_one_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Gruneisen parameters along one direction.
This function uses a 1-dimensional polynomial of fourth degree to fit the 
frequencies along a certain direction (along a and c axis in hexagonal systems
for example).</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.gruneisen1D.find_geocenters">
<code class="descclassname">pyqha.gruneisen1D.</code><code class="descname">find_geocenters</code><span class="sig-paren">(</span><em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/gruneisen1D.html#find_geocenters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.gruneisen1D.find_geocenters" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the center geometries. Remember indexex in lists starts from 0...</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.minutils">
<span id="pyqha-minutils-module"></span><h2>pyqha.minutils module<a class="headerlink" href="#module-pyqha.minutils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.minutils.calculate_fitted_points_anis">
<code class="descclassname">pyqha.minutils.</code><code class="descname">calculate_fitted_points_anis</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>nmesh</em>, <em>fittype='quadratic'</em>, <em>ibrav=4</em>, <em>a=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#calculate_fitted_points_anis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.calculate_fitted_points_anis" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a denser mesh of Efitted(celldmsx) points for plotting. nmesh = (nx,ny,nz)
gives the dimensions of the mesh.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.contract_vector">
<code class="descclassname">pyqha.minutils.</code><code class="descname">contract_vector</code><span class="sig-paren">(</span><em>x</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#contract_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.contract_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function: contract a vector x, len(x)=6, into a x-dim vector (x&lt;6) 
according to ibrav
Note: not all ibrav are implemented yet</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.expand_vector">
<code class="descclassname">pyqha.minutils.</code><code class="descname">expand_vector</code><span class="sig-paren">(</span><em>x</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#expand_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.expand_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function: expands a vector x, len(x)&lt;6, into a 6-dim vector according
to ibrav
Note: not all ibrav are implemented yet</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.find_min">
<code class="descclassname">pyqha.minutils.</code><code class="descname">find_min</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav</em>, <em>type</em>, <em>guess=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#find_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.find_min" title="Permalink to this definition">¶</a></dt>
<dd><p>An auxiliary function for handling the minimum search</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.find_min_quadratic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">find_min_quadratic</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav=4</em>, <em>guess=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#find_min_quadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.find_min_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for finding the minimum of the quadratic polynomial</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.find_min_quartic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">find_min_quartic</code><span class="sig-paren">(</span><em>a</em>, <em>ibrav=4</em>, <em>guess=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#find_min_quartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.find_min_quartic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function for finding the minimum of the quartic polynomial</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquadratic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquadratic</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Implemented polynomials for fitting and miminizing</p>
<p>only ibrav=4 and the most general case are implemented for now</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquadratic_der">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquadratic_der</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquadratic_der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquadratic_der" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquartic">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquartic</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquartic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquartic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.minutils.fquartic_der">
<code class="descclassname">pyqha.minutils.</code><code class="descname">fquartic_der</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/minutils.html#fquartic_der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.minutils.fquartic_der" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyqha.plotutils">
<span id="pyqha-plotutils-module"></span><h2>pyqha.plotutils module<a class="headerlink" href="#module-pyqha.plotutils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.plotutils.multiple_plot_xy">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">multiple_plot_xy</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>xlabel=''</em>, <em>ylabel=''</em>, <em>labels=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#multiple_plot_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.multiple_plot_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a simple xy plot with matplotlib overlapping several
lines as in the matrix y. y second index refers to a line in the plot, the first 
index is for the array to be plotted.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.plot_EV">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">plot_EV</code><span class="sig-paren">(</span><em>V</em>, <em>E</em>, <em>a=None</em>, <em>labely='Etot'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#plot_EV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.plot_EV" title="Permalink to this definition">¶</a></dt>
<dd><p>This function plots with matplotlib E(V) data and if a is given it also plot
the fitted results</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.plot_Etot">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">plot_Etot</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Ex</em>, <em>n</em>, <em>nmesh=(50</em>, <em>50</em>, <em>50)</em>, <em>fittype='quadratic'</em>, <em>ibrav=4</em>, <em>a=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#plot_Etot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.plot_Etot" title="Permalink to this definition">¶</a></dt>
<dd><p>This function makes a 3D plot with matplotlib Ex(celldmsx) data and if a is given it also plot
the fitted results. The plot type depends on ibrav.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.plot_Etot_contour">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">plot_Etot_contour</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>nmesh=(50</em>, <em>50</em>, <em>50)</em>, <em>fittype='quadratic'</em>, <em>ibrav=4</em>, <em>a=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#plot_Etot_contour"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.plot_Etot_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>This function makes a countour plot with matplotlib of Ex(celldmsx) fitted results. 
The plot type depends on ibrav.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.plotutils.simple_plot_xy">
<code class="descclassname">pyqha.plotutils.</code><code class="descname">simple_plot_xy</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>xlabel=''</em>, <em>ylabel=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/plotutils.html#simple_plot_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.plotutils.simple_plot_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a simple xy plot with matplotlib.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.properties_anis">
<span id="pyqha-properties-anis-module"></span><h2>pyqha.properties_anis module<a class="headerlink" href="#module-pyqha.properties_anis" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.properties_anis.compute_alpha">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_alpha</code><span class="sig-paren">(</span><em>minT</em>, <em>ibrav</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the thermal expansion alphaT at different temperatures
from the input minT matrix by computing the numerical derivatives with numpy.
The input matrix minT has shape nT*6, where the first index is the temperature 
and the second the lattice parameter. For example, minT[i,0] and minT[i,2] are
the lattice parameters a and c at the temperature i.</p>
<p>More ibrav types must be implemented</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_alpha_splines">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_alpha_splines</code><span class="sig-paren">(</span><em>TT</em>, <em>minT</em>, <em>ibrav</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_alpha_splines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_alpha_splines" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the thermal expansion alphaT at different temperatures
as the previous function but with splines</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_heat_capacity">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_heat_capacity</code><span class="sig-paren">(</span><em>TT</em>, <em>minT</em>, <em>alphaT</em>, <em>C</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_heat_capacity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_heat_capacity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the difference between the constant stress heat capacity
C_sigma and the constant strain heat capacity C_epsilon from the V, the thermal
expansions and the elastic constant tensor C</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.properties_anis.compute_volume">
<code class="descclassname">pyqha.properties_anis.</code><code class="descname">compute_volume</code><span class="sig-paren">(</span><em>celldms</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/properties_anis.html#compute_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.properties_anis.compute_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the volume given the celldms, only for ibrav=4 for now</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.read">
<span id="pyqha-read-module"></span><h2>pyqha.read module<a class="headerlink" href="#module-pyqha.read" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.read.read_Etot">
<code class="descclassname">pyqha.read.</code><code class="descname">read_Etot</code><span class="sig-paren">(</span><em>fname</em>, <em>ibrav=4</em>, <em>bc_as_a_ratio=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_Etot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_Etot" title="Permalink to this definition">¶</a></dt>
<dd><p>Read cell parameters <em>(a,b,c)</em> and the corresponding energies from input file <em>fname</em>. 
Each set of cell parameters is stored in a numpy array of lenght 6 
for <em>(a,b,c,alpha,beta,gamma)</em> respectively. This is done for a future possible 
extension but for now only the first 3 elements are used (the others are always 0).
All sets are stored in <em>celldmsx</em> and <em>Ex</em>, the former is a nE*6 matrix, 
the latter is a nE array.</p>
<p><em>ibrav</em> identifies the Bravais lattice as in Quantum Espresso and is needed 
in input (default is 4, i.e. hexagonal cell). The input file format depends
on <em>ibrav</em>, for example in the hex case, the first two columns are for <em>a</em> and
<em>c</em> and the third is for the energies.</p>
<p>If <em>bc_as_a_ratio=True</em>, the input data are assumed to be given as 
<img class="math" src="_images/math/6feb653eb0c50d525d449bc1145229e56ee50dc6.png" alt="(a,b/a,c/a)"/> in the input file and hence converted into <img class="math" src="_images/math/48f6917edfbcd881ae54ffeab449b6658e9e09dc.png" alt="(a,b,c)"/>
which is how they are always stored internally in <code class="xref py py-mod docutils literal"><span class="pre">pyqha</span></code>.</p>
<p>Units must be <img class="math" src="_images/math/d935fd0b17b6d0138bea48d11efd237fba1a7468.png" alt="a.u."/> and <img class="math" src="_images/math/f66ef80fce797aaa395a5db0d9139dc35c1c6b41.png" alt="Ryd/cell"/></p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_EtotV">
<code class="descclassname">pyqha.read.</code><code class="descname">read_EtotV</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_EtotV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_EtotV" title="Permalink to this definition">¶</a></dt>
<dd><p>Read cell volumes and the corresponding energies from input file <em>fname</em>
(1st col, volumes, 2nd col energies). Units must be <img class="math" src="_images/math/2992e67f1f6a95b9e595c21733afd4498b8aa5b8.png" alt="a.u.^3"/> and 
<img class="math" src="_images/math/f66ef80fce797aaa395a5db0d9139dc35c1c6b41.png" alt="Ryd/cell"/></p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_alpha">
<code class="descclassname">pyqha.read.</code><code class="descname">read_alpha</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.read.read_celldmt_hex">
<code class="descclassname">pyqha.read.</code><code class="descname">read_celldmt_hex</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_celldmt_hex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_celldmt_hex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.read.read_dos">
<code class="descclassname">pyqha.read.</code><code class="descname">read_dos</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_dos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_dos" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the phonon density of states (y axis) and the corresponding energies (x axis)
from the input file <em>filename</em> (1st col energies, 2nd col DOS) and store it
in two numpy arrays which are returned.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_dos_geo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_dos_geo</code><span class="sig-paren">(</span><em>fin</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_dos_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_dos_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the phonon density of states and energies as in <a class="reference internal" href="#pyqha.read.read_dos" title="pyqha.read.read_dos"><code class="xref py py-func docutils literal"><span class="pre">read_dos()</span></code></a> from <em>ngeo</em> input files
<em>fin1</em>, <em>fin2</em>, etc. and store it in two numpy matrices which are returned.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_elastic_constants">
<code class="descclassname">pyqha.read.</code><code class="descname">read_elastic_constants</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_elastic_constants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_elastic_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads and returns the elastic constants and compliances from
the file <em>fname</em> .
Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape [6,6]
So, the elastic constant C11 is in C[0,0], C12 in C[0,1] and so on.
Same for the elastic compliances.</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_elastic_constants_geo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_elastic_constants_geo</code><span class="sig-paren">(</span><em>fC</em>, <em>ngeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_elastic_constants_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_elastic_constants_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read elastic constants calculated on a multidimensional grid of lattice parameters
<em>ngeo</em> defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>This funcstion reads the phonon frequencies at each <em>q</em> point from a frequency file.  
Input file has the following format (to be done).</p>
<p>Returning values are a nq*3 matrix q, each q[i] being a q point (vector of 3 elements)
and a nq*modes matrix freq, each element freq[i] being the phonon frequencies
(vector of modes elements)</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq_ext">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq_ext</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq_ext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the phonon frequencies at each q point from a frequency file. The format 
of this file is different from the one read by the function read_freq and
contains usually more frequencies, each with a weight, but no qpoint coordinates.
Input file has the following format:</p>
<p>First line contains n. atoms, nqx, nqy, nqz, nq total.
Second line not read.
Third line: weight of the first qpoint
Following lines: phonon frequencies (their number is modes=3*n. atoms), one per line
then again: weight of the next qpoint, phonon frequencies (3*modes), one per line, etc.</p>
<p>Weights are diffent because of simmetry</p>
<p>Returning values are a nq vector weights, each weights[i] being the weight of a q point 
and a nq*modes matrix freq, each element freq[i] being the phonon frequencies
(vector of modes elements) at the qpoint i</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq_ext_geo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq_ext_geo</code><span class="sig-paren">(</span><em>inputfilefreq</em>, <em>rangegeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq_ext_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq_ext_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the frequencies for all geometries where the gruneisen parameters must be
calculated.</p>
<p>Notes:
nq = qgeo.shape[1] -&gt; total number of q points read
modes = freqgeo.shape[2] -&gt; number of frequency modes</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_freq_geo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_freq_geo</code><span class="sig-paren">(</span><em>inputfilefreq</em>, <em>rangegeo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_freq_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_freq_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the frequencies for all geometries where the gruneisen parameters must be
calculated. Start, stop, step must be given accordingly. It can be used to read
the frequencies only at some geometries from a larger set, if necessary, 
providing the proper start, stop and step values.</p>
<p>Notes:
nq = qgeo.shape[1] -&gt; total number of q points read
modes = freqgeo.shape[2] -&gt; number of frequency modes</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.read.read_thermo">
<code class="descclassname">pyqha.read.</code><code class="descname">read_thermo</code><span class="sig-paren">(</span><em>fname</em>, <em>ngeo=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/read.html#read_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.read.read_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read vibrational thermodynamic functions (Evib, Fvib, Svib, Cvib) as a 
function of temperature from the input file <em>fname</em>. <em>ngeo</em> is the number
of input files to read, corresponding for example to different geometries
in a quasi-harmonic calculation.
If <em>ngeo&gt;1</em> reads from the files <em>fname1</em>, <em>fname2</em>, etc. up to <em>ngeo</em>  
Input file(s) have the following format:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">T</th>
<th class="head"><img class="math" src="_images/math/9fbdb84aec610808b553f187fc1ac99b95993006.png" alt="E_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/55b3ed38f962644f1072ee6a112740f24b78ed7b.png" alt="F_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/1ec0b0b14b11bd65993b7ac59a1fa3b78e78688c.png" alt="S_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/03ba745362038f7a468482e89419d50637d84353.png" alt="C_{vib}"/></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>Lines starting with &#8220;#&#8221; are not read (comments).</p>
<p>Returning values are <img class="math" src="_images/math/368f789921bf6861b596ea6ff0b6d4ca99ad5d5e.png" alt="nT*ngeo"/> numpy matrices (T,Evib,Fvib,Svib,Cvib) containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib[T,geo] -&gt; Fvib at the temperature <em>T</em> for the geometry <em>geo</em></p>
<p>Units must be <em>K</em> for temperature, <em>Ryd/cell</em> for energies, <em>Ryd/cell/K</em> for
entropy and heat capacity.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.thermo">
<span id="pyqha-thermo-module"></span><h2>pyqha.thermo module<a class="headerlink" href="#module-pyqha.thermo" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>TT</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function computes the vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation from the input numpy arrays <em>E</em> 
and <em>dos</em> containing the phonon DOS(E). The calculation is done over a set of
temperatures given in input as a numpy array <em>TT</em>.
It also computes the number of phonon modes obtained from the input DOS (which
must be approximately equal to <img class="math" src="_images/math/7fd84257c87ff8dc9ee27bd300875a6bdc8e2161.png" alt="3*N"/>, with <em>N</em> the number of atoms per cell)
and the ZPE. The input energy and dos are expected to be in 1/cm-1. 
It returns numpy arrays for the following quantities (in this order):
temperatures, vibrational energy, Helmholtz energy, entropy, heat capacity.
Plus it returns the ZPE and number of phonon modes obtained from the input DOS.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">compute_thermo_geo</code><span class="sig-paren">(</span><em>fin</em>, <em>fout=None</em>, <em>ngeo=1</em>, <em>TT=array([1])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#compute_thermo_geo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function reads the input dos file(s) from <em>fin+i</em>, with <em>i</em> a number from
1 to <em>ngeo</em> + 1 and computes vibrational energy, Helmholtz energy, entropy and
heat capacity in the harmonic approximation. Then writes the output on file(s)
if fout!=None.
Output file(s) have the following format:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">T</th>
<th class="head"><img class="math" src="_images/math/9fbdb84aec610808b553f187fc1ac99b95993006.png" alt="E_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/55b3ed38f962644f1072ee6a112740f24b78ed7b.png" alt="F_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/1ec0b0b14b11bd65993b7ac59a1fa3b78e78688c.png" alt="S_{vib}"/></th>
<th class="head"><img class="math" src="_images/math/03ba745362038f7a468482e89419d50637d84353.png" alt="C_{vib}"/></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>and are names <em>fout</em> +1, <em>fout</em> +2,... for each geometry.</p>
<p>Returning values are (len(TT),ngeo) numpy matrices (T,gEvib,gFvib,gSvib,gCvib,gZPE,gmodes) 
containing the 
temperatures and the above mentioned thermodynamic functions as for example:
Fvib[T,geo] -&gt; Fvib at the temperature &#8220;T&#8221; for the geometry &#8220;geo&#8221;</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">dos_integral</code><span class="sig-paren">(</span><em>E</em>, <em>dos</em>, <em>m=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#dos_integral"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>A function to compute the integral of an input phonon DOS (<em>dos</em>) with the 3/8 Simpson method.
<em>m</em> is the moment of the integral, if <img class="math" src="_images/math/9fe942a3b863852d1099e24ee69ed6068dce0933.png" alt="m&gt;0"/> different moments can be calculated.
For example, with <img class="math" src="_images/math/57e7fcd1e7c250f9afe8510738fcc25150cd46f8.png" alt="m=0"/> (default) it returns the number of modes from the dos, 
with <img class="math" src="_images/math/59c39884c40bf8420da99bdbc1f350c83b9acf63.png" alt="m=1"/> it returns the ZPE. The input energy (<em>E</em>) and phonon DOS (<em>dos</em>) are expected to be in
<img class="math" src="_images/math/8ef74976bf2a6e3a7790f40f153ad625f3fb9d60.png" alt="cm^{-1}"/>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">gen_TT</code><span class="sig-paren">(</span><em>Tstart=1</em>, <em>Tend=1000</em>, <em>Tstep=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#gen_TT"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>A simple function to generate a numpy array of temperatures, starting from
<em>Tstart</em> and ending to <em>Tend</em> (or the closest <em>T&lt;Tend</em> accorinding to the <em>Tstep</em> )
with step <em>Tstep</em> .</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pyqha.thermo.</code><code class="descname">rearrange_thermo</code><span class="sig-paren">(</span><em>T</em>, <em>Evib</em>, <em>Fvib</em>, <em>Svib</em>, <em>Cvib</em>, <em>ngeo=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/thermo.html#rearrange_thermo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function just rearranges the order of the elements in the input matrices
The first index of the returning matrices <em>X</em> now gives all geometries at a given
<em>T</em>, i.e. <em>X[0]</em> is the vector of the property <em>X</em> a <em>T=T[0,0]</em> . <em>X[0,0]</em> for the first 
geometry, <em>X[0,1]</em> the second geometry and so on.</p>
</dd></dl>

</div>
<div class="section" id="module-pyqha.write">
<span id="pyqha-write-module"></span><h2>pyqha.write module<a class="headerlink" href="#module-pyqha.write" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyqha.write.write_CT">
<code class="descclassname">pyqha.write.</code><code class="descname">write_CT</code><span class="sig-paren">(</span><em>Ts</em>, <em>CT</em>, <em>fCout=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_CT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_CT" title="Permalink to this definition">¶</a></dt>
<dd><p>Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies!</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_C_geo">
<code class="descclassname">pyqha.write.</code><code class="descname">write_C_geo</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>C</em>, <em>ibrav=4</em>, <em>fCout=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_C_geo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_C_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>Write elastic constants calculated on a multidimensional grid of lattice parameters
ngeo defines the total number of geometries evaluated
Note: the order must be the same as for the total energies in the quasi-harmonic calculations!</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_Etot">
<code class="descclassname">pyqha.write.</code><code class="descname">write_Etot</code><span class="sig-paren">(</span><em>celldmsx</em>, <em>Ex</em>, <em>fname</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_Etot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_Etot" title="Permalink to this definition">¶</a></dt>
<dd><p>Read cell parameters (a,b,c,alpha,beta,gamma) and energies for a grid of cell
parameters values from file output_energy1. 
Each celldms is a vector of lenght 6 containing a,b,c,alpha,beta,gamma respectively
celldmsx and Ex contains the grid of values of celldms and E so that:
celldmsx[0] = celldms0      Ex[0] = E0
celldmsx[1] = celldms1      Ex[1] = E1
celldmsx[2] = celldms2      Ex[2] = E2
........
values are taken from the file &#8220;fname&#8221;
ibrav is the Bravais lattice as in Quantum Espresso and is needed in input (default is cubic)</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_alphaT">
<code class="descclassname">pyqha.write.</code><code class="descname">write_alphaT</code><span class="sig-paren">(</span><em>fname</em>, <em>T</em>, <em>alphaT</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_alphaT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_alphaT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.write.write_celldmsT">
<code class="descclassname">pyqha.write.</code><code class="descname">write_celldmsT</code><span class="sig-paren">(</span><em>fname</em>, <em>T</em>, <em>x</em>, <em>ibrav=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_celldmsT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_celldmsT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.write.write_elastic_constants">
<code class="descclassname">pyqha.write.</code><code class="descname">write_elastic_constants</code><span class="sig-paren">(</span><em>C</em>, <em>S</em>, <em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_elastic_constants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_elastic_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Elastic constants (and elastic compliances) are stored in Voigt notation 
They are then 6x6 matrices, stored as numpy matrices of shape [6,6]
So, the elastic constant C11 is in C[0][0], C12 in C[0][1] and so on.
Same for the elastic compliances</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_freq">
<code class="descclassname">pyqha.write.</code><code class="descname">write_freq</code><span class="sig-paren">(</span><em>qgeo</em>, <em>freq</em>, <em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Write frequencies (or Gruneisen parameters) in a file. In this format also q points
coordinates are written but not the weight of each point.
It can be used to write the Gruneisen mode parameters, giving them in input as freq</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_freq_ext">
<code class="descclassname">pyqha.write.</code><code class="descname">write_freq_ext</code><span class="sig-paren">(</span><em>weights</em>, <em>freq</em>, <em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_freq_ext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_freq_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Write frequencies (or Gruneisen parameters) on an extended mesh in a file.
In this format, q points coordinates are NOT written but the weight of each point yes.
It can be used to write the Gruneisen mode parameters, giving them in input as freq
Write the gruneisen parameters</p>
</dd></dl>

<dl class="function">
<dt id="pyqha.write.write_thermo">
<code class="descclassname">pyqha.write.</code><code class="descname">write_thermo</code><span class="sig-paren">(</span><em>fname</em>, <em>T</em>, <em>Evib</em>, <em>Fvib</em>, <em>Svib</em>, <em>Cvib</em>, <em>ZPE</em>, <em>modes</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_thermo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_thermo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyqha.write.write_xy">
<code class="descclassname">pyqha.write.</code><code class="descname">write_xy</code><span class="sig-paren">(</span><em>fname</em>, <em>x</em>, <em>y</em>, <em>labelx</em>, <em>labely</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyqha/write.html#write_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyqha.write.write_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function writes a quantity y versus quantity x into the file fname.
y and x are arrays and should have the same lenght. labelx and labely
are the axis labels (possibly with units), written in the header of the file
(first line).</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Mauro Palumbo.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5a1.
    </div>
  </body>
</html>